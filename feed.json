{
    "version": "https://jsonfeed.org/version/1",
    "title": "北沐清的博客",
    "subtitle": "Welcome to My Wonderland",
    "icon": "https://erinwithbmq.github.io/images/favicon.ico",
    "description": "Per Aspera, Ad Astra.",
    "home_page_url": "https://erinwithbmq.github.io",
    "items": [
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/COA16/",
            "url": "https://erinwithbmq.github.io/2025/01/11/COA16/",
            "title": "计组期末复习第十六讲 输入输出",
            "date_published": "2025-01-11T11:38:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>LaTeX 渲染有问题。将就着看吧。</p>\n</div>\n<p>能否将外设直接连接到系统总线上？<strong>不可以</strong></p>\n<p>为什么不能把外设直接连接到系统总线上</p>\n<ul>\n<li>\n<p>外设种类繁多，操作方法<strong>多种多样</strong></p>\n</li>\n<li>\n<p>外设的数据传送速度一般比存储器或处理器的<strong>慢得多</strong></p>\n</li>\n<li>\n<p>某些外设的数据传送速度比存储器或处理器<strong>要快</strong></p>\n</li>\n<li>\n<p>外设使用的<strong>数据格式和字长度</strong>通常与处理器不同</p>\n</li>\n</ul>\n<h1 id=\"io-模块\"><a class=\"anchor\" href=\"#io-模块\">#</a> I/O 模块</h1>\n<p>I/O 模块是计算机内部系统和外设之间的桥梁</p>\n<h2 id=\"功能\"><a class=\"anchor\" href=\"#功能\">#</a> 功能</h2>\n<h3 id=\"处理器通信\"><a class=\"anchor\" href=\"#处理器通信\">#</a> 处理器通信</h3>\n<p>命令译码，状态报告，数据，地址识别</p>\n<h3 id=\"设备通信\"><a class=\"anchor\" href=\"#设备通信\">#</a> 设备通信</h3>\n<p>通信内容包含命令、状态信息和数据</p>\n<h3 id=\"数据缓冲\"><a class=\"anchor\" href=\"#数据缓冲\">#</a> 数据缓冲</h3>\n<h3 id=\"控制和定时\"><a class=\"anchor\" href=\"#控制和定时\">#</a> 控制和定时</h3>\n<h3 id=\"检错\"><a class=\"anchor\" href=\"#检错\">#</a> 检错</h3>\n<h2 id=\"外部接口\"><a class=\"anchor\" href=\"#外部接口\">#</a> 外部接口</h2>\n<ul>\n<li>\n<p>并行接口：多根线</p>\n</li>\n<li>\n<p>串行接口：一根线</p>\n</li>\n</ul>\n<h1 id=\"操作技术\"><a class=\"anchor\" href=\"#操作技术\">#</a> 操作技术</h1>\n<h2 id=\"编程式-io\"><a class=\"anchor\" href=\"#编程式-io\">#</a> 编程式 I/O</h2>\n<p>轮询？</p>\n<p>I/O 不会中断处理器，因此处理器需要周期性地检查 I/O 模块的状态，直到发现该操作完成</p>\n<p>CPU 全程 100% 投入</p>\n<p>为了执行 I/O 操作，处理器发送一个指定具体 I/O 模块和外设的地址，并发送一条<strong> I/O 命令</strong></p>\n<p>I/O 指令很容易<strong>映射为 I/O 命令</strong>，并且两者之间通常是简单的一一对应关系</p>\n<p><strong>编址方式</strong></p>\n<ul>\n<li>\n<p>存储器映射式 I/O：合并到指令系统里</p>\n</li>\n<li>\n<p>分离式 I/O：有独立的线</p>\n</li>\n</ul>\n<h2 id=\"中断驱动式-io\"><a class=\"anchor\" href=\"#中断驱动式-io\">#</a> 中断驱动式 I/O</h2>\n<p>中断处理器来进行 I/O 操作</p>\n<p><img data-src=\"/image/COA16/152c3c6e93f27b59af4dc5a626ad1f34.png\" alt=\"152c3c6e93f27b59af4dc5a626ad1f34.png\" /></p>\n<h3 id=\"响应优先级和处理优先级\"><a class=\"anchor\" href=\"#响应优先级和处理优先级\">#</a> 响应优先级和处理优先级</h3>\n<ul>\n<li>\n<p><strong>响应优先级：</strong></p>\n<ul>\n<li>\n<p><strong>响应优先级</strong>决定了<strong>中断控制器</strong>在接收到多个中断信号时，应该<strong>优先响应</strong>哪一个中断请求。</p>\n</li>\n<li>\n<p>响应优先级仅涉及<strong>哪一个中断首先被响应</strong>，不直接决定中断的具体处理时间。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>处理优先级：</strong></p>\n<ul>\n<li>\n<p><strong>处理优先级</strong>决定了<strong> CPU</strong> 在响应中断后，如何分配资源来处理这些中断。</p>\n</li>\n<li>\n<p>处理中断时，可能出现嵌套中断的情况，此时需要根据处理优先级决定是否允许其他中断<strong>打断当前中断</strong>。</p>\n</li>\n<li>\n<p><strong>举例</strong>：如果当前正在处理一个低优先级的中断，但又有一个高优先级的中断到来，则高优先级中断可以中断低优先级中断的处理（称为嵌套中断）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>** 例子：** 假设中断系统中有 4 个中断源，其响应优先级为 L1&gt;L2&gt;L3&gt;L4，处理优先级为 L1&gt;L4&gt;L3&gt;L2。如果在主程序执行时同时发生 L1、L3 和 L4 中断，并且在处理 L3 中断的过程中发生 L2 中断，写出掩码字和所有中断服务程序的过程。</p>\n<p><img data-src=\"/image/COA16/b264a7cd4b7e43fe4e4ce2293b48c6bb.png\" alt=\"b264a7cd4b7e43fe4e4ce2293b48c6bb.png\" /></p>\n<p>** 掩码字：** 为 1 代表可打断，为 0 代表不可打断</p>\n<h1 id=\"直接存储器存取dma\"><a class=\"anchor\" href=\"#直接存储器存取dma\">#</a> 直接存储器存取（DMA）</h1>\n<p>直接存储器存取：无需经过处理器即可<strong>直接访问内存</strong>的模块</p>\n<p>DMA 模块将全部数据块，每次一个字，直接将数据传输到存储器或从存储器读出，<strong>而无需经过处理器</strong></p>\n<p>传输完成时，DMA 模块向处理器发送一个<strong>中断信号</strong></p>\n<p>内存访问时，DMA 优先于 CPU</p>\n<h2 id=\"内存访问\"><a class=\"anchor\" href=\"#内存访问\">#</a> 内存访问</h2>\n<h3 id=\"cpu-停止法\"><a class=\"anchor\" href=\"#cpu-停止法\">#</a> CPU 停止法</h3>\n<p><img data-src=\"/image/COA16/e3fd9487d3368fcc89bfa31c1aeea396.png\" alt=\"e3fd9487d3368fcc89bfa31c1aeea396.png\" /></p>\n<p>直接打断 CPU？</p>\n<p>优点：控制简单</p>\n<p>缺点：影响 CPU，没有充分利用内存</p>\n<p>适用：高速 I/O 设备的块传输</p>\n<h3 id=\"周期窃取\"><a class=\"anchor\" href=\"#周期窃取\">#</a> 周期窃取</h3>\n<p><img data-src=\"/image/COA16/210c6722eefcd38c43f94182d41bac73.png\" alt=\"210c6722eefcd38c43f94182d41bac73.png\" /></p>\n<p>在 CPU 访问的间隔期使用 DMA？</p>\n<p>适用：I/O 周期大于存储周期</p>\n<h3 id=\"交替分时访问\"><a class=\"anchor\" href=\"#交替分时访问\">#</a> 交替分时访问</h3>\n<p><img data-src=\"/image/COA16/3b8b71c86f3097515555f02a285f9db8.png\" alt=\"3b8b71c86f3097515555f02a285f9db8.png\" /></p>\n<p>优点：CPU 未停止或等待，DMA 不请求总线</p>\n<p>缺点：CPU 周期大于存储周期</p>\n<h2 id=\"配置机制\"><a class=\"anchor\" href=\"#配置机制\">#</a> 配置机制</h2>\n<h3 id=\"单总线分离dma\"><a class=\"anchor\" href=\"#单总线分离dma\">#</a> 单总线分离 DMA</h3>\n<p>所有模块<strong>共享相同的系统总线</strong></p>\n<p>DMA 直接连在总线上</p>\n<h3 id=\"单总线集合的dma-io\"><a class=\"anchor\" href=\"#单总线集合的dma-io\">#</a> 单总线集合的 DMA-I/O</h3>\n<p>DMA 逻辑实际上可能是<strong> I/O 模块的一部分</strong>，也可能是控制一个或多个 I/O 模 块的单独模块</p>\n<h3 id=\"io-总线\"><a class=\"anchor\" href=\"#io-总线\">#</a> I/O 总线</h3>\n<p>使用 I/O 总线将 I/O 模块连接到 DMA 模块</p>\n<p>多个 I/O 模块<strong>共享 DMA</strong>，且易于扩展</p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "计算机组织结构",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/COA15/",
            "url": "https://erinwithbmq.github.io/2025/01/11/COA15/",
            "title": "计组期末复习第十五讲 控制器",
            "date_published": "2025-01-11T11:37:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>LaTeX 渲染有问题。将就着看吧。</p>\n</div>\n<h2 id=\"寄存器\"><a class=\"anchor\" href=\"#寄存器\">#</a> 寄存器</h2>\n<h3 id=\"分类\"><a class=\"anchor\" href=\"#分类\">#</a> 分类</h3>\n<ul>\n<li>\n<p><strong>用户可见寄存器</strong></p>\n<ul>\n<li>\n<p>通用寄存器</p>\n</li>\n<li>\n<p>数据寄存器</p>\n</li>\n<li>\n<p>地址寄存器</p>\n</li>\n<li>\n<p>条件码寄存器</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>控制和状态寄存器</strong></p>\n<ul>\n<li>\n<p>程序计数器 PC</p>\n</li>\n<li>\n<p>指令寄存器 IR</p>\n</li>\n<li>\n<p>存储器地址寄存器 MAR</p>\n</li>\n<li>\n<p>存储器缓冲寄存器 MBR（或者说是 MDR）</p>\n</li>\n<li>\n<p>程序状态字 PSW</p>\n</li>\n<li>\n<p>设计出发点：对操作系统的支持 / 控制信息在寄存器和存储器之间的分配</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>两者的区分并不严格</strong></p>\n<h2 id=\"微操作\"><a class=\"anchor\" href=\"#微操作\">#</a> 微操作</h2>\n<p><img data-src=\"/image/COA15/b6c20b22a81a5a2cebd5c3a4ead6bb1d.png\" alt=\"b6c20b22a81a5a2cebd5c3a4ead6bb1d.png\" /></p>\n<h3 id=\"微操作分组的原则\"><a class=\"anchor\" href=\"#微操作分组的原则\">#</a> 微操作分组的原则</h3>\n<ul>\n<li>\n<p>事件的流动顺序必须是恰当的</p>\n</li>\n<li>\n<p>必须避免冲突</p>\n</li>\n<li>\n<p>满足上述条件下，所用的时间单位尽可能少</p>\n</li>\n</ul>\n<h3 id=\"子周期\"><a class=\"anchor\" href=\"#子周期\">#</a> 子周期</h3>\n<ul>\n<li>\n<p>取指周期</p>\n</li>\n<li>\n<p>间址周期</p>\n<ul>\n<li>\n<p>如果指令采用<strong>间接寻址</strong>，则在指令执行前有一个间址周期</p>\n</li>\n<li>\n<p>完成间址周期后，IR 的状态与不使用间接寻址方式的状态是相同的，已经为执行周期准备就绪</p>\n</li>\n</ul>\n<p><img data-src=\"/image/COA15/d024815799acb7ad9c48d35841d71c14.png\" alt=\"d024815799acb7ad9c48d35841d71c14.png\" /></p>\n<p>即将 IR 存储指令内的地址部分存入 MAR，读出数据后存入 MBR，MBR 将更新后的地址再存入 IR 指令内的地址部分</p>\n</li>\n<li>\n<p>执行周期</p>\n</li>\n<li>\n<p>中断周期</p>\n<ul>\n<li>\n<p>在完成执行周期时，要确定是否有允许的中断产生</p>\n</li>\n<li>\n<p>如果有，则出现一个中断周期</p>\n</li>\n<li>\n<p>下图是微操作示意。注意微操作的分组</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"/image/COA15/3b90fbf4a75322625f8095c67ea53369.png\" alt=\"3b90fbf4a75322625f8095c67ea53369.png\" /></p>\n<h3 id=\"指令周期代码-icc\"><a class=\"anchor\" href=\"#指令周期代码-icc\">#</a> 指令周期代码 ICC</h3>\n<p>00：取指</p>\n<p>01：间址</p>\n<p>10：执行</p>\n<p>11：中断</p>\n<h2 id=\"控制器\"><a class=\"anchor\" href=\"#控制器\">#</a> 控制器</h2>\n<h3 id=\"输入\"><a class=\"anchor\" href=\"#输入\">#</a> 输入</h3>\n<ul>\n<li>\n<p>指令寄存器：当前指令的寻址方式和操作码</p>\n</li>\n<li>\n<p>标志：确定 CPU 的状态和前一个 ALU 操作的结果</p>\n</li>\n<li>\n<p>时钟：控制器要在每个时钟脉冲完成一个或一组同时的微操作</p>\n</li>\n<li>\n<p>来自控制总线的控制信号：向控制器提供控制<s>信号</s>（请求）比如中断请求</p>\n</li>\n</ul>\n<h3 id=\"输出\"><a class=\"anchor\" href=\"#输出\">#</a> 输出</h3>\n<p>控制信号</p>\n<ul>\n<li>\n<p>CPU 内</p>\n</li>\n<li>\n<p>控制总线</p>\n<ul>\n<li>存储器、IO 模块</li>\n</ul>\n</li>\n</ul>\n<p>控制门的开关，从而控制数据传递</p>\n<p>所有的控制信号最终作为二进制输入量直接输入到各个逻辑门上</p>\n<h3 id=\"控制器的最小特性\"><a class=\"anchor\" href=\"#控制器的最小特性\">#</a> 控制器的最小特性</h3>\n<p>它只需要知道将被执行的指令和算术、逻辑运算结果的性质（如正负、溢出 等），而不需要知道正被处理的数据或得到的实际结果具体是什么</p>\n<p>它只是以少量的送到 CPU 内的和送到系统总线上的控制信号来实现控制</p>\n<h3 id=\"功能需求\"><a class=\"anchor\" href=\"#功能需求\">#</a> 功能需求</h3>\n<h4 id=\"cpu的基本元素\"><a class=\"anchor\" href=\"#cpu的基本元素\">#</a> CPU 的基本元素</h4>\n<p>ALU，寄存器组，内部数据通路，控制器，外部数据通路</p>\n<h4 id=\"cpu需要完成的微操作\"><a class=\"anchor\" href=\"#cpu需要完成的微操作\">#</a> CPU 需要完成的微操作</h4>\n<ul>\n<li>\n<p>在寄存器之间传送数据</p>\n</li>\n<li>\n<p>将数据由寄存器传送到外部接口（如系统总线）</p>\n</li>\n<li>\n<p>将数据由外部接口传送到寄存器</p>\n</li>\n<li>\n<p>将寄存器作为输入和输出，完成算术和逻辑运算</p>\n</li>\n</ul>\n<h3 id=\"实现\"><a class=\"anchor\" href=\"#实现\">#</a> 实现</h3>\n<ul>\n<li>\n<p><strong>硬布线实现</strong>（hardwired implementation）</p>\n</li>\n<li>\n<p><strong>微程序实现</strong>（microprogrammed implementation）</p>\n</li>\n</ul>\n<h4 id=\"硬布线实现\"><a class=\"anchor\" href=\"#硬布线实现\">#</a> 硬布线实现</h4>\n<p>控制器是一个组合电路，把输入逻辑信号转换为一组输出逻辑信号，即控制信号</p>\n<h4 id=\"微程序实现\"><a class=\"anchor\" href=\"#微程序实现\">#</a> 微程序实现</h4>\n<p>控制逻辑是微程序指定的，控制器是一个相对简单的逻辑电路，通过执行每条微指令来产生控制信号</p>\n<p>微程序（固件）介于硬件与软件之间</p>\n<p><strong>优点与缺点：</strong></p>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>\n<p>简化了控制器的设计任务</p>\n</li>\n<li>\n<p>实现起来既成本较低，也能减少出错机会</p>\n</li>\n<li>\n<p>便于更新</p>\n</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>要比采用相同或相近半导体工艺的硬布线控制器慢一些</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "计算机组织结构",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/COA14/",
            "url": "https://erinwithbmq.github.io/2025/01/11/COA14/",
            "title": "计组期末复习第十四讲 指令周期与指令流水线",
            "date_published": "2025-01-11T11:36:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>LaTeX 渲染有问题。将就着看吧。</p>\n</div>\n<h2 id=\"指令周期\"><a class=\"anchor\" href=\"#指令周期\">#</a> 指令周期</h2>\n<p>指令周期：处理单个指令的过程（时间）</p>\n<p>取指周期：从内存中提取一条指令</p>\n<p>执行周期：执行所提取的指令</p>\n<p>还可能有中断周期、间址周期</p>\n<h3 id=\"间址周期\"><a class=\"anchor\" href=\"#间址周期\">#</a> 间址周期</h3>\n<p>间址周期：把间接地址的读取看成是一个额外的指令子周期</p>\n<p><img data-src=\"/image/COA14/274c366cb6404d1a22a876a8e6ac932a.png\" alt=\"274c366cb6404d1a22a876a8e6ac932a.png\" /></p>\n<h2 id=\"cpu-的任务与需求\"><a class=\"anchor\" href=\"#cpu-的任务与需求\">#</a> CPU 的任务与需求</h2>\n<p><img data-src=\"/image/COA14/3882187eb23f1c685343376c0070d4fc.png\" alt=\"3882187eb23f1c685343376c0070d4fc.png\" /></p>\n<p>取指令（从特定地方获取），解释指令（译码），取数据（从特定地方获取），处理数据（如进行算术运算），写数据（写入特定地方）</p>\n<h2 id=\"数据流\"><a class=\"anchor\" href=\"#数据流\">#</a> 数据流</h2>\n<h3 id=\"取值周期\"><a class=\"anchor\" href=\"#取值周期\">#</a> 取值周期</h3>\n<ol>\n<li>\n<p>控制器下达指令：取指周期的开始。</p>\n</li>\n<li>\n<p>通过 MAR 将地址传入地址总线</p>\n<p>控制器通过控制线通知存储器地址就绪</p>\n<p>存储器读取地址</p>\n</li>\n<li>\n<p>存储器通过数据总线将数据发送给 MBR</p>\n<p>如果是异步总线，存储器提供反馈</p>\n</li>\n<li>\n<p>指令取回来后，PC+“1”</p>\n</li>\n</ol>\n<h3 id=\"间址周期-2\"><a class=\"anchor\" href=\"#间址周期-2\">#</a> 间址周期</h3>\n<p>将 MBR 中的<strong>地址引用送入 MAR</strong> 得到地址</p>\n<p>MAR 将地址传入地址总线</p>\n<p>控制器通知<strong>存储器取地址</strong></p>\n<p>存储器通过数据总线将<strong>有效地址发送给 MBR</strong></p>\n<h3 id=\"中断周期\"><a class=\"anchor\" href=\"#中断周期\">#</a> 中断周期</h3>\n<p>处理中断前，将下一条指令放到 MBR 中，再放到数据总线上</p>\n<p>控制器将下一条指令的取值地址通过 MAR 放到地址总线上</p>\n<p>控制器通知存储器获得数据</p>\n<p>存储器从地址线获得地址</p>\n<p>存储器从数据线获得数据，并将数据写入到获得的地址</p>\n<h2 id=\"指令流水线\"><a class=\"anchor\" href=\"#指令流水线\">#</a> 指令流水线</h2>\n<h3 id=\"两阶段方法\"><a class=\"anchor\" href=\"#两阶段方法\">#</a> 两阶段方法</h3>\n<p>将指令处理分成两个阶段：取指令和执行指令</p>\n<h3 id=\"六阶段方法\"><a class=\"anchor\" href=\"#六阶段方法\">#</a> 六阶段方法</h3>\n<p>为了进一步的加速，流水线必须有<strong>更多的阶段</strong></p>\n<p>• <strong>取指令</strong>（Fetch instruction，FI）：读下一条预期的指令到缓冲器</p>\n<p>• <strong>译码指令</strong>（Decode instruction，DI）：确定操作码和操作数指定符</p>\n<p>• <strong>计算操作数</strong>（Calculate operands，CO）：计算每个源操作数的有效地址</p>\n<p>• <strong>取操作数</strong>（Fetch operands，FO）：从存储器取出每个操作数，寄存器 中的操作数不需要取</p>\n<p>• <strong>执行指令</strong>（Execute instruction，EI）：完成指定的操作。若有指定的目 的操作数位置，则将结果写入此位置</p>\n<p>• <strong>写操作数</strong>（Write operand，WO）：将结果存入存储器</p>\n<h3 id=\"流水线性能\"><a class=\"anchor\" href=\"#流水线性能\">#</a> 流水线性能</h3>\n<p><img data-src=\"/image/COA14/75a8ce7a9da4d09beba328505bcfb97c.png\" alt=\"75a8ce7a9da4d09beba328505bcfb97c.png\" /></p>\n<p><strong>加速比：</strong></p>\n<p><img data-src=\"/image/COA14/37ed6e00bc2d027c051bd3f8c389dbf7.png\" alt=\"37ed6e00bc2d027c051bd3f8c389dbf7.png\" /></p>\n<p k+(n-1)=\"\">S_k = \\frac{T_{1,n}}{T_{k,n}} = \\frac{nkt}{[k+(n-1)]t}=\\frac{nk}</p>\n<h2 id=\"冒险\"><a class=\"anchor\" href=\"#冒险\">#</a> 冒险</h2>\n<h3 id=\"数据冒险\"><a class=\"anchor\" href=\"#数据冒险\">#</a> 数据冒险</h3>\n<p>数据依赖性</p>\n<p>有些数据要等前序计算完成</p>\n<p>解决方案 1：插入<strong> nop 指令</strong>（软件）（不进行任何操作）</p>\n<p>解决方案 2：插入<strong> bubble</strong>（硬件）</p>\n<p>解决方案 3：前递（forwarding）/ <strong>旁路</strong>（bypassing）（快速传递数据）</p>\n<p>解决方案 4：<strong>交换</strong>指令顺序</p>\n<h3 id=\"控制冒险\"><a class=\"anchor\" href=\"#控制冒险\">#</a> 控制冒险</h3>\n<p>指令的执行顺序被更改</p>\n<p>解决方案 1：<strong>提早确定</strong>分支</p>\n<p>解决方案 2：取<strong>多条指令</strong></p>\n<p>解决方案 3：分支<strong>预测</strong></p>\n<p>静态预测（规则不变）</p>\n<p>动态预测（规则变化）</p>\n<p>解决方案 4：<strong>交换</strong>指令顺序</p>\n<h3 id=\"结构冒险\"><a class=\"anchor\" href=\"#结构冒险\">#</a> 结构冒险</h3>\n<p>已进入流水线的不同指令在同一时刻访问相同的硬件资源（内存或寄存器）</p>\n<p>解决：使用多个不同的硬件资源，或者分时使用同一个硬件资源</p>\n<p>解决方案 1：流水线停顿（stall），<strong>插入空泡</strong>（bubble）</p>\n<p>解决方案 2：使用不同用途的<strong>多个存储器</strong></p>\n<p>解决方案 3：同一个存储器提供<strong>分时处理</strong></p>\n<p>下面是 GPT 写的：</p>\n<p>在计算机体系结构中，** 冒险（Hazard）** 是指在指令流水线（Pipeline）中，由于某些原因，指令无法按预期执行，导致执行暂停或结果错误。冒险通常分为三种类型：结构冒险、数据冒险和控制冒险。下面分别介绍这三种冒险：</p>\n<h3 id=\"1-结构冒险structural-hazard\"><a class=\"anchor\" href=\"#1-结构冒险structural-hazard\">#</a> 1. 结构冒险（Structural Hazard）</h3>\n<p><strong>定义</strong>：结构冒险是由于硬件资源冲突导致的流水线停顿，通常发生在多个指令需要同时使用相同硬件资源时，导致资源无法同时满足所有指令的需求。</p>\n<p><strong>原因</strong>：</p>\n<ul>\n<li>\n<p>指令流水线中的不同阶段可能会共享相同的硬件资源，例如 ALU（算术逻辑单元）、寄存器堆、内存总线等。</p>\n</li>\n<li>\n<p>如果两个或多个指令在同一时刻需要访问相同的硬件资源，硬件资源就无法同时满足所有指令的需求，从而引发结构冒险。</p>\n</li>\n</ul>\n<p><strong>例子</strong>：</p>\n<ul>\n<li>\n<p>在一个简单的流水线中，如果同时有两条指令需要访问内存（例如一条加载指令和一条存储指令），而只有一个内存访问单元时，就会发生结构冒险。</p>\n</li>\n<li>\n<p>类似地，如果同一时刻多个指令需要访问 ALU，但 ALU 资源有限，也可能发生结构冒险。</p>\n</li>\n</ul>\n<p><strong>解决方法</strong>：</p>\n<ul>\n<li>\n<p>增加硬件资源（如多路复用器、独立的内存访问端口等）。</p>\n</li>\n<li>\n<p>使用流水线阶段的资源调度技术，确保指令不同时访问相同的资源。</p>\n</li>\n</ul>\n<h3 id=\"2-数据冒险data-hazard\"><a class=\"anchor\" href=\"#2-数据冒险data-hazard\">#</a> 2. 数据冒险（Data Hazard）</h3>\n<p><strong>定义</strong>：数据冒险发生在指令间存在数据依赖时，前序指令的结果尚未计算出来，后续指令需要依赖该结果，从而导致停顿或错误。</p>\n<p><strong>数据冒险类型</strong>：</p>\n<ul>\n<li>\n<p><strong>读后写（RAW，Read After Write）</strong>：也称为真正的数据依赖。后续指令需要读取前序指令计算的结果，但该结果尚未写回寄存器或内存，导致后续指令无法执行。</p>\n<p><strong>例子</strong>：</p>\n  <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD R1, R2, R3  // R1 = R2 + R3</span><br><span class=\"line\">SUB R4, R1, R5  // 需要R1的值，但R1尚未计算出来</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在此例中，第二条指令需要依赖第一条指令计算的 R1 的值，但由于第一条指令尚未完成，第二条指令不能立即执行。</li>\n</ul>\n</li>\n<li>\n<p><strong>写后读（WAR，Write After Read）</strong>：后续指令写入寄存器的值会覆盖前序指令的结果，导致数据依赖错误。</p>\n<p><strong>例子</strong>：</p>\n  <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD R1, R2, R3  // R1 = R2 + R3</span><br><span class=\"line\">SUB R2, R1, R5  // 需要R1的值，但R2被后续指令修改</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>写后写（WAW，Write After Write）</strong>：前序指令和后续指令都试图向同一寄存器写值，顺序不一致会导致数据错误。</p>\n<p><strong>例子</strong>：</p>\n  <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD R1, R2, R3  // R1 = R2 + R3</span><br><span class=\"line\">SUB R1, R4, R5  // R1被修改</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>解决方法</strong>：</p>\n<ul>\n<li>\n<p><strong>流水线插入气泡（Pipeline Stalls）</strong>：通过插入 “空指令”（气泡）来等待读取数据，减少数据依赖冲突。</p>\n</li>\n<li>\n<p><strong>数据前推（Data Forwarding/Bypassing）</strong>：将计算结果直接从一个流水线阶段传送到需要的后续阶段，避免等待数据写回寄存器。</p>\n</li>\n<li>\n<p><strong>重排序（Instruction Reordering）</strong>：重新排列指令的顺序，避免数据依赖冲突。</p>\n</li>\n</ul>\n<h3 id=\"3-控制冒险control-hazard\"><a class=\"anchor\" href=\"#3-控制冒险control-hazard\">#</a> 3. 控制冒险（Control Hazard）</h3>\n<p><strong>定义</strong>：控制冒险是由于程序中的控制指令（如跳转、分支等）导致流水线不能确定下一条指令是哪一条，从而发生停顿或错误。</p>\n<p><strong>原因</strong>：</p>\n<ul>\n<li>\n<p>当程序遇到分支指令时，流水线无法提前知道分支的目标地址，因此必须等待分支指令执行完成以确定跳转的目标。</p>\n</li>\n<li>\n<p>这通常发生在条件分支指令（如 <code>if</code>  语句、循环等）和无条件跳转指令（如 <code>goto</code> 、 <code>return</code>  等）之后。</p>\n</li>\n</ul>\n<p><strong>例子</strong>：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BEQ R1, R2, <span class=\"selector-tag\">LABEL</span>  // 如果R1 == R2，跳转到<span class=\"selector-tag\">LABEL</span></span><br><span class=\"line\">ADD R3, R4, R5     // 该指令要等BEQ完成才能执行，因为BEQ决定了跳转</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在此例中， <code>BEQ</code>  指令的执行结果不确定，直到它被完全执行后，流水线才能知道是否跳转以及跳转到哪个地址，从而导致控制冒险。</li>\n</ul>\n<p><strong>解决方法</strong>：</p>\n<ul>\n<li>\n<p><strong>分支预测（Branch Prediction）</strong>：根据历史执行模式预测分支的方向，提前加载指令。如果预测正确，可以减少控制冒险的影响。</p>\n</li>\n<li>\n<p><strong>延迟分支（Delayed Branch）</strong>：在分支指令后插入一条可以执行的指令，即使分支未确定，流水线仍然可以继续执行。</p>\n</li>\n<li>\n<p><strong>动态分支预测（Dynamic Branch Prediction）</strong>：使用硬件动态调整分支预测策略，通过复杂的算法来预测跳转指令的目标。</p>\n</li>\n<li>\n<p><strong>提早确定分支</strong>（？）</p>\n</li>\n</ul>\n<hr />\n<p>总结来说，冒险的出现是因为流水线中的不同阶段存在相互依赖和硬件资源竞争。通过优化硬件和采用各种技术（如数据前推、分支预测等），可以最大限度地减少冒险对流水线性能的影响。</p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "计算机组织结构",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/COA13/",
            "url": "https://erinwithbmq.github.io/2025/01/11/COA13/",
            "title": "计组期末复习第十三讲 指令系统",
            "date_published": "2025-01-11T11:34:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>LaTeX 渲染有问题。将就着看吧。</p>\n</div>\n<h1 id=\"指令\"><a class=\"anchor\" href=\"#指令\">#</a> 指令</h1>\n<p>指令是计算机处理的最基本单位</p>\n<p>操作码（指令执行的内容）+ 操作数（要操作的对象）</p>\n<p>多周期实现方案</p>\n<ul>\n<li>\n<p>取指令</p>\n</li>\n<li>\n<p>译码 / 取寄存器</p>\n</li>\n<li>\n<p>执行 / 有效地址 / 完成分支</p>\n</li>\n<li>\n<p>访问内存，存储结果</p>\n</li>\n</ul>\n<p>要素：</p>\n<ul>\n<li>\n<p>操作码</p>\n</li>\n<li>\n<p>源操作数引用</p>\n</li>\n<li>\n<p>结果操作数引用</p>\n</li>\n<li>\n<p>下一指令引用</p>\n</li>\n</ul>\n<h2 id=\"指令格式\"><a class=\"anchor\" href=\"#指令格式\">#</a> 指令格式</h2>\n<h3 id=\"扩展操作码\"><a class=\"anchor\" href=\"#扩展操作码\">#</a> 扩展操作码</h3>\n<p>不同地址数的指令具有不同长度的操作码</p>\n<p><img data-src=\"/image/COA13/849b68ccb8402d2588526f25cb5f9d30.png\" alt=\"849b68ccb8402d2588526f25cb5f9d30.png\" /></p>\n<p>怎么区分？<strong>看最前面有多少个 1</strong>.</p>\n<p>例题：</p>\n<p>假设指令字长为 16 位，操作数的地址码为 6 位，指令有零地址、一地址、二地址 3 种格式。</p>\n<ol>\n<li>\n<p>设操作码固定，若零地址指令有 M 种，一地址指令有 N 种，则二地址指令最多有几种？</p>\n<p>由于操作码固定，最多有二地址，则 16 - 6 * 2 = 4，操作码有 4 位</p>\n<p>那么总共有 16 种指令。</p>\n<p>二地址指令有 16 - M - N 种。</p>\n</li>\n<li>\n<p>采用扩展操作码技术，二地址指令最多有几种？</p>\n<p>对于二地址指令操作码有 4 位，<strong>全 1 不可用</strong></p>\n<p>0000~1110, 15 种</p>\n</li>\n<li>\n<p>采用扩展操作码技术，若二地址指令有 P 条，零地址指令有 Q 条，则一地址指令最多有几种？</p>\n<p>2^4 - P：二地址没有用的操作码（指令前缀）个数（4 位）</p>\n<p>(2^4 - P）* 2^6：一地址总共可以表示的总数（一地址操作码为 10 位）</p>\n<p>(2^4 - P）* 2^6 - R：一地址没有用的操作码个数</p>\n<p>[(2^4 - P）* 2^6 - R] * 2^6：零地址总共可以表示的总数</p>\n<p><em><em>Q = [(2^4 - P）</em> 2^6 - R] * 2^6</em>*</p>\n</li>\n</ol>\n<h2 id=\"寻址方式\"><a class=\"anchor\" href=\"#寻址方式\">#</a> 寻址方式</h2>\n<h3 id=\"记号\"><a class=\"anchor\" href=\"#记号\">#</a> 记号</h3>\n<ul>\n<li>\n<p>A: 指令中地址字段的内容</p>\n</li>\n<li>\n<p>R: 指向寄存器的指令地址字段内容</p>\n</li>\n<li>\n<p>EA: 被访问位置的实际（有效）地址</p>\n</li>\n<li>\n<p>(X): <strong>存储器位置 X 或寄存器 X 的内容</strong></p>\n</li>\n<li>\n<p><strong>操作数 = (EA)，即操作数为 EA 内的内容</strong></p>\n</li>\n</ul>\n<h3 id=\"立即寻址\"><a class=\"anchor\" href=\"#立即寻址\">#</a> 立即寻址</h3>\n<p>操作数 = A</p>\n<p>立即数。</p>\n<h3 id=\"直接寻址\"><a class=\"anchor\" href=\"#直接寻址\">#</a> 直接寻址</h3>\n<p>EA = A</p>\n<p>把地址写在指令里面，进行一次存储器访问</p>\n<h3 id=\"间接寻址\"><a class=\"anchor\" href=\"#间接寻址\">#</a> 间接寻址</h3>\n<p>EA = (A)</p>\n<p>两次存储器访问</p>\n<p><img data-src=\"/image/COA13/7d5f5a89194f02dff0ad79122ad99017.png\" alt=\"7d5f5a89194f02dff0ad79122ad99017.png\" /></p>\n<h3 id=\"寄存器寻址\"><a class=\"anchor\" href=\"#寄存器寻址\">#</a> 寄存器寻址</h3>\n<p>EA = R</p>\n<p>给出寄存器编号，读寄存器内的值</p>\n<h3 id=\"寄存器间接寻址\"><a class=\"anchor\" href=\"#寄存器间接寻址\">#</a> 寄存器间接寻址</h3>\n<p>EA = (R)</p>\n<p>寄存器里存的是地址，拿到地址再读一次存储器</p>\n<h3 id=\"偏移寻址\"><a class=\"anchor\" href=\"#偏移寻址\">#</a> 偏移寻址</h3>\n<p>EA = (R) + A</p>\n<p>在读出的地址上加一个立即数得到新的地址</p>\n<p>类型</p>\n<p>相对寻址</p>\n<p>基址寄存器寻址</p>\n<p>变址寻址</p>\n<h4 id=\"偏移寻址相对寻址\"><a class=\"anchor\" href=\"#偏移寻址相对寻址\">#</a> 偏移寻址：相对寻址</h4>\n<p>隐含引用的寄存器是程序计数器（PC）</p>\n<p>EA = (PC) + A</p>\n<p>在 PC 寄存器读出的地址上加一个立即数得到新的地址</p>\n<h4 id=\"偏移寻址基址寄存器寻址\"><a class=\"anchor\" href=\"#偏移寻址基址寄存器寻址\">#</a> 偏移寻址：基址寄存器寻址</h4>\n<p>EA = (B) + A</p>\n<p>在寄存器读出的地址上加一个立即数得到新的地址</p>\n<h4 id=\"偏移寻址变址寻址\"><a class=\"anchor\" href=\"#偏移寻址变址寻址\">#</a> 偏移寻址：变址寻址</h4>\n<p>EA = A + (IX)</p>\n<p>A 是基地址，从寄存器 IX 里读出一个数与它相加得到新的地址</p>\n<h3 id=\"栈寻址\"><a class=\"anchor\" href=\"#栈寻址\">#</a> 栈寻址</h3>\n<p>方式：栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种<strong>寄存器间接寻址方式</strong></p>\n<h2 id=\"指令格式的设计原则\"><a class=\"anchor\" href=\"#指令格式的设计原则\">#</a> 指令格式的设计原则</h2>\n<p>指令尽量短</p>\n<p>有足够的操作码位数</p>\n<p>操作码的编码必须有唯一的解释</p>\n<p>指令长度是字节的整数倍</p>\n<p>合理选择地址字段的个数</p>\n<p>指令尽量规整</p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "计算机组织结构",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/COA12/",
            "url": "https://erinwithbmq.github.io/2025/01/11/COA12/",
            "title": "计组期末复习第十二讲 总线",
            "date_published": "2025-01-11T11:33:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>LaTeX 渲染有问题。将就着看吧。</p>\n</div>\n<p><strong>类型</strong></p>\n<ul>\n<li>\n<p><strong>芯片内部总线</strong></p>\n</li>\n<li>\n<p><strong>系统总线</strong></p>\n</li>\n<li>\n<p><strong>通信总线</strong></p>\n</li>\n</ul>\n<h1 id=\"总线结构\"><a class=\"anchor\" href=\"#总线结构\">#</a> 总线结构</h1>\n<h3 id=\"数据线\"><a class=\"anchor\" href=\"#数据线\">#</a> 数据线</h3>\n<p>在<strong>系统组件</strong>之间传输数据</p>\n<p>数据线的数量决定了一次可以<strong>传输的数据的大小</strong></p>\n<h3 id=\"地址线\"><a class=\"anchor\" href=\"#地址线\">#</a> 地址线</h3>\n<p>在数据线和地址 I/O 端口上指定数据的来源和去向</p>\n<p>地址线的数量决定了<strong>寻址空间</strong>的大小</p>\n<p>即：如果寻址空间为 2^32，那么地址线有 32 根</p>\n<p>两台地址线数量相同的计算机，寻址空间的大小一样吗？</p>\n<p>其理论寻址空间是相同的，但 <strong>实际寻址空间大小</strong> 和 <strong>使用方式</strong> 可能不同，取决于多种其他因素。</p>\n<h3 id=\"控制线\"><a class=\"anchor\" href=\"#控制线\">#</a> <strong>控制线</strong></h3>\n<p>控制对数据线和地址线的存取和使用</p>\n<p>・时钟（clock）：用于总线同步操作</p>\n<p>・总线请求（bus request）：表示模块需要获得对总线的控制</p>\n<p>・总线允许（bus grant）：发出请求的设备已经被允许控制总线</p>\n<p>・中断请求（interrupt request）：表示某个中断正在悬而未决</p>\n<p>・中断响应（interrupt ACK）：未决的终端请求被响应</p>\n<p>・存储器读（memory read）：从存储器读数据到总线</p>\n<p>・存储器写（memory write）：将数据从总线写入存储器</p>\n<p>・I/O 读（I/O read）：从 I/O 端口读数据到总线</p>\n<p>・I/O 写（I/O write）：将数据从总线写入 I/O 端口</p>\n<p>• ……</p>\n<h1 id=\"总线上数据传输的特点\"><a class=\"anchor\" href=\"#总线上数据传输的特点\">#</a> 总线上数据传输的特点</h1>\n<p>总线可以被<strong>多个设备监听</strong>，但同一时刻只能由<strong>一个设备</strong>发送数据</p>\n<p>当总线在被使用过程中，其它设备<strong>不可以抢占</strong></p>\n<p>如果设备想发送数据 / 请求数据，需要先<strong>获得总线的使用权</strong></p>\n<h1 id=\"设计要素\"><a class=\"anchor\" href=\"#设计要素\">#</a> 设计要素</h1>\n<h2 id=\"用途\"><a class=\"anchor\" href=\"#用途\">#</a> 用途</h2>\n<p><strong>专用（dedicated）总线</strong>：始终只负责一项功能，或始终分配给特定的计算 机组件</p>\n<p><strong>复用（multiplexed）总线</strong>：将同一线路用于多种用途</p>\n<h2 id=\"仲裁与仲裁方案\"><a class=\"anchor\" href=\"#仲裁与仲裁方案\">#</a> 仲裁与仲裁方案</h2>\n<p>当多个设备需要与总线通信时，通过某种策略选择一个设备</p>\n<p>仲裁方案：</p>\n<ul>\n<li>\n<p><strong>集中式</strong>（centralized）：由<strong>仲裁器</strong>（arbiter）或<strong>总线控制器</strong>（bus controller）负责<strong>分配总线使用权</strong></p>\n<ul>\n<li>\n<p>链式查询 / 菊花链</p>\n</li>\n<li>\n<p>计数器查询</p>\n</li>\n<li>\n<p>独立请求</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>分布式</strong>（distributed）：每个设备都包含访问控制逻辑，各设备共同作用分享总线</p>\n<ul>\n<li>\n<p>自举式</p>\n</li>\n<li>\n<p>冲突检测</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"链式查询\"><a class=\"anchor\" href=\"#链式查询\">#</a> 链式查询</h3>\n<p>所有的设备都是<strong>串行连接</strong>的，并将<strong>允许信号</strong>从<strong>优先级最高</strong>的设备下发到<strong>优先级最低</strong>的设备。</p>\n<p>总线仲裁器收到请求后，在<strong>总线不忙</strong>的前提下，发起<strong>允许信号</strong></p>\n<p>如果某个设备<strong>收到了允许信号</strong>并且<strong>发起了总线请求</strong>，该设备将总线设置为<strong>繁忙</strong>状态，允许信号将不再被进一步传递</p>\n<p><img data-src=\"/image/COA12/197144221c5fbc9c6e686b852fcca5b9.png\" alt=\"197144221c5fbc9c6e686b852fcca5b9.png\" /></p>\n<p>确定优先级简单，可以灵活添加设备，但是不能保证公平性，限制总线的速度。</p>\n<h3 id=\"计数器查询\"><a class=\"anchor\" href=\"#计数器查询\">#</a> 计数器查询</h3>\n<p>将总线允许线替换为<strong>设备 ID（地址）线</strong></p>\n<p>当总线仲裁器收到总线请求信号，判断总线<strong>空闲</strong>时，计数器开始计数，计数值通过<strong>设备 ID 线</strong>发向各个部件</p>\n<p>如果当前发送请求的设备 ID<strong> 等于</strong>裁决器当前的计数，裁决器将停止计数，设备将总线设置为<strong>繁忙</strong></p>\n<p>人话就是仲裁器依次从高往低询问每个设备要不要使用总线，如果当前设备请求总线，则赋予其总线控制权，如果没有请求，则<strong>继续查询</strong>下一个设备。</p>\n<p>一旦某个设备获得总线控制权，其他设备需要等待其释放总线后才能竞争。</p>\n<p>强调优先级和公平性，但是限制总线的速度。</p>\n<p><img data-src=\"/image/COA12/345f37f2276b2624abadc1b28b3391b8.png\" alt=\"345f37f2276b2624abadc1b28b3391b8.png\" /></p>\n<h3 id=\"独立请求\"><a class=\"anchor\" href=\"#独立请求\">#</a> 独立请求</h3>\n<p>每个设备都有自己的<strong>总线请求线和总线允许线</strong></p>\n<p>总线仲裁器决定哪个设备可以使用总线</p>\n<p>有很多确定策略：固定优先级，公平链式，LRU，FIFO，…</p>\n<p>快速响应，可编程的优先级，但是逻辑更复杂，线路更多</p>\n<p><img data-src=\"/image/COA12/73c85b510ec39c44c344c7417ce262a1.png\" alt=\"73c85b510ec39c44c344c7417ce262a1.png\" /></p>\n<h3 id=\"自举式\"><a class=\"anchor\" href=\"#自举式\">#</a> 自举式</h3>\n<ul>\n<li>\n<p>固定优先级</p>\n</li>\n<li>\n<p>每个设备<strong>在其总线请求线</strong>上发送请求</p>\n<ul>\n<li><strong>最低优先级的设备没有请求线</strong></li>\n</ul>\n</li>\n<li>\n<p>每个设备自行判断自己是否在请求总线的设备中优先级最高</p>\n</li>\n</ul>\n<p><img data-src=\"/image/COA12/2c0ae01f5a75dd975a3a5a5d22d8dc25.png\" alt=\"2c0ae01f5a75dd975a3a5a5d22d8dc25.png\" /></p>\n<h2 id=\"时序\"><a class=\"anchor\" href=\"#时序\">#</a> 时序</h2>\n<p>确定每个总线事务的<strong>开始和结束时间</strong></p>\n<h3 id=\"同步时序\"><a class=\"anchor\" href=\"#同步时序\">#</a> 同步时序</h3>\n<p><img data-src=\"/image/COA12/b373550f1d75534e4ddb603ba8c8ebf5.png\" alt=\"b373550f1d75534e4ddb603ba8c8ebf5.png\" /></p>\n<p>所有设备<strong>共享同一个时钟</strong></p>\n<h3 id=\"异步时序\"><a class=\"anchor\" href=\"#异步时序\">#</a> 异步时序</h3>\n<p>异步时序（Asynchronous Timing）是指总线通信过程中不依赖全局时钟，而是通过 <strong>握手信号</strong> 来协调各设备之间的操作。</p>\n<p>分为非互锁、半互锁、全互锁。</p>\n<p><img data-src=\"/image/COA12/e62bf4b220c06f86733747af020b0ad7.png\" alt=\"e62bf4b220c06f86733747af020b0ad7.png\" /></p>\n<p><img data-src=\"/image/COA12/ef04e187ba71f25f4caee9e79fa29068.png\" alt=\"ef04e187ba71f25f4caee9e79fa29068.png\" /></p>\n<h3 id=\"半同步时序\"><a class=\"anchor\" href=\"#半同步时序\">#</a> 半同步时序</h3>\n<p>为了减少噪声的影响，在异步计时中使用时钟</p>\n<p>准备和响应信号在时钟<strong>上升沿</strong>有效</p>\n<h3 id=\"分离事务\"><a class=\"anchor\" href=\"#分离事务\">#</a> 分离事务</h3>\n<p>将一个总线事件分离为<strong>两个过程</strong></p>\n<h1 id=\"总线带宽和数据传输速率\"><a class=\"anchor\" href=\"#总线带宽和数据传输速率\">#</a> 总线带宽和数据传输速率</h1>\n<p><strong>总线带宽</strong>（bus bandwidth）：总线的<strong>最大</strong>数据传输速率</p>\n<p><strong>不要</strong>考虑总线仲裁、地址传输等因素</p>\n<p><strong>数据传输速率</strong></p>\n<p><strong>考虑</strong>地址传输、握手等因素</p>\n<h2 id=\"同步总线和异步总线的数据传输速率\"><a class=\"anchor\" href=\"#同步总线和异步总线的数据传输速率\">#</a> 同步总线和异步总线的数据传输速率</h2>\n<p>** 例题 1：** 假设同步总线的时钟周期为 50ns，每次传输需要一个时钟周期，异步 总线每次握手需要 40ns。两个总线都是 32 位宽，内存的数据准备时间为 200ns。 <strong>当从存储器中读出一个 32 位的字时</strong>，计算两个总线的数据传输速率。</p>\n<p>同步总线：</p>\n<p>从存储器中读出一个 32 位的字，三个流程：</p>\n<ol>\n<li>\n<p>CPU 发送指令和地址到内存：50ns</p>\n</li>\n<li>\n<p>内存准备数据：200ns</p>\n</li>\n<li>\n<p>将数据传输回 CPU：50ns</p>\n</li>\n</ol>\n<p>由于一次传递 32 位，速率单位为 bps</p>\n<p>所以：数据传输速率 = 32bit / (50 + 200 + 50) ns = 106.7Mbps</p>\n<p>（1 ns 等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>9</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">10^{-9}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span></span></span></span> s）</p>\n<p>异步总线：</p>\n<p>步骤 1：40 ns</p>\n<p>步骤 2、3、4 / 数据准备：max (40ns* 3,200ns) = 200ns</p>\n<p>步骤 5、6、7：40ns * 3 = 120ns</p>\n<p>数据传输速率 = 32bit / (40 + 200 + 120) ns = 88.9Mbps</p>\n<p><img data-src=\"/image/COA12/1f44d4181a9237b28d969db2c6151274.png\" alt=\"1f44d4181a9237b28d969db2c6151274.png\" /></p>\n<p>每一步的解释看上面</p>\n<p>** 例题 2：** 假设同步总线的时钟周期为 50ns，每次传输需要一个时钟周期，异步 总线每次握手需要 40ns。两个总线都是 32 位宽，存储器的数据准备时间为 230ns。当从存储器中读出一个 32 位的字时，计算两个总线的数据传输速率。</p>\n<p>同步总线</p>\n<p>数据传输速率 = 32bit / (50 + <strong>250</strong> + 50)ns = 91.4Mbps</p>\n<p>250 是因为需要是<strong>时钟周期的倍数</strong></p>\n<p>异步总线</p>\n<p>数据传输速率 = 32bit / (40 + 230 + 120) ns = 82.1Mbps</p>\n<p>40：步骤 1</p>\n<p>230：max（40*3,230）</p>\n<p>120：40*3</p>\n<h2 id=\"不同数据块大小的数据传输速率\"><a class=\"anchor\" href=\"#不同数据块大小的数据传输速率\">#</a> 不同数据块大小的数据传输速率</h2>\n<p>** 例题 3：** 假设系统具有以下特征:</p>\n<ol>\n<li>\n<p>它支持访问大小为 4 到 16 个字（每个字 32 位）的块</p>\n</li>\n<li>\n<p>同步总线具有<strong> 64 位宽</strong>和<strong> 200MHz 时钟频率</strong>，需要<strong> 1 个时钟周期</strong>来传输地址或 64 位数据</p>\n</li>\n<li>\n<p>在两个总线事务之间有<strong> 2 个空闲时钟周期</strong></p>\n</li>\n<li>\n<p>内存访问时准备<strong>前 4 个字需要 200ns</strong>，后面<strong>每 4 个字</strong>准备需要 20ns</p>\n</li>\n<li>\n<p>当前面的数据在总线上传输时，内存可以<strong>同时读取后面的数据</strong></p>\n</li>\n</ol>\n<p>如果读取 256 个字，分别计算每次传输 4 个字和 16 个字时的数据传输速率、 传输时间和每秒总线事务数</p>\n<p><strong>每次传输 4 个字：</strong></p>\n<p>200MHz 时钟频率 → 5ns 一个时钟周期</p>\n<p>先计算总共的时间周期：</p>\n<p>总线事务：传地址＋传 4 个字</p>\n<p>地址传输：需要 1 个时钟周期</p>\n<p>数据准备：需要 200ns (40 个时钟周期)</p>\n<p>数据传输：2 个时钟周期（一个时钟周期传输 64 位，4*32/64=2）</p>\n<p>空闲：2 个时钟周期</p>\n<p>总共传 256 个字，256/4=64，传 64 次</p>\n<p>因此总共：64*（1+40+2+2）=2880 个时钟周期</p>\n<p>传输时间：2880 * 5 ns = 14400 ns</p>\n<p>每秒总线事务数：</p>\n<p>单次时间：（1+40+2+2）*5=225ns</p>\n<p>每秒总线事务数 = 1s / 225ns = 4.44M</p>\n<p>数据传输速率：总传输数据量 / 总时间</p>\n<p>256 * 32bit / 14400ns = 568.9Mbps</p>\n<p><strong>每次传输 16 个字：</strong></p>\n<p>先计算总共的时间周期：</p>\n<p>总线事务：传地址＋传 16 个字</p>\n<p>地址传输：需要 1 个时钟周期</p>\n<p>数据准备（前四个字）：需要 200ns (40 个时钟周期)</p>\n<p>数据传输：2 个时钟周期（同时读取后 4 个字：20ns，4 个时钟周期）</p>\n<p>空闲：2 个时钟周期</p>\n<p>总共传 256 个字，256/16=16，传 64 次</p>\n<p>因此总共：16 *（1+40+ 3 * max（2 , 4）+ 2+2）= 912 个时钟周期</p>\n<p>解释一下，还是一次传 4 个字，16 个字传 4 组。在传第 1 组时，同时读取第 2 组数据，4&gt;2 所以耗费 4 个时钟周期，同理传第 2 组读第 3 组，传第 3 组读第 4 组，都是 4 个时钟周期。传第 4 组时，不用读数据了，因此 2 个时钟周期即可。</p>\n<p>传输时间： 912 * 5 ns = 4560 ns</p>\n<p>每秒总线事务数：</p>\n<p>单次时间：（1+40+ 3 * max（2 , 4）+ 2+2）*5=285ns</p>\n<p>每秒总线事务数 = 1s / 285ns = 4.44M</p>\n<p>数据传输速率：总传输数据量 / 总时间</p>\n<p>256 * 32bit / 4560ns = 1796.5Mbps</p>\n<h2 id=\"提高总线的数据传输率\"><a class=\"anchor\" href=\"#提高总线的数据传输率\">#</a> 提高总线的数据传输率</h2>\n<ol>\n<li>\n<p>提高时钟频率（时钟周期数不变的情况下）</p>\n</li>\n<li>\n<p>增加数据总线宽度，每次传输更多的数据</p>\n</li>\n<li>\n<p>块传输，传输一次地址就传输一块数据</p>\n</li>\n<li>\n<p>分离总线事务，减少总线空闲时间</p>\n</li>\n<li>\n<p>分离地址线和数据线，同时传输地址和数据</p>\n</li>\n</ol>\n<h1 id=\"总线层次结构\"><a class=\"anchor\" href=\"#总线层次结构\">#</a> 总线层次结构</h1>\n<h2 id=\"单总线结构\"><a class=\"anchor\" href=\"#单总线结构\">#</a> 单总线结构</h2>\n<p>CPU、存储器和 I/O 模块都连接到<strong>一条系统总线</strong></p>\n<h2 id=\"双总线结构i\"><a class=\"anchor\" href=\"#双总线结构i\">#</a> 双总线结构 I</h2>\n<p><img data-src=\"/image/COA12/04a72126603bd6219207a1f08cb3edf8.png\" alt=\"04a72126603bd6219207a1f08cb3edf8.png\" /></p>\n<p>在 CPU 和存储器中间增加一个<strong>存储器总线</strong></p>\n<p>增加 CPU 和存储器之间的传输效率，同时降低系统总线的负担</p>\n<h2 id=\"双总线结构ii\"><a class=\"anchor\" href=\"#双总线结构ii\">#</a> 双总线结构 II</h2>\n<p>将系统总线分为<strong>存储器总线</strong>、<strong>I/O 总线</strong> 和 <strong>IOP</strong>(input/output processer)</p>\n<p>降低 I/O 对总线的负担</p>\n<p><img data-src=\"/image/COA12/image.png\" alt=\"image.png\" /></p>\n<h2 id=\"多总线结构\"><a class=\"anchor\" href=\"#多总线结构\">#</a> 多总线结构</h2>\n<p>都是增加 I/O 交互效率的。略</p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "计算机组织结构",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/COA11/",
            "url": "https://erinwithbmq.github.io/2025/01/11/COA11/",
            "title": "计组期末复习第十一讲 虚拟存储器",
            "date_published": "2025-01-11T11:32:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>LaTeX 渲染有问题。将就着看吧。</p>\n</div>\n<p>虚拟存储器</p>\n<p>请求分页：每次访问仅将当前需要的页面调入主存，而其他不活跃的页面放在外存磁盘上</p>\n<p>虚拟地址</p>\n<h3 id=\"分区方式\"><a class=\"anchor\" href=\"#分区方式\">#</a> 分区方式</h3>\n<p>将主存分为两大区域</p>\n<p>系统区：固定的地址范围内，存放操作系统</p>\n<p>用户区：存放所有用户程序</p>\n<p>分区方式</p>\n<p>简单固定分区：用户区划分成长度不等的<strong>固定长</strong>的分区</p>\n<p>可变长分区：用户区<strong>按每个任务所需要的内存大小</strong>进行分配</p>\n<h3 id=\"分页方式\"><a class=\"anchor\" href=\"#分页方式\">#</a> 分页方式</h3>\n<p>把<strong>主存</strong>分成<strong>固定长且比较小</strong>的存储块，称为<strong>页框（page frame）</strong></p>\n<p>每个<strong>任务</strong>也被划分成<strong>固定长的程序块</strong>，称为<strong>页（page）</strong></p>\n<p>将<strong>页装入页框</strong>中，且<strong>无需采用</strong>连续的页框来存放一个任务中所有的页</p>\n<p><strong>逻辑地址：指令</strong>中的地址</p>\n<p><strong>物理地址：<strong>实际</strong>主存</strong>地址</p>\n<h1 id=\"虚拟存储器\"><a class=\"anchor\" href=\"#虚拟存储器\">#</a> 虚拟存储器</h1>\n<p><strong>基本思想</strong></p>\n<p>• <strong>请求分页</strong>：仅将<strong>当前需要的的页</strong>调入主存</p>\n<p>・通过硬件将<strong>逻辑地址</strong>转换为<strong>物理地址</strong></p>\n<p>• <strong>未命中时</strong>在主存和硬盘之间交换信息</p>\n<p><strong>类型</strong></p>\n<p>• <strong>分页式</strong>虚拟存储器</p>\n<p>• <strong>分段式</strong>虚拟存储器</p>\n<p>• <strong>段页式</strong>虚拟存储器</p>\n<p><strong>映射算法</strong></p>\n<p>・全相联映射</p>\n<p><strong>写策略</strong></p>\n<p>・写回</p>\n<h2 id=\"分页式虚拟存储器\"><a class=\"anchor\" href=\"#分页式虚拟存储器\">#</a> 分页式虚拟存储器</h2>\n<p><strong>主存储器</strong>和<strong>虚拟地址空间</strong>都被划分为<strong>大小相等</strong>的页面</p>\n<p>虚拟页（virtual page，VP）/ <strong>逻辑页</strong>（logical page）：<strong>虚拟地址空间</strong>中的页面</p>\n<p>物理页（physical page，PP）/ <strong>页框</strong>（page frame）：<strong>主存空间</strong>中的页面</p>\n<p><strong>页表：</strong></p>\n<p>页表中包含了<strong>所有虚拟页的信息</strong>，包括虚拟页的存放位置、装入位（valid）、修改位（dirty）、存取权限位等等。保存在主存中。</p>\n<p>** 虚拟地址：** 虚拟页号 + 页内偏移量</p>\n<p><strong>快表（TLB）：</strong></p>\n<p>页表的使用增加了主存的访问次数</p>\n<p>为了减少访存次数，把页表中<strong>最活跃的几个页表项</strong>复制到 ** 高速缓存（Cache）** 中</p>\n<p>** 映射：** 关联映射，组关联映射</p>\n<p><strong>替换</strong>：随机替换</p>\n<p>主存中的页表相应地称之为 “慢表”</p>\n<p>注：现在的计算机中，TLB 和 Cache 在物理上是<strong>两个存储器</strong></p>\n<p>根据页表中记录的物理页存放位置，可以<strong>将虚拟地址转化为物理地址</strong></p>\n<p><img data-src=\"/image/COA11/ca7e99a21a5250fba0cb9dca14197c50.png\" alt=\"ca7e99a21a5250fba0cb9dca14197c50.png\" /></p>\n<p>TLB：主存中比较活跃的页，TLB 命中，则主存中一定有这个页</p>\n<p>页表：主存中的所有页，页表命中，则主存中一定有这个页。</p>\n<p>那么实际上 TLB 和页表是包含关系</p>\n<p>cache 和主存是包含关系</p>\n<p>TLB 和页表是存虚拟页描述信息的，并没有实际 data</p>\n<p>TLB 相对于页表，有点像 cache 相对于主存</p>\n<p><img data-src=\"/image/COA11/638ab0c03ef14a05b59373e47086aa64.png\" alt=\"638ab0c03ef14a05b59373e47086aa64.png\" /></p>\n<p><img data-src=\"/image/COA11/1e188f2705907faadae40f3c4e1be16e.png\" alt=\"1e188f2705907faadae40f3c4e1be16e.png\" /></p>\n<p>TLB 未命中但页表命中，需要更新 TLB</p>\n<p>TLB 和页表都未命中，两个都需要更新</p>\n<h2 id=\"分段式虚拟存储器\"><a class=\"anchor\" href=\"#分段式虚拟存储器\">#</a> 分段式虚拟存储器</h2>\n<p>将程序和数据分成不同长度的段，将所需的段加载到主存中</p>\n<p>虚拟地址：段号 + 段内偏移量</p>\n<h2 id=\"段页式虚拟存储器\"><a class=\"anchor\" href=\"#段页式虚拟存储器\">#</a> 段页式虚拟存储器</h2>\n<p>将程序和数据分段，<strong>段内再进行分页</strong></p>\n<p>每个分段都有一个页表</p>\n<p>虚拟地址</p>\n<p><strong>段号 + 页号</strong> + 页内偏移量</p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "计算机组织结构",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/COA10/",
            "url": "https://erinwithbmq.github.io/2025/01/11/COA10/",
            "title": "计组期末复习第十讲 RAID",
            "date_published": "2025-01-11T11:31:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>LaTeX 渲染有问题。将就着看吧。</p>\n</div>\n<p>冗余磁盘阵列 / 独立磁盘冗余阵列：RedundantArraysofIndependent Disks (RAID)</p>\n<p>RAID（Redundant Array of Independent Disks，独立磁盘冗余阵列）是一种将<strong>多个物理硬盘组合成一个逻辑硬盘</strong>的技术，以提升数据的性能、冗余性和可用性。通过 RAID，可以在数据存储时实现一定的容错能力，避免数据因某一硬盘的故障而丢失。</p>\n<p><strong>特性：</strong></p>\n<ul>\n<li>\n<p>由一组物理磁盘驱动器组成，被视为<strong>单个逻辑驱动器</strong></p>\n</li>\n<li>\n<p>数据是分布在多个物理磁盘上</p>\n</li>\n<li>\n<p><strong>冗余磁盘</strong>容量用于存储<strong>校验信息</strong>，保证磁盘万一损坏时能恢复数据</p>\n</li>\n</ul>\n<h3 id=\"分类\"><a class=\"anchor\" href=\"#分类\">#</a> 分类：</h3>\n<p><img data-src=\"/image/COA10/bb7702e1aedb4121051ed4452e3757c2.png\" alt=\"bb7702e1aedb4121051ed4452e3757c2.png\" /></p>\n<h2 id=\"raid-0\"><a class=\"anchor\" href=\"#raid-0\">#</a> RAID 0</h2>\n<p>数据以条带的形式在可用的磁盘上分布</p>\n<p><strong>不采用</strong>冗余来改善性能（不是 RAID 家族中的真正成员）</p>\n<ul>\n<li>\n<p>优点：读写速度提升，因为可以并行读取和写入。</p>\n</li>\n<li>\n<p>缺点：没有数据冗余，任何一块硬盘故障都会导致所有数据丢失。</p>\n</li>\n<li>\n<p>适用场景：对速度要求较高的数据处理任务，不要求数据冗余。</p>\n</li>\n</ul>\n<p>用途：高数据传输率 ，高速响应 I/O 请求</p>\n<h2 id=\"raid-1\"><a class=\"anchor\" href=\"#raid-1\">#</a> RAID 1</h2>\n<p><img data-src=\"/image/COA10/2dd0b04f89401dfb4f3c4ddf374a9879.png\" alt=\"2dd0b04f89401dfb4f3c4ddf374a9879.png\" /></p>\n<p>采用了数据条带</p>\n<p>采用简单地<strong>备份所有数据</strong>的方法来实现冗余</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>\n<p>高速响应 I/O 请求：即便是同一个磁盘上的数据块，也可以由两组硬盘分别响应</p>\n</li>\n<li>\n<p>读请求可以由包含请求数据的两个对应磁盘中的某一个提供服务，可以选择寻道 时间较小的那个</p>\n</li>\n<li>\n<p>写请求需要<strong>更新两个对应的条带</strong>：可以并行完成，但受限于写入较慢的磁盘</p>\n</li>\n<li>\n<p>单个磁盘损坏时不会影响数据访问，恢复受损磁盘简单</p>\n</li>\n</ul>\n<p>** 缺点：** 价格昂贵</p>\n<p>** 用途：** 只限于用在存储系统软件、数据和其他关键文件的驱动器中</p>\n<p><strong>与 RAID 0 相比：</strong></p>\n<p>如果有大批的读请求，则 RAID 1 能实现高速的 I/O 速率，性能可以达到 RAID 0 的两倍</p>\n<p>如果 I/O 请求有相当大的部分是写请求，则它不比 RAID 0 的性能好多少</p>\n<h3 id=\"raid-01-vs-raid-10\"><a class=\"anchor\" href=\"#raid-01-vs-raid-10\">#</a> RAID 01 vs. RAID 10</h3>\n<p>RAID 01 =RAID 0+1：先做 RAID0，再做 RAID1</p>\n<p>RAID 10 =RAID 1+0：先做 RAID1，再做 RAID0</p>\n<p>两者在数据传输率和磁盘利用率上没有明显区别，主要区别是对磁盘损坏的<strong>容错能力</strong></p>\n<p><img data-src=\"/image/COA10/1195195a2e56fec7eefc0d0d254e73f3.png\" alt=\"1195195a2e56fec7eefc0d0d254e73f3.png\" /></p>\n<p>RAID 01 会无法恢复，但 RAID 10 可以恢复。</p>\n<h2 id=\"raid-2\"><a class=\"anchor\" href=\"#raid-2\">#</a> RAID 2</h2>\n<p>采用并行存取技术</p>\n<p>目标：</p>\n<p>所有磁盘都参与每个 I/O 请求的执行</p>\n<p>实际基本被弃用</p>\n<h2 id=\"raid-3\"><a class=\"anchor\" href=\"#raid-3\">#</a> RAID 3</h2>\n<p>采用<strong>并行存取</strong>技术</p>\n<p>各个驱动器的轴同步旋转</p>\n<p>采用非常小的数据条带，所有盘一起读写</p>\n<p>校验：对<strong>所有数据盘上同一位置的数据</strong>计算奇偶校验码</p>\n<p>优点：能够获得非常高的数据传输率，对于大量读请求，性能改善特别明显</p>\n<p>缺点：一次只能执行一个 I/O 请求，在面向多个 IO 请求时，性能将受损</p>\n<h2 id=\"raid-4\"><a class=\"anchor\" href=\"#raid-4\">#</a> RAID 4</h2>\n<p>采用<strong>独立存取</strong>技术</p>\n<p>每个磁盘成员的操作是独立的，各个 I/O 请求能够<strong>并行处理</strong></p>\n<p>采用相对较大的数据条带</p>\n<p>根据各个数据盘上的数据来逐位计算奇偶校验条带，奇偶校验位存储在奇偶校验盘的对应条带上</p>\n<h3 id=\"raid-4-的特点\"><a class=\"anchor\" href=\"#raid-4-的特点\">#</a> RAID 4 的特点</h3>\n<ol>\n<li>\n<p><strong>块级条带化</strong>：RAID 4 将数据按块（通常是较大的数据块）条带化分布在多个磁盘上，而不是按字节。每个磁盘存储数据的不同块，并且会有一个独立的磁盘用于存储所有数据块的奇偶校验。</p>\n</li>\n<li>\n<p><strong>单一奇偶校验磁盘</strong>：和 RAID 3 类似，RAID 4 使用一个单独的磁盘来存储所有的奇偶校验数据。如果数据磁盘之一发生故障，奇偶校验磁盘可以帮助恢复丢失的数据。</p>\n</li>\n<li>\n<p><strong>容错能力</strong>：RAID 4 能够容忍一块磁盘的故障而不丢失数据，因为奇偶校验磁盘可以用来重建丢失的磁盘数据。但如果奇偶校验磁盘发生故障，数据将不可恢复。</p>\n</li>\n<li>\n<p><strong>性能瓶颈</strong>：由于所有的奇偶校验数据都存储在一个单独的磁盘上，RAID 4 会受到写操作性能瓶颈的限制。每次写入数据时，都需要读取、计算并写入新的奇偶校验信息，这会导致奇偶校验磁盘的过载。</p>\n</li>\n</ol>\n<h3 id=\"raid-4-的优缺点\"><a class=\"anchor\" href=\"#raid-4-的优缺点\">#</a> RAID 4 的优缺点</h3>\n<ul>\n<li>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>\n<p><strong>较高的顺序读取性能</strong>：与 RAID 3 相比，由于块级条带化，RAID 4 在进行顺序读取时性能较好。</p>\n</li>\n<li>\n<p><strong>容错性</strong>：RAID 4 可以容忍一块硬盘故障，能够通过奇偶校验数据恢复丢失的数据。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>\n<p><strong>写入性能瓶颈</strong>：由于所有的奇偶校验操作都集中在单一磁盘上，写操作时必须读取该磁盘上的旧的奇偶校验信息，并进行更新，这会导致性能下降。尤其是在频繁写入的情况下，奇偶校验磁盘会成为性能瓶颈。</p>\n</li>\n<li>\n<p><strong>随机读取性能差</strong>：尽管顺序读取性能较好，但在处理小文件或随机读取时，RAID 4 的性能不如其他 RAID 级别（如 RAID 5）。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>性能</p>\n<p>当执行较小规模的 I/O 写请求时，RAID4 会遭遇写损失</p>\n<p>对于每一次写操作，阵列管理软件不仅要修改用户数据，而且<strong>要修改相应的校验位</strong></p>\n<p><img data-src=\"/image/COA10/e13b2c5605f915d23cbd3f32f0398124.png\" alt=\"e13b2c5605f915d23cbd3f32f0398124.png\" /></p>\n<p>当涉及所有磁盘的数据条带的较大 I/O 写操作时，只要用新的数据位来进行简单的计算即可得到奇偶校验位</p>\n<p>每一次写操作必须涉及到唯一的校验盘，校验盘会成为瓶颈（实际基本弃用）</p>\n<h2 id=\"raid-5\"><a class=\"anchor\" href=\"#raid-5\">#</a> RAID 5</h2>\n<p>与 RAID 4 组织方式相似（常用）</p>\n<p>在<strong>所有磁盘上</strong>都分布了奇偶校验条带</p>\n<p>避免潜在的 I/O 瓶颈问题</p>\n<p>RAID 5 通过 <strong>块级条带化</strong> 和 <strong>分布式奇偶校验</strong> 来提供数据冗余和容错能力。这意味着数据被分割成块，并分布到多个磁盘上，同时奇偶校验信息也<strong>分布在所有磁盘上</strong>，以便在某一磁盘发生故障时恢复数据。</p>\n<p>访问时的 “两读两写”：<strong>读在写前，读 / 写不需要并行</strong></p>\n<p><img data-src=\"/image/COA10/f8014c6df3743515363dfd77662ed62c.png\" alt=\"f8014c6df3743515363dfd77662ed62c.png\" /></p>\n<h3 id=\"raid-50\"><a class=\"anchor\" href=\"#raid-50\">#</a> RAID 50</h3>\n<p>RAID 5 与 RAID 0 的组合，先作 RAID 5，再作 RAID 0，也就是对多组 RAID 5 彼此构成条带访问</p>\n<p>RAID 50 在底层的任一组或多组 RAID5 中出现<strong> 1 颗硬盘损坏</strong>时，<strong>仍能维持运作</strong>；如果 任一组 RAID5 中出现<strong> 2 颗或 2 颗以上</strong>硬盘损毁，整组 RAID50 就会<strong>失效</strong></p>\n<p>RAID 50 由于在上层把多组 RAID 5 进行条带化，性能比起单纯的 RAID 5 高，但<strong>容量 利用率比 RAID5 要低</strong></p>\n<h2 id=\"raid-6\"><a class=\"anchor\" href=\"#raid-6\">#</a> RAID 6</h2>\n<p>采用<strong>两种不同的校验码</strong>，并将校验码<strong>以分开的块存于不同的磁盘中</strong></p>\n<ol>\n<li>\n<p><strong>奇偶校验码 P（Parity Code P）</strong></p>\n</li>\n<li>\n<p><strong>Reed-Solomon 校验码 Q（RS Code Q）</strong></p>\n</li>\n</ol>\n<p>优点</p>\n<p>提升数据可用性：只有在平均修复时间间隔内 3 个磁盘都出了故障，才会造成数据丢失</p>\n<p>缺点</p>\n<p>写损失：每次写都要<strong>影响两个校验块</strong>（读 3 个写 3 个磁盘）</p>\n<p><img data-src=\"/image/COA10/4fad03be52b6e9345a9ff9888c28f8cd.png\" alt=\"4fad03be52b6e9345a9ff9888c28f8cd.png\" /></p>\n<h2 id=\"不同-raid-的比较\"><a class=\"anchor\" href=\"#不同-raid-的比较\">#</a> 不同 RAID 的比较</h2>\n<p><img data-src=\"/image/COA10/d0c5adeb15049237c207a782e0099837.png\" alt=\"d0c5adeb15049237c207a782e0099837.png\" /></p>\n<p><img data-src=\"/image/COA10/d0c04ebdcd5ae24c46a149742d41f1e8.png\" alt=\"d0c04ebdcd5ae24c46a149742d41f1e8.png\" /></p>\n<p><img data-src=\"/image/COA10/0e21bb90b9b8683cc9336b4fee11d884.png\" alt=\"0e21bb90b9b8683cc9336b4fee11d884.png\" /></p>\n<h1 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h1>\n<p><img data-src=\"/image/COA10/8f4b9f3f22a1b4bfcb686a7bf45d8e8a.png\" alt=\"8f4b9f3f22a1b4bfcb686a7bf45d8e8a.png\" /></p>\n<p>0：I/O 快，但是数据可用性低</p>\n<p>1：数据可用性高但是容量可用性低</p>\n<p>2/3：不能并行处理，处理速度慢</p>\n<p>456：数据可用性高但是写速率收到影响</p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "计算机组织结构",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/COA9/",
            "url": "https://erinwithbmq.github.io/2025/01/11/COA9/",
            "title": "计组期末复习第九讲 数据校验码",
            "date_published": "2025-01-11T11:28:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>LaTeX 渲染有问题。将就着看吧。</p>\n</div>\n<h1 id=\"纠错\"><a class=\"anchor\" href=\"#纠错\">#</a> 纠错</h1>\n<p>两种<strong>存储错误</strong>：</p>\n<ol>\n<li>\n<p>硬故障：永久性物理故障</p>\n</li>\n<li>\n<p>软故障：随机非破坏性，改变了某个或某些存储单元的内容，但没有损坏机器</p>\n</li>\n</ol>\n<h2 id=\"基本思想\"><a class=\"anchor\" href=\"#基本思想\">#</a> 基本思想</h2>\n<p>存储额外的信息以进行检错和校正</p>\n<h2 id=\"处理过程\"><a class=\"anchor\" href=\"#处理过程\">#</a> 处理过程</h2>\n<p>使用函数在数据上生成校验码。传输完成后再生成一次，比较差错</p>\n<h1 id=\"常用的数据校验码\"><a class=\"anchor\" href=\"#常用的数据校验码\">#</a> 常用的数据校验码</h1>\n<h2 id=\"奇偶校验码\"><a class=\"anchor\" href=\"#奇偶校验码\">#</a> 奇偶校验码</h2>\n<p>基本思想：<strong>增加 1 位校验码</strong>来表示数据中 <strong>1 的数量</strong>是奇数还是偶数</p>\n<ul>\n<li>\n<p><strong>奇校验</strong>：使传输的数据 **（数据位 + 校验位）<strong>中有</strong>奇数 ** 个 1</p>\n</li>\n<li>\n<p><strong>偶校验</strong>：使传输的数据 **（数据位 + 校验位）<strong>中有</strong>偶数 ** 个 1</p>\n</li>\n</ul>\n<p>传输完成后，根据校验类型生成校验码，比较是否相同。</p>\n<p>检错：S=𝐶′′⊕𝐶′</p>\n<p>𝑆=0：正确 / 数据中出错的位数为<strong>偶数</strong></p>\n<p>𝑆=1：数据中出错的位数为奇数</p>\n<p>适用于对<strong>较短长度</strong>（如 1 字节）的数据进行检错</p>\n<h2 id=\"海明码\"><a class=\"anchor\" href=\"#海明码\">#</a> 海明码</h2>\n<ul>\n<li>\n<p>基本思想：将数据分成几组，对<strong>每一组</strong>都使用<strong>奇偶校验码</strong>进行检错</p>\n</li>\n<li>\n<p>处理过程：</p>\n<ul>\n<li>\n<p>分组：将𝑀位数据分成𝐾组</p>\n</li>\n<li>\n<p>数据输入：为数据𝐷中<strong>每组</strong>生成 1 位校验码，<strong>合并</strong>得到𝐾位校验码𝐶</p>\n</li>\n<li>\n<p>数据输出：为数据𝐷′中<strong>每组</strong>生成 1 位校验码，<strong>合并</strong>得到新的𝐾位校验码𝐶′′</p>\n</li>\n<li>\n<p>检错：将校验码𝐶′′和取出的校验码 C’<strong>按位进行异或</strong>，生成𝐾位<strong>故障字</strong> （syndrome word）</p>\n</li>\n</ul>\n</li>\n<li>\n<p>故障字的作用</p>\n<ul>\n<li>\n<p>故障字是两个校验码<strong>按位异或</strong>生成的结果</p>\n</li>\n<li>\n<p>规则：</p>\n<ul>\n<li>\n<p>全部是 0：没有检测到错误</p>\n</li>\n<li>\n<p>有且仅有 1 位是 1：错误发生在<strong>校验码中的某一位</strong>，<strong>不需要纠正</strong></p>\n</li>\n<li>\n<p>有多位为 1：错误发生在数据中的某一位，将𝐷′中对应数据位<strong>取反</strong>即可纠正</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>海明码通过在原始数据中插入额外的校验位，使得接收方可以检测并纠正 <strong>1 位错误</strong>（单比特错误），并检测 <strong>2 位错误</strong></p>\n<h3 id=\"构造过程\"><a class=\"anchor\" href=\"#构造过程\">#</a> 构造过程</h3>\n<ol>\n<li>\n<p><strong>确定校验位的数量</strong></p>\n<ul>\n<li>\n<p>给定数据位的长度为 k，校验位的数量为 r，总长度为 n=k+r。</p>\n</li>\n<li>\n<p>校验位 r 的数量需满足以下关系： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>r</mi></msup><mo>≥</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>k</mi><mo>+</mo><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^r≥n+1=k+r+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.800362em;vertical-align:-0.13597em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n</li>\n<li>\n<p>例如：如果 k=4（数据位长度），则 r=3 满足条件（2^3=8≥4+3+1）。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>确定校验位的位置</strong></p>\n<ul>\n<li>\n<p>校验位插入到数据位中，使其位于指数为 2 的幂的位置（即第 1、2、4、8... 位）。</p>\n</li>\n<li>\n<p>其他位置存放数据位。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>生成校验位</strong></p>\n<ul>\n<li>\n<p>每个校验位负责<strong>对特定位置的比特</strong>进行校验，位置由 <strong>二进制表示</strong>决定</p>\n</li>\n<li>\n<p>例如：校验位 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub><mtext>​</mtext></mrow><annotation encoding=\"application/x-tex\">P_i​</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">​</span></span></span></span> 负责检查所有位置的二进制表示中第 i 位为 1 的数据位。</p>\n</li>\n<li>\n<p>一般是偶校验</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"实例\"><a class=\"anchor\" href=\"#实例\">#</a> 实例</h3>\n<p><img data-src=\"/image/COA9/e0c39b0342ecf9262187f370d5757785.png\" alt=\"e0c39b0342ecf9262187f370d5757785.png\" /></p>\n<p><img data-src=\"/image/COA9/09f7a02031fe96fb31fcfd0d8cfd3ce6.png\" alt=\"09f7a02031fe96fb31fcfd0d8cfd3ce6.png\" /></p>\n<p><img data-src=\"/image/COA9/d2274a2bd99359ac8b510780e11fef80.png\" alt=\"d2274a2bd99359ac8b510780e11fef80.png\" /></p>\n<h2 id=\"码距和纠错理论\"><a class=\"anchor\" href=\"#码距和纠错理论\">#</a> 码距和纠错理论</h2>\n<h3 id=\"码距\"><a class=\"anchor\" href=\"#码距\">#</a> 码距</h3>\n<p>同一编码中，任意两个<strong>合法编码</strong>之间<strong>不同二进制数位数</strong>的<strong>最小值</strong></p>\n<ul>\n<li>\n<p>{0000, 0001, 0010, 0011} 码距为 1</p>\n</li>\n<li>\n<p>{0000, 0011} 码距为 2</p>\n</li>\n</ul>\n<h3 id=\"纠错理论\"><a class=\"anchor\" href=\"#纠错理论\">#</a> 纠错理论</h3>\n<p>𝑳−𝟏=𝑫+𝑪, 𝑫≥𝑪</p>\n<p><strong>𝐿是码距，𝐷是检错位数，𝐶是纠错位数</strong></p>\n<ul>\n<li>\n<p>奇偶校验的<strong>码距是 2</strong>，1 位能检错，不能纠错</p>\n</li>\n<li>\n<p>海明码的<strong>码距是 3</strong>，1 位能检错和纠错（海明码能 2 位检测 0 位纠错吗？<strong>可以</strong>）</p>\n</li>\n</ul>\n<h2 id=\"循环冗余校验-crc\"><a class=\"anchor\" href=\"#循环冗余校验-crc\">#</a> 循环冗余校验 CRC</h2>\n<p>通过将数据看作一个二进制多项式，并对其进行特定的多项式除法运算来生成一个校验值。</p>\n<p><strong>数据视为二进制多项式</strong></p>\n<ul>\n<li>数据位序列被视为一个二进制多项式。例如，数据 1101 对应多项式： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x^3+x^2+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，每个比特对应多项式的系数。</li>\n</ul>\n<p>生成多项式要求最低位和最高位为 1.</p>\n<h3 id=\"计算过程\"><a class=\"anchor\" href=\"#计算过程\">#</a> 计算过程</h3>\n<ol>\n<li>\n<p>确定生成多项式。如 1011（<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">G(x)=x^3+x+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>）</p>\n</li>\n<li>\n<p>在数据后面添加 0，0 的个数为生成多项式的阶数。</p>\n</li>\n<li>\n<p>对新的数据进行模 2 除法，等价于依次进行异或运算。直到产生余数，即校验码。（余数应比生成多项式少一位）</p>\n</li>\n<li>\n<p>将校验码加在原来的数据后面，发送。接收方再次进行模 2 除法，检验校验位。</p>\n</li>\n</ol>\n<p><img data-src=\"/image/COA9/3193335de6541ac6fd795ebd7d487295.png\" alt=\"3193335de6541ac6fd795ebd7d487295.png\" /></p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "计算机组织结构",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/COA8/",
            "url": "https://erinwithbmq.github.io/2025/01/11/COA8/",
            "title": "计组期末复习第八讲 外部存储器",
            "date_published": "2025-01-11T11:25:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>LaTeX 渲染有问题。将就着看吧。</p>\n</div>\n<p>磁盘 / 磁带部分。</p>\n<h1 id=\"外部存储设备\"><a class=\"anchor\" href=\"#外部存储设备\">#</a> 外部存储设备</h1>\n<p>用于存储不经常使用的、数据量较大的信息，非易失</p>\n<ul>\n<li>\n<p>类型</p>\n<ul>\n<li>\n<p>磁盘存储器（magnetic disk）</p>\n</li>\n<li>\n<p>光存储器（optical memory）</p>\n</li>\n<li>\n<p>磁带（magnetic tape）</p>\n</li>\n<li>\n<p>U 盘（USB flash disk），固态硬盘（solid state disk，SSD）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"硬磁盘存储器\"><a class=\"anchor\" href=\"#硬磁盘存储器\">#</a> 硬磁盘存储器</h1>\n<h2 id=\"结构\"><a class=\"anchor\" href=\"#结构\">#</a> 结构</h2>\n<ul>\n<li>\n<p>磁盘存储器每个盘片表面有一个<strong>读写磁头</strong>，所有磁头通过机械方式固定在一起，<strong>同时移动</strong></p>\n</li>\n<li>\n<p>在任何时候，所有磁头都位于距磁盘中心<strong>等距离的磁道</strong>上</p>\n</li>\n</ul>\n<p><img data-src=\"/image/COA8/ad11beb08f503a90afcea51258bcb361.png\" alt=\"ad11beb08f503a90afcea51258bcb361.png\" /></p>\n<ul>\n<li>\n<p>对盘片进行读写操作的装置叫做<strong>磁头（head）</strong></p>\n<ul>\n<li>磁头越窄，电磁感应能力<strong>越弱</strong>，离盘片的<strong>距离就越近</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"读写机制\"><a class=\"anchor\" href=\"#读写机制\">#</a> 读写机制</h2>\n<ul>\n<li>\n<p>在<strong>读或写</strong>操作期间，磁头<strong>静止</strong>，而<strong>盘片在其下方旋转</strong></p>\n</li>\n<li>\n<p>磁头的数量</p>\n<ul>\n<li>\n<p>单磁头：读写共用同一个磁头（软盘、早期硬盘）</p>\n</li>\n<li>\n<p>双磁头：使用一个单独的磁头进行读取（当代硬盘）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据组织\"><a class=\"anchor\" href=\"#数据组织\">#</a> 数据组织</h2>\n<ol>\n<li>\n<p><strong>磁道：<strong>盘片上的数据组织呈现为一组</strong>同心圆环</strong>，称为磁道（track）</p>\n</li>\n<li>\n<p>** 扇区：** 数据以扇区（sector）的形式传输到磁盘或从传出磁盘。默认值为 <strong>512B</strong></p>\n</li>\n<li>\n<p>相邻磁道之间有<strong>间隙</strong>（gap），相邻的扇区之间也留有间隙，否则磁场容易相互影响</p>\n</li>\n<li>\n<p>磁道编号<strong>从外往里递增</strong>（0~N），磁头静止时停在磁道 0 外侧</p>\n</li>\n</ol>\n<p><img data-src=\"/image/COA8/4b5d8546b05becb886bc673b354549b0.png\" alt=\"4b5d8546b05becb886bc673b354549b0.png\" /></p>\n<p>图上的一个圈应该就是磁道</p>\n<p><strong>扇区划分</strong></p>\n<ul>\n<li>\n<p>恒定角速度</p>\n<ul>\n<li>恒定的数据传输率</li>\n</ul>\n</li>\n<li>\n<p>多带式记录 / 多重区域记录</p>\n</li>\n</ul>\n<p><img data-src=\"/image/COA8/f05924d72efda289d2c4c59c97ac1a37.png\" alt=\"f05924d72efda289d2c4c59c97ac1a37.png\" /></p>\n<p><img data-src=\"/image/COA8/ddc2b547215c7fce8a5c0613f115e905.png\" alt=\"ddc2b547215c7fce8a5c0613f115e905.png\" /></p>\n<p><strong>柱面 (cylinder)</strong>：所有盘片上处于<strong>相同的相对位置</strong>的一组磁道被称为柱面 (cylinder)</p>\n<p><img data-src=\"/image/COA8/a0310b1f399141ec0d5d3222e0a28a7d.png\" alt=\"a0310b1f399141ec0d5d3222e0a28a7d.png\" /></p>\n<h2 id=\"io-访问时间\"><a class=\"anchor\" href=\"#io-访问时间\">#</a> I/O 访问时间</h2>\n<p>访问时间包含以下三个部分组成：</p>\n<ol>\n<li>\n<p>** 寻道时间：** 磁头定位到所需移动到的磁道所花费的时间</p>\n<ul>\n<li>初始启动时间，跨越若干磁道所用的时间</li>\n</ul>\n</li>\n<li>\n<p><strong>旋转延迟</strong>：等待响应扇区的起始处<strong>到达磁头</strong>所需的时间</p>\n<ul>\n<li>通常是磁道<strong>旋转半周</strong>所需的时间</li>\n</ul>\n</li>\n<li>\n<p><strong>传送时间</strong>：数据传输所需的时间</p>\n<p><img data-src=\"/image/COA8/39378e04fe673a9b7aa846913174a2c0.png\" alt=\"39378e04fe673a9b7aa846913174a2c0.png\" /></p>\n<p>公式推导和解释：</p>\n<ul>\n<li>\n<p>磁盘每旋转一圈，磁头能传输整个磁道的数据，每个磁道的数据量是 N（字节数）；磁盘每秒旋转 r 转，因此<strong>每秒传送的数据量</strong>为 rN 字节 / 秒。</p>\n</li>\n<li>\n<p>如果要传送的数据量是 b，而每秒能传送的数据量是 rN，那么总传送时间为：T = b/rN</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"平均访问时间\"><a class=\"anchor\" href=\"#平均访问时间\">#</a> 平均访问时间</h4>\n<p><img data-src=\"/image/COA8/9ea8d642d53577a3dcd8bc74c3023744.png\" alt=\"9ea8d642d53577a3dcd8bc74c3023744.png\" /></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mi>r</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{2r}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.190108em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 是转半圈，为一个平均值（0 ~ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mi>r</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{r}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.190108em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 的平均）</p>\n<p>当连续访问多个相邻的磁道时，<strong>跨越磁道</strong>：</p>\n<ul>\n<li>\n<p>对于<strong>每个</strong>磁道都需要考虑<strong>旋转延迟</strong></p>\n</li>\n<li>\n<p>通常只需要考虑<strong>第一个磁道的寻道时间</strong>，但在<strong>明确知道</strong>跨越每个磁道需要的时间时需要考虑。（因为磁道非常多，顺序移到下一个磁道的耗时是非常少的）</p>\n</li>\n</ul>\n<h4 id=\"实例\"><a class=\"anchor\" href=\"#实例\">#</a> 实例</h4>\n<p>假设某个硬盘的平均寻道时间为 4ms，转速为 15000rpm（每<strong>分钟</strong> 15000 转），每磁道 500 扇区，每扇区 512B，现读取一个由 2500 个扇区组成的文件</p>\n<p><strong>情况 1：顺序组织</strong></p>\n<p>该文件占据相邻 5 个磁道的全部扇区。因为相邻，后续不需要再计算寻道时间。</p>\n<p><img data-src=\"/image/COA8/0509740cda91b738a4db7800135c002c.png\" alt=\"0509740cda91b738a4db7800135c002c.png\" /></p>\n<p>b=500<em>512=256000，r = 15000 / 60 = 250 转 / 秒，N = 500</em>512=256000</p>\n<p>T = 1/250=0.004s=4ms，即读 500 个扇区的时间。</p>\n<p><strong>情况 2：随机存取</strong></p>\n<p>该文件随机分布在磁盘上的各个扇区。</p>\n<p><img data-src=\"/image/COA8/d918328dea125c362157c032baa0d99e.png\" alt=\"d918328dea125c362157c032baa0d99e.png\" /></p>\n<p>计算了每次访问一个磁道再读扇区的单次时间，乘 2500 次（需要找 2500 次扇区）</p>\n<p>这个需要计算寻道时间，因为两次寻道不一定是相邻寻道了。而且扇区也不连续，不能再连续计算 500 个扇区。</p>\n<h2 id=\"磁头寻道磁盘调度\"><a class=\"anchor\" href=\"#磁头寻道磁盘调度\">#</a> 磁头寻道 / 磁盘调度</h2>\n<p>目标：当有多个访问磁盘任务时，使得<strong>平均寻道时间最小</strong></p>\n<p>六种调度算法。你应该都会了</p>\n<ul>\n<li>\n<p><strong>先来先服务</strong>（First Come First Service，FCFS）</p>\n<ul>\n<li>直接按任务顺序依次寻道</li>\n</ul>\n</li>\n<li>\n<p><strong>最短寻道时间优先</strong>（Shortest Seek Time First，SSTF）</p>\n<ul>\n<li>处理与当前磁头位置最近的读写任务</li>\n</ul>\n</li>\n<li>\n<p><strong>扫描 / 电梯</strong>（SCAN）</p>\n<ul>\n<li>按照一个方向进行调度，直到撞上边缘才改变方向</li>\n</ul>\n</li>\n<li>\n<p><strong>LOOK</strong></p>\n<ul>\n<li>SCAN 优化，不会撞上边缘，只要磁头移动方向上不再有请求就立即改变磁头的方向</li>\n</ul>\n</li>\n<li>\n<p><strong>循环扫描</strong>（C-SCAN）</p>\n<ul>\n<li>按照一个方向（往大）进行调度，撞上最大边缘后返回到<strong>起点</strong>，再调度。除了返回过程一直都是同一个方向移动</li>\n</ul>\n</li>\n<li>\n<p><strong>C-LOOK</strong></p>\n<ul>\n<li>CSCAN 优化，只要在磁头移动方向上不再有请求，就立即让磁头返回起点</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"光存储器\"><a class=\"anchor\" href=\"#光存储器\">#</a> 光存储器</h1>\n<p>如光盘 CD</p>\n<p>CD 和 CD-ROM 采用类似的技术，但 CD-ROM 更加耐用且有纠错功能</p>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>\n<p>存储有信息的光盘可以廉价地进行大规模复制</p>\n</li>\n<li>\n<p>光盘更换方便</p>\n</li>\n<li>\n<p>寿命长</p>\n</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>\n<p>它是只读的，不能更改</p>\n</li>\n<li>\n<p>其存取时间比磁盘存储器慢得多</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>CD-R（写一次）</p>\n<p>CD-RW（写多次）</p>\n<h1 id=\"其他存储器\"><a class=\"anchor\" href=\"#其他存储器\">#</a> 其他存储器</h1>\n<h2 id=\"磁带\"><a class=\"anchor\" href=\"#磁带\">#</a> 磁带</h2>\n<p>使用与磁盘类似的记录和读取技术</p>\n<p>致命缺陷是顺序存取</p>\n<h2 id=\"u盘和固态硬盘\"><a class=\"anchor\" href=\"#u盘和固态硬盘\">#</a> U 盘和固态硬盘</h2>\n<p>采用快闪存储器</p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "计算机组织结构",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/COA7/",
            "url": "https://erinwithbmq.github.io/2025/01/11/COA7/",
            "title": "计组期末复习第七讲 Cache",
            "date_published": "2025-01-11T11:21:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>LaTeX 渲染有问题。将就着看吧。</p>\n</div>\n<h2 id=\"cache的基本思路\"><a class=\"anchor\" href=\"#cache的基本思路\">#</a> Cache 的基本思路</h2>\n<p><em><strong>存储器层次结构</strong></em></p>\n<p><img data-src=\"/image/COA7/ec942ba7d6f015987e548443fbb6dd8d.png\" alt=\"ec942ba7d6f015987e548443fbb6dd8d.png\" /></p>\n<p>解决<strong>内存墙</strong>带来的 CPU 和主存协作问题</p>\n<p>在使用主存（相对大而慢）之余，添加一块<strong>小而快</strong>的 cache</p>\n<p>Cache 位于 CPU 和主存之间，可以<strong>集成在 CPU 内部</strong>或作为<strong>主板上的一个模块</strong></p>\n<p>Cache 中存放了主存中的部分信息的 “副本”</p>\n<h2 id=\"cache的工作流程\"><a class=\"anchor\" href=\"#cache的工作流程\">#</a> Cache 的工作流程</h2>\n<p>主存中的一个块对应着 Cache 中的一个行</p>\n<p>检查（Check）：当 CPU 试图访问主存中的某个字时，首先检查这个字<strong>是否在 cache</strong> 中</p>\n<p>检查后分两种情况处理：</p>\n<p>命中（Hit）：如果在 cache 中，则把<strong>这个字传送给 CPU</strong></p>\n<p>未命中（Miss）：如果不在 cache 中，则将主存中包含这个字<strong>固定大小</strong>的块（block）<strong>读入 cache 中</strong>，然后再<strong>从 cache 传送该字</strong>给 CPU</p>\n<h3 id=\"命中和未命中的判断\"><a class=\"anchor\" href=\"#命中和未命中的判断\">#</a> 命中和未命中的判断</h3>\n<p>Cache 通过<strong>标记（tags）<strong>来标识其内容在</strong>主存</strong>中的对应<strong>位置</strong></p>\n<h3 id=\"程序访问的局部性原理\"><a class=\"anchor\" href=\"#程序访问的局部性原理\">#</a> 程序访问的局部性原理</h3>\n<p>类型：</p>\n<p>时间局部性：在相对较短的时间周期内，重复访问特定的信息（也就是问相同存储位置的信息）</p>\n<p>空间局部性：在相对较短的时间周期内，访问相邻存储位置的数据</p>\n<p>顺序局部性：当数据被<strong>线性排列和访问</strong>时，出现的空间局部性的一种特殊情况（比如访问一维数组中的元素）</p>\n<h3 id=\"向cache传送内容\"><a class=\"anchor\" href=\"#向cache传送内容\">#</a> 向 Cache 传送内容</h3>\n<p>利用 “时间局部性”</p>\n<p>将<strong>未命中</strong>的数据在<strong>返回给 CPU</strong> 的同时<strong>存放在 Cache</strong> 中，以便再次访问时命中</p>\n<h3 id=\"传送块而不是传送字\"><a class=\"anchor\" href=\"#传送块而不是传送字\">#</a> 传送块而不是传送字</h3>\n<p>利用 “空间局部性”</p>\n<p>将<strong>包含所访问的字</strong>的块存储到 Cache 中，以便在访问相邻数据时命中</p>\n<h3 id=\"平均访问时间\"><a class=\"anchor\" href=\"#平均访问时间\">#</a> 平均访问时间</h3>\n<h3 id=\"cache未命中原因\"><a class=\"anchor\" href=\"#cache未命中原因\">#</a> Cache 未命中原因</h3>\n<h4 id=\"义务失效compulsory-miss-冷启动失效cold-start-miss\"><a class=\"anchor\" href=\"#义务失效compulsory-miss-冷启动失效cold-start-miss\">#</a> 义务失效（Compulsory Miss）/ 冷启动失效（Cold Start Miss）</h4>\n<p>第一次访问一个块时</p>\n<h4 id=\"容量失效-capacity-miss\"><a class=\"anchor\" href=\"#容量失效-capacity-miss\">#</a> 容量失效 （Capacity Miss）</h4>\n<p>Cache 无法保存程序访问<strong>所需的所有数据块</strong>，则当某数据块被替换后，又重新被访问，则发生失效</p>\n<h4 id=\"冲突失效conflict-miss\"><a class=\"anchor\" href=\"#冲突失效conflict-miss\">#</a> 冲突失效（Conflict Miss）</h4>\n<p>多个存储器位置映射到<strong>同一 Cache 位置</strong></p>\n<h1 id=\"cache的设计要素\"><a class=\"anchor\" href=\"#cache的设计要素\">#</a> Cache 的设计要素</h1>\n<h2 id=\"映射功能mapping-function\"><a class=\"anchor\" href=\"#映射功能mapping-function\">#</a> 映射功能（Mapping Function）</h2>\n<h3 id=\"直接映射\"><a class=\"anchor\" href=\"#直接映射\">#</a> 直接映射</h3>\n<p>将主存中的每个块映射到一个<strong>固定可用</strong>的 cache 行中</p>\n<p>假设 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 是 cache 行号，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 是主存储器的块号，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> 是 cache 的行数</p>\n<p>$ i = j $ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">mod</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">d</span></span></span></span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span></p>\n<h4 id=\"块标记\"><a class=\"anchor\" href=\"#块标记\">#</a> （块）标记</h4>\n<p><img data-src=\"/image/COA7/70766a26a2bd5884b81762d09447c246.png\" alt=\"70766a26a2bd5884b81762d09447c246.png\" /></p>\n<p>假设 cache 有 4 行，每行包含 8 个字；主存中包含 128 个字。访问主存的地址长度为 7 位，则：</p>\n<ul>\n<li>\n<p>最低的 3 位：块内地址</p>\n</li>\n<li>\n<p>中间的 2 位：映射时所对应的 Cache 行号</p>\n</li>\n<li>\n<p>最高的 2 位：区分映射到同一行的不同块，记录为 Cache 标记（一行分配 4 个块，共四行 16 个块）</p>\n</li>\n</ul>\n<p>标记代表了你是这一行 / 组的第几个块，通过标记判断是否命中。</p>\n<p>tag = j /c （块号整除以行数）（组相联那就除以组数）</p>\n<ul>\n<li>\n<p>gpt 的解释</p>\n<p>在计算机体系结构中，** 缓存（cache）** 是一种用于加速数据访问的小型高速存储器，主要用于减少从主存中读取数据的延迟。直接映射（Direct Mapping）是缓存中一种简单且常用的映射机制。它将主存中的每一个内存块映射到缓存中唯一的一个缓存行位置。这种固定的映射关系使得直接映射缓存的实现简单且高效。</p>\n<h3 id=\"1-直接映射的原理\"><a class=\"anchor\" href=\"#1-直接映射的原理\">#</a> 1. 直接映射的原理</h3>\n<p>在直接映射缓存中，主存中的每一个块都可以映射到缓存中的一个固定位置。假设有一块主存和一个较小的缓存，主存中的每个块会根据其地址被映射到缓存中的一个特定行。具体映射方法如下：</p>\n<p>[缓存行号 = （内存块地址） \\bmod （缓存行数）]</p>\n<h3 id=\"2-地址分解\"><a class=\"anchor\" href=\"#2-地址分解\">#</a> 2. 地址分解</h3>\n<p>为了确定主存中的地址应该映射到缓存的哪个位置，内存地址通常会分为以下三部分：</p>\n<ul>\n<li>\n<p><strong>标记位（Tag）：</strong> 用于标识数据块的<strong>唯一性</strong>，确保找到的数据块是正确的。</p>\n</li>\n<li>\n<p><strong>索引位（Index）：</strong> 用于指定数据在缓存中的<strong>行位置</strong>。</p>\n</li>\n<li>\n<p><strong>块内偏移（Block Offset）：</strong> 用于找到数据<strong>块内</strong>的具体字节。</p>\n</li>\n</ul>\n<p>通过这种分解，缓存可以快速判断主存地址是否在缓存中。</p>\n<h3 id=\"3-直接映射的优缺点\"><a class=\"anchor\" href=\"#3-直接映射的优缺点\">#</a> 3. 直接映射的优缺点</h3>\n<ul>\n<li>\n<p><strong>优点：</strong> 实现简单，访问速度快，开销小。</p>\n</li>\n<li>\n<p><strong>缺点：</strong> 由于每个内存块都只能映射到缓存中的一个位置，可能会出现冲突导致频繁的<strong>缓存替换</strong>（Cache Miss）。例如，当多个内存块被映射到同一行时，它们会不断替换，从而降低缓存命中率。</p>\n</li>\n</ul>\n<h3 id=\"4-例子\"><a class=\"anchor\" href=\"#4-例子\">#</a> 4. 例子</h3>\n<p>假设有 4 行缓存（行号为 0 到 3），主存块会按照如下方式映射：</p>\n<ul>\n<li>\n<p>主存块 0、4、8... 都映射到缓存行 0</p>\n</li>\n<li>\n<p>主存块 1、5、9... 都映射到缓存行 1</p>\n</li>\n<li>\n<p>主存块 2、6、10... 都映射到缓存行 2</p>\n</li>\n<li>\n<p>主存块 3、7、11... 都映射到缓存行 3</p>\n</li>\n</ul>\n<p>当访问主存中块 4 的数据时，数据会被加载到缓存行 0。如果接下来访问块 0 或块 8，数据依然在缓存行 0，这可能导致缓存命中失败（Cache Miss）。</p>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>直接映射是一种效率较高的缓存映射方式，适合对实现复杂度要求不高的系统。但由于映射固定，容易产生冲突失效（Conflict Miss），对程序的访问模式敏感。</p>\n</li>\n<li>\n<p>举例</p>\n<p>好，下面我们通过一个简单的例子来说明直接映射缓存的读取数据过程。</p>\n<h3 id=\"假设条件\"><a class=\"anchor\" href=\"#假设条件\">#</a> 假设条件</h3>\n<ol>\n<li>\n<p><strong>主存和缓存参数：</strong></p>\n<ul>\n<li>\n<p>主存有 32 个块（Block），每个块 1 字节。</p>\n</li>\n<li>\n<p>缓存有 8 行（Cache Lines），每行 1 字节，因此只能缓存 8 个块的数据。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>映射规则：</strong></p>\n<ul>\n<li>\n<p>使用<strong>直接映射</strong>，即  <code>缓存行号 = （主存块地址）mod（缓存行数）</code> 。</p>\n</li>\n<li>\n<p>主存地址分为<strong>标记位</strong>和<strong>索引位</strong>两部分：</p>\n<ul>\n<li>\n<p>索引位：用来找到缓存行的位置（这里需要 (\\log_2 (8) = 3 ) 位）。</p>\n</li>\n<li>\n<p>标记位：用于区分属于同一个缓存行的不同主存块。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"示例\"><a class=\"anchor\" href=\"#示例\">#</a> 示例</h3>\n<p>假设我们需要访问主存地址  <code>12</code>  和  <code>28</code> ，来看在直接映射缓存中的情况。</p>\n<h4 id=\"步骤-1访问主存地址-12\"><a class=\"anchor\" href=\"#步骤-1访问主存地址-12\">#</a> 步骤 1：访问主存地址  <code>12</code></h4>\n<ol>\n<li>\n<p><strong>确定索引和标记位：</strong></p>\n<ul>\n<li>\n<p>地址  <code>12</code>  的二进制表示为  <code>1100</code> 。</p>\n</li>\n<li>\n<p>低 3 位  <code>100</code>  为索引位，对应的是缓存中的第  <code>4</code>  行（ <code>100</code>  二进制即  <code>4</code> ）。</p>\n</li>\n<li>\n<p>剩下的高位  <code>1</code>  是标记位，用来确认数据块来源。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>缓存操作：</strong></p>\n<ul>\n<li>\n<p>如果缓存行  <code>4</code>  里已经存有标记  <code>1</code>  的数据，表示数据命中，可以直接从缓存中读取。</p>\n</li>\n<li>\n<p>如果缓存行  <code>4</code>  的标记位不同，表示数据不在缓存中（缓存未命中）。此时，需要从主存中加载地址  <code>12</code>  的数据到缓存的第  <code>4</code>  行，并将标记位更新为  <code>1</code> 。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"步骤-2访问主存地址-28\"><a class=\"anchor\" href=\"#步骤-2访问主存地址-28\">#</a> 步骤 2：访问主存地址  <code>28</code></h4>\n<ol>\n<li>\n<p><strong>确定索引和标记位：</strong></p>\n<ul>\n<li>\n<p>地址  <code>28</code>  的二进制表示为  <code>11100</code> 。</p>\n</li>\n<li>\n<p>低 3 位  <code>100</code>  为索引位，对应的仍然是缓存中的第  <code>4</code>  行。</p>\n</li>\n<li>\n<p>高位  <code>11</code>  是标记位，用于区分不同的数据块。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>缓存操作：</strong></p>\n<ul>\n<li>\n<p>缓存行  <code>4</code>  目前存的是标记为  <code>1</code>  的数据块（即主存地址  <code>12</code>  的数据）。</p>\n</li>\n<li>\n<p>因为标记位不匹配（ <code>1</code>  不等于  <code>11</code> ），发生<strong>冲突未命中</strong>（Conflict Miss）。此时，需要将主存地址  <code>28</code>  的数据块加载到缓存行  <code>4</code> ，并更新标记为  <code>11</code> 。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结-2\"><a class=\"anchor\" href=\"#总结-2\">#</a> 总结</h3>\n<p>在这个例子中，访问主存地址  <code>12</code>  和  <code>28</code>  都映射到了缓存的第  <code>4</code>  行，但由于它们有不同的标记位，在访问  <code>28</code>  时导致了缓存替换。直接映射缓存的这种特性，使得某些相邻的内存块可能频繁发生缓存未命中。</p>\n</li>\n</ul>\n<h3 id=\"关联映射全相联映射\"><a class=\"anchor\" href=\"#关联映射全相联映射\">#</a> 关联映射（全相联映射）</h3>\n<p>一个主存块可以装入 cache<strong> 任意一行</strong></p>\n<p><img data-src=\"/image/COA7/3b009c490945c3a4350c32b6af171223.png\" alt=\"3b009c490945c3a4350c32b6af171223.png\" /></p>\n<p><strong>示例：</strong></p>\n<p>假设 cache 有 4 行，每行包含 8 个字；主存中包含 128 个字。访问主存的地址长度为 7 位，则：</p>\n<p>最低的 3 位：块内地址（1 个块里 8 个字）</p>\n<p>最高的 4 位：块号，记录为 Cache 标记 （16 个块，随机放到行中）</p>\n<ul>\n<li>\n<p>gpt 的解释</p>\n<p><strong>全相联映射</strong>（Fully Associative Mapping）是一种缓存映射机制，与直接映射不同，它不限制每个主存块固定映射到特定缓存行，而是允许主存中的任意块加载到缓存的任何行。这种灵活的映射方式消除了缓存行冲突，能够更有效地利用缓存空间，但也需要更复杂的查找机制。</p>\n<h3 id=\"全相联映射的基本原理\"><a class=\"anchor\" href=\"#全相联映射的基本原理\">#</a> 全相联映射的基本原理</h3>\n<p>在全相联映射中，主存中的任何一个数据块都可以存放在缓存的任意行中。因此，不需要像直接映射那样有固定的缓存行位置，而是通过标记位来判断主存块是否在缓存中。</p>\n<ul>\n<li>\n<p><strong>标记位（Tag）：</strong> <strong>唯一标识主存块</strong>，和缓存中的每一行<strong>比较标记位</strong>来判断缓存命中。</p>\n</li>\n<li>\n<p><strong>块内偏移（Block Offset）：</strong> 指定数据块<strong>内部</strong>的具体字节位置（用于确定具体的字节偏移）。</p>\n</li>\n</ul>\n<h3 id=\"访问过程\"><a class=\"anchor\" href=\"#访问过程\">#</a> 访问过程</h3>\n<p>当处理器需要访问某个内存地址时，全相联映射的访问过程如下：</p>\n<ol>\n<li>\n<p>从主存地址中<strong>提取标记位</strong>。</p>\n</li>\n<li>\n<p>将这个标记位与缓存中所有行的标记位<strong>逐一比较</strong>。</p>\n<ul>\n<li>\n<p>如果找到一个匹配的标记位，则表示缓存<strong>命中</strong>，可以直接从缓存中读取数据。</p>\n</li>\n<li>\n<p>如果没有找到匹配项，则表示缓存<strong>未命中</strong>，需要从主存中加载数据到缓存。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"缓存替换策略\"><a class=\"anchor\" href=\"#缓存替换策略\">#</a> 缓存替换策略</h3>\n<p>因为全相联映射允许任意数据块存放到任意缓存行，所以当缓存已满且需要加载新数据时，必须选择一个缓存行进行替换。常用的替换策略包括：</p>\n<ul>\n<li>\n<p><strong>FIFO（先进先出）：</strong> <strong>最早进入</strong>缓存的块最先被替换。</p>\n</li>\n<li>\n<p><strong>LRU（最近最少使用）：</strong> 替换<strong>最长时间未被访问</strong>的块，适用于大部分程序的访问模式。</p>\n</li>\n<li>\n<p><strong>LFU（最少使用频率）：</strong> 替换访问<strong>次数最少</strong>的块，适用于频繁访问相对固定数据的场景。</p>\n</li>\n</ul>\n<h3 id=\"优缺点\"><a class=\"anchor\" href=\"#优缺点\">#</a> 优缺点</h3>\n<p><strong>优点：</strong></p>\n<ul>\n<li>\n<p>没有缓存行冲突，因为任何数据块可以存放到缓存的任意位置。</p>\n</li>\n<li>\n<p>在某些访问模式下，命中率可能比直接映射和组相联映射更高。</p>\n</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>\n<p>需要比较所有缓存行的标记位，硬件实现复杂。</p>\n</li>\n<li>\n<p>替换策略的管理需要更多的硬件资源和复杂的算法。</p>\n</li>\n</ul>\n<h3 id=\"示例-2\"><a class=\"anchor\" href=\"#示例-2\">#</a> 示例</h3>\n<p>假设我们有一个小缓存，包含 4 行，可以存放 4 个字节的数据，每行可存放主存中的任意数据块：</p>\n<ol>\n<li>\n<p><strong>访问主存地址 5</strong>：缓存为空，将主存地址 5 的数据块加载到缓存行 1。</p>\n</li>\n<li>\n<p><strong>访问主存地址 9</strong>：缓存中没有地址 9 对应的数据，将它加载到缓存行 2。</p>\n</li>\n<li>\n<p><strong>再次访问主存地址 5</strong>：缓存中找到标记匹配的缓存行 1，所以直接命中，读取数据。</p>\n</li>\n<li>\n<p><strong>访问主存地址 12</strong>：如果缓存已满，选择一行替换。例如，使用 LRU 替换最近未访问的行。</p>\n</li>\n</ol>\n<h3 id=\"总结-3\"><a class=\"anchor\" href=\"#总结-3\">#</a> 总结</h3>\n<p>全相联映射通过允许任意主存块存放到任意缓存行，消除了缓存行冲突，适用于对命中率要求高的应用。然而，它实现复杂且需要替换策略，在硬件上更难实现，因此常用于小型缓存或与其他映射方式（如组相联映射）结合使用。</p>\n</li>\n</ul>\n<h3 id=\"组关联映射组相联映射\"><a class=\"anchor\" href=\"#组关联映射组相联映射\">#</a> 组关联映射（组相联映射）</h3>\n<p>Cache<strong> 分为若干组</strong>，每一组包含相同数量的行，每个主存块被映射到<strong>固定组的任意一行</strong></p>\n<p>分组是连续分组，即第 01 行是第 0 组，第 23 行是第 1 组……</p>\n<p>假设 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> 是 cache 组号，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 是主存块号，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 是组数</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> $= $ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">mod</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">d</span></span></span></span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span></p>\n<p>K - 路组关联映射：</p>\n<p>K = C / S（C 为行数，S 为组数）</p>\n<p><img data-src=\"/image/COA7/c3f60e48b12c5f8a8612769a5465e041.png\" alt=\"c3f60e48b12c5f8a8612769a5465e041.png\" /></p>\n<p><em><strong>示例：</strong></em></p>\n<p>假设 cache 有 4 行，每行包含 8 个字（即块大小为 8 个字，cache 里的一行对应着内存里的一个块），分成 2 个组；主存中包含 128 个字。访问主存的地址长度为 7 位，则：</p>\n<p>最低的 3 位：块内地址（一个块内有 8 个字）</p>\n<p>中间的 1 位：映射时所对应的 Cache 中的组（2 个组）</p>\n<p>最高的 3 位：区分映射到同一组的不同块，记录为 Cache 标记（一个组内分了 8 个块）</p>\n<ul>\n<li>\n<p>gpt 的解释</p>\n<p><strong>组相联映射</strong>（Set Associative Mapping）是缓存映射的一种折中方式，结合了直接映射和全相联映射的优点。它将缓存分成多个<strong>组</strong>（Set），每组包含若干个缓存行，每个内存块可以映射到一个特定的组，但可以存放在组中的任何缓存行。这种映射方式能够有效减少缓存冲突，同时又避免了全相联映射的高复杂度。</p>\n<h3 id=\"组相联映射的基本原理\"><a class=\"anchor\" href=\"#组相联映射的基本原理\">#</a> 组相联映射的基本原理</h3>\n<p>在组相联映射中，缓存分为  <code>N</code>  个组，每组包含  <code>k</code>  个缓存行（这种缓存通常称为<strong> k 路组相联缓存</strong>）。主存中的每个块只能映射到缓存中的一个组，但在组内的  <code>k</code>  个缓存行中可以任选一个来存放。</p>\n<ul>\n<li>\n<p><strong>映射方式</strong>：通过主存地址找到数据所在的组（类似直接映射），然后在组内的所有缓存行中查找对应的标记位（类似全相联映射）。</p>\n</li>\n<li>\n<p><strong>标记位（Tag）：</strong> 用于区分同一组中不同内存块的标记，确保是正确的数据块。</p>\n</li>\n<li>\n<p><strong>组索引位（Set Index）：</strong> 用于找到特定的数据组。</p>\n</li>\n<li>\n<p><strong>块内偏移（Block Offset）：</strong> 用于定位块内的具体字节。</p>\n</li>\n</ul>\n<h3 id=\"地址分解\"><a class=\"anchor\" href=\"#地址分解\">#</a> 地址分解</h3>\n<p>假设有一个 (2^m) 大小的缓存，分为 ( 2^s ) 个组，每组有  <code>k</code>  个缓存行。主存地址分为以下几部分：</p>\n<ul>\n<li>\n<p><strong>标记位（Tag）：</strong> 用来确认数据块的唯一性。</p>\n</li>\n<li>\n<p><strong>组索引位（Set Index）：</strong> 用于定位缓存中的特定组，组数为 (2^s)。</p>\n</li>\n<li>\n<p><strong>块内偏移（Block Offset）：</strong> 用于在数据块内找到具体的字节。</p>\n</li>\n</ul>\n<h3 id=\"访问过程-2\"><a class=\"anchor\" href=\"#访问过程-2\">#</a> 访问过程</h3>\n<ol>\n<li>\n<p>从主存地址中提取组索引位，找到数据块映射到的组。</p>\n</li>\n<li>\n<p>在该组中，依次检查  <code>k</code>  个缓存行的标记位：</p>\n<ul>\n<li>\n<p>如果找到匹配的标记位，则缓存<strong>命中</strong>，可以直接读取数据。</p>\n</li>\n<li>\n<p>如果没有找到匹配项，则缓存<strong>未命中</strong>，需要从主存中加载数据块到缓存的该组中一个空闲或替换的行。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"替换策略\"><a class=\"anchor\" href=\"#替换策略\">#</a> 替换策略</h3>\n<p>如果目标组中的缓存行已满且需要加载新数据，则需要选择一个行进行替换。常用的替换策略与全相联映射类似，包括：</p>\n<ul>\n<li>\n<p><strong>LRU（最近最少使用）：</strong> 替换组内最近最少被访问的缓存行。</p>\n</li>\n<li>\n<p><strong>随机替换</strong>：随机替换一个缓存行，简单且快速。</p>\n</li>\n</ul>\n<h3 id=\"示例-3\"><a class=\"anchor\" href=\"#示例-3\">#</a> 示例</h3>\n<p>假设有一个<strong> 4 路组相联缓存</strong>，总共 8 行，即缓存分成 2 个组，每组 4 行。</p>\n<ol>\n<li>\n<p><strong>访问主存地址 4</strong>：</p>\n<ul>\n<li>\n<p>计算组索引，找到主存地址 4 映射到缓存的第 0 组。</p>\n</li>\n<li>\n<p>检查第 0 组的所有缓存行，发现没有匹配的标记位。</p>\n</li>\n<li>\n<p>将主存地址 4 的数据块加载到第 0 组的一个空闲行。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>访问主存地址 12</strong>：</p>\n<ul>\n<li>\n<p>计算组索引，发现地址 12 也映射到第 0 组。</p>\n</li>\n<li>\n<p>检查第 0 组中的缓存行，发现没有匹配的标记位。</p>\n</li>\n<li>\n<p>将主存地址 12 的数据块加载到第 0 组的一个空闲行。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>再次访问主存地址 4</strong>：</p>\n<ul>\n<li>\n<p>计算组索引，找到第 0 组。</p>\n</li>\n<li>\n<p>发现标记位匹配，因此<strong>命中</strong>，可以直接读取数据。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>访问主存地址 20</strong>：</p>\n<ul>\n<li>\n<p>计算组索引，地址 20 映射到第 1 组。</p>\n</li>\n<li>\n<p>组内没有匹配的标记位，将地址 20 的数据块加载到第 1 组的一个空闲行。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"优缺点-2\"><a class=\"anchor\" href=\"#优缺点-2\">#</a> 优缺点</h3>\n<p><strong>优点：</strong></p>\n<ul>\n<li>\n<p>通过将缓存分成多组，减少了直接映射中的缓存冲突。</p>\n</li>\n<li>\n<p>查找过程比全相联映射简单，硬件开销相对较低。</p>\n</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>比直接映射复杂度略高，硬件上需要实现组内的部分相联查找。</li>\n</ul>\n<h3 id=\"总结-4\"><a class=\"anchor\" href=\"#总结-4\">#</a> 总结</h3>\n<p>组相联映射通过折中策略，将缓存划分成多个组，每个主存块只能映射到特定组，组内缓存行可以灵活存放数据。它在减少缓存冲突的同时，不需要全相联映射的复杂硬件支持，因此被广泛应用于现代处理器的缓存设计中。</p>\n</li>\n</ul>\n<h3 id=\"三种映射方式比较\"><a class=\"anchor\" href=\"#三种映射方式比较\">#</a> 三种映射方式比较</h3>\n<p>三种方式的相关性</p>\n<p>如果 K = 1，组关联映射等同于直接映射</p>\n<p>如果 K = C，组关联映射等同于关联映射</p>\n<p>K 是一组中行的数目，C 是 Cache 的行数</p>\n<ul>\n<li>\n<p><strong>关联度</strong>：一个主存块映射到 cache 中<strong>可能存放的位置个数</strong></p>\n<ul>\n<li>\n<p>直接映射：1</p>\n</li>\n<li>\n<p>关联映射：C</p>\n</li>\n<li>\n<p>组关联映射：K</p>\n</li>\n</ul>\n<p>关联度<strong>越低</strong>，命中率越低，判断是否命中的时间越短，标记所占额外空间开销越小</p>\n<ul>\n<li>\n<p>直接映射的命中率最低，命中时间最短，标记最短。</p>\n</li>\n<li>\n<p>关联映射的命中率最高，命中时间最长，标记最长。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"替换算法\"><a class=\"anchor\" href=\"#替换算法\">#</a> 替换算法</h2>\n<ul>\n<li>\n<p>最近最少使用算法（Least Recently Used, LRU）</p>\n</li>\n<li>\n<p>先进先出算法（First In First Out, FIFO）</p>\n</li>\n<li>\n<p>最不经常使用算法（Least Frequently Used, LFU）</p>\n</li>\n<li>\n<p>随机替换算法（Random）</p>\n</li>\n</ul>\n<h3 id=\"最近最少使用算法-lru\"><a class=\"anchor\" href=\"#最近最少使用算法-lru\">#</a> 最近最少使用算法 LRU</h3>\n<p>替换掉在 cache 中<strong>最长时间未被访问</strong>的数据块</p>\n<p>实现：</p>\n<ul>\n<li>增加 LRU 位，来标记访问时间（01234…… 数字越小表示越久没被访问）每次替换为 0 的块。</li>\n</ul>\n<p>LRU 位需要额外的硬件实现，会增加 cache 访问时间</p>\n<h3 id=\"先进先出算法-fifo\"><a class=\"anchor\" href=\"#先进先出算法-fifo\">#</a> 先进先出算法 FIFO</h3>\n<p>替换掉在 Cache 中<strong>停留时间最长</strong>的块</p>\n<p>实现：时间片轮转法或环形缓冲技术</p>\n<ul>\n<li>\n<p>每行包含一个标识位</p>\n</li>\n<li>\n<p>当同一组中的某行被替换时，将其标识位设为 1，同时将<strong>下一行</strong>的标识位设为 0</p>\n</li>\n<li>\n<p>如果被替换的是该组中的最后一行，则将该组中的第一行的标识位设为 0</p>\n</li>\n<li>\n<p>替换掉标识位为 0 的行中的数据块</p>\n</li>\n</ul>\n<p>标识位需要额外的硬件实现</p>\n<h3 id=\"最不经常使用算法-lfu\"><a class=\"anchor\" href=\"#最不经常使用算法-lfu\">#</a> 最不经常使用算法 LFU</h3>\n<p>替换掉 cache 中被访问次数最少的数据块</p>\n<p>实现：为每一行设置<strong>计数器</strong></p>\n<h3 id=\"随机替换算法\"><a class=\"anchor\" href=\"#随机替换算法\">#</a> 随机替换算法</h3>\n<p>随机替换</p>\n<h2 id=\"写策略\"><a class=\"anchor\" href=\"#写策略\">#</a> 写策略</h2>\n<p>考虑到主存和 Cache 的一致性，当 Cache 中某个数据块被修改时，需要考虑该数据块是否被修改。若被修改了，则在替换之前，需要将修改后的数据块写回主存。</p>\n<h3 id=\"写直达-write-through\"><a class=\"anchor\" href=\"#写直达-write-through\">#</a> 写直达 Write Through</h3>\n<p>所有写操作都<strong>同时</strong>对 cache 和主存进行</p>\n<p>会产生大量主存访问。</p>\n<h3 id=\"写回-write-back\"><a class=\"anchor\" href=\"#写回-write-back\">#</a> 写回 Write Back</h3>\n<p>先更新 cache 中的数据，当 cache 中某个数据块被替换时，如果它被修改了，才被写回主存</p>\n<p>利用一个 ** 脏位（dirty bit）** 或者使用位（use bit）来表示块是否被修改</p>\n<h3 id=\"缓存未命中时的写策略\"><a class=\"anchor\" href=\"#缓存未命中时的写策略\">#</a> 缓存未命中时的写策略</h3>\n<ul>\n<li>\n<p><strong>写不分配</strong>（Write Non-Allocate）：<strong>直接将数据写入主存</strong>，无需读入 cache</p>\n<ul>\n<li>\n<p>优点：避免 cache 和主存中的数据不一致</p>\n</li>\n<li>\n<p>通常搭配：<strong>写直达</strong></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>写分配</strong>（Write Allocate）：将数据所在的块<strong>读入 cache 后</strong>，在 cache 中更新内容</p>\n<ul>\n<li>\n<p>优点：利用了 cache 的高速特性，<strong>减少写内存次数</strong></p>\n</li>\n<li>\n<p>通常搭配：<strong>写回法</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"行大小\"><a class=\"anchor\" href=\"#行大小\">#</a> 行大小</h2>\n<p>假设从行的大小为一个字开始，随着行大小的逐步增大，则 Cache 命中率会增加</p>\n<p>当行大小变得较大之后，继续增加行大小，则 Cache 命中率会下降</p>\n<h2 id=\"cache-数目\"><a class=\"anchor\" href=\"#cache-数目\">#</a> Cache 数目</h2>\n<p>略</p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "计算机组织结构",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/COA/",
            "url": "https://erinwithbmq.github.io/2025/01/11/COA/",
            "title": "计组期末复习 1~6讲",
            "date_published": "2025-01-11T11:09:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>LaTeX 渲染有问题。将就着看吧。</p>\n</div>\n<h1 id=\"第一讲-计算机系统概述\"><a class=\"anchor\" href=\"#第一讲-计算机系统概述\">#</a> 第一讲 计算机系统概述</h1>\n<h2 id=\"组织与结构\"><a class=\"anchor\" href=\"#组织与结构\">#</a> 组织与结构</h2>\n<p>许多计算机制造商提供了一系列的计算机模型，它们都具有相同的体系结构，但组成不同。</p>\n<p>一台机器是否具备乘法指令的功能，这是计算机体系<strong>结构</strong>的问题</p>\n<p>如何实现这个乘法指令的，使用专门的乘法电路还是采用连续相加的加法电路等，这是计算机<strong>组成</strong>的问题</p>\n<p><strong>组织</strong>：对编程人员不可见。可以理解为具体功能实现的过程。</p>\n<p><strong>结构</strong>：对编程人员可见。理解为有哪些功能、指令等。</p>\n<h2 id=\"指令集体系结构-isa\"><a class=\"anchor\" href=\"#指令集体系结构-isa\">#</a> 指令集体系结构 ISA</h2>\n<p>ISA 是一种规约（Specification），它规定了如何使用硬件。</p>\n<p>在通用计算机系统是必不可少的一个抽象层。</p>\n<h2 id=\"摩尔定律\"><a class=\"anchor\" href=\"#摩尔定律\">#</a> 摩尔定律</h2>\n<p>当<strong>价格</strong>不变时，单芯片上所能包含的晶体管数量<strong>每年翻一番</strong>（后来变成每 18 个月翻一番）</p>\n<h2 id=\"冯诺依曼结构\"><a class=\"anchor\" href=\"#冯诺依曼结构\">#</a> 冯诺依曼结构</h2>\n<p>三个基本原则：</p>\n<ul>\n<li>\n<p>二进制</p>\n</li>\n<li>\n<p>存储程序</p>\n</li>\n<li>\n<p>5 个组成部分</p>\n<ul>\n<li>\n<p><strong>主存储器</strong>：地址和存储的内容</p>\n</li>\n<li>\n<p><strong>算术逻辑单元 / 处理单元 ALU</strong>：执行信息的实际处理</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>程序控制单元 / 控制单元 PC</strong>：指挥信息的处理</p>\n<p><strong>输入设备</strong>：将信息送入计算机中</p>\n<p><strong>输出设备</strong>：将处理结果以某种形式显示在计算机外</p>\n<p><img data-src=\"/image/COA/image.png\" alt=\"image.png\" /></p>\n<blockquote>\n<p>内存是存储器；硬盘是输入输出设备</p>\n</blockquote>\n<p>冯・诺伊曼的最重要的思想是 “<strong>存储程序（Stored-program）</strong>”</p>\n<h2 id=\"计算机性能\"><a class=\"anchor\" href=\"#计算机性能\">#</a> 计算机性能</h2>\n<p>计算机设计的主要目标是：提高 CPU 性能</p>\n<h3 id=\"cpu-性能\"><a class=\"anchor\" href=\"#cpu-性能\">#</a> CPU 性能</h3>\n<ol>\n<li>\n<p><strong>时钟频率 f</strong> / 时钟速度（单位：Hz）</p>\n<p>计算机<strong>在单位时间内</strong>（例如 1 秒钟）执行最基本操作的<strong>次数</strong></p>\n</li>\n<li>\n<p><strong>时钟周期 t</strong> / 周期时间（单位：s）</p>\n<p>执行每次最基本操作的时间</p>\n<ul>\n<li f=\"\">\n<p>时钟周期是时钟频率的倒数。t = \\frac{1}</p>\n</li>\n<li>\n<p>周期时间即为两个电子脉冲之间的时间</p>\n</li>\n</ul>\n<p><img data-src=\"/image/COA/5cdbdfaa3d2dd5de4fc26e60ddfa85da.png\" alt=\"5cdbdfaa3d2dd5de4fc26e60ddfa85da.png\" /></p>\n</li>\n<li>\n<p><strong>CPI</strong>（Cycles Per Instruction）<strong>每条指令所要的时钟周期数</strong></p>\n<p>也可以理解为<strong>每条指令所需要的基本操作的次数</strong></p>\n<p><img data-src=\"/image/COA/a34a2ef067e6aa328287a4b89b208c61.png\" alt=\"a34a2ef067e6aa328287a4b89b208c61.png\" /></p>\n<p>整个 CPI，即平均每条指令所需要的时钟周期数，用<strong>总时钟周期数除以总指令数</strong>即可。总时钟周期数，通过把不同种指令总时钟周期数相加得到。</p>\n<p>一个程序的处理时间：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><msub><mi>I</mi><mi>c</mi></msub><mo>∗</mo><mi>C</mi><mi>P</mi><mi>I</mi><mo>∗</mo><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">T = I_c*CPI*t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span>，即总时钟周期数乘以单个时钟周期的时间。</p>\n</li>\n<li>\n<p><strong>MIPS</strong> （Million Instructions Per Second）<strong>每秒百万条指令</strong></p>\n<p>MIPS 表示 CPU <strong>每秒钟可以执行多少百万条指令</strong>。</p>\n<p><img data-src=\"/image/COA/e442eb966ae7e0a184cde9e08b6250f4.png\" alt=\"e442eb966ae7e0a184cde9e08b6250f4.png\" /></p>\n<p>首先计算每秒执行多少条指令。即用<strong>总指令条数除以总时间</strong>（单位 s）。接着换算成每秒执行多少百万条指令。即再除以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>。</p>\n<p>由于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><msub><mi>I</mi><mi>c</mi></msub><mo>∗</mo><mi>C</mi><mi>P</mi><mi>I</mi><mo>∗</mo><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">T = I_c*CPI*t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span>，因此公式也可换成后面那种形式。</p>\n</li>\n<li>\n<p><strong>MFLOPS</strong>（Million Floating Point Operations Per Second）<strong>百万浮点运算每秒</strong></p>\n<p><img data-src=\"/image/COA/f8ae9a6c07156135f3e565d5c22d74f9.png\" alt=\"f8ae9a6c07156135f3e565d5c22d74f9.png\" /></p>\n<p><img data-src=\"/image/COA/5151377bbc7473a7a335e883b1771980.png\" alt=\"5151377bbc7473a7a335e883b1771980.png\" /></p>\n</li>\n<li>\n<p><strong>CPU 性能的基准程序</strong></p>\n<p>使用一系列基准程序来测量系统的性能</p>\n<p><img data-src=\"/image/COA/f3f2daeb6b07bfa5c36457a5515d3df9.png\" alt=\"f3f2daeb6b07bfa5c36457a5515d3df9.png\" /></p>\n</li>\n</ol>\n<h3 id=\"性能设计的基本原则\"><a class=\"anchor\" href=\"#性能设计的基本原则\">#</a> 性能设计的基本原则</h3>\n<p>Amdahl 定律</p>\n<ul>\n<li>\n<p>加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的重要性比例</p>\n</li>\n<li>\n<p>性能增加的递减规则：如果仅仅对计算机中的一部分做性能改进，改进越多，系统获得的效果越小。</p>\n</li>\n</ul>\n<h2 id=\"计算机顶层结构\"><a class=\"anchor\" href=\"#计算机顶层结构\">#</a> 计算机顶层结构</h2>\n<h3 id=\"cpu\"><a class=\"anchor\" href=\"#cpu\">#</a> CPU</h3>\n<p>中央处理单元（Central Processing Unit, CPU）: 获取并执行指令的计算机组成部分，它由 ** 一个 ALU、一个控制单元（PC）和多个寄存器（Reg）** 构成。在单处理单元系统中，它通常简称为处理器。</p>\n<h3 id=\"存储器\"><a class=\"anchor\" href=\"#存储器\">#</a> 存储器</h3>\n<p>在本门课及相关作业中，主存不等同于内存，因为准确来说，内部存储器确实不止包括主存。另外，从两本教材的整体术语使用情况来看，通常还是采用更准确的表述，即 “主存”。</p>\n<p>主存（主存储器）是内存（内部存储器）的一部分。</p>\n<p>内部存储器（内存）包含寄存器、高速缓存和主存。</p>\n<h1 id=\"第二讲-数据的机器级表示\"><a class=\"anchor\" href=\"#第二讲-数据的机器级表示\">#</a> 第二讲 数据的机器级表示</h1>\n<h2 id=\"整数\"><a class=\"anchor\" href=\"#整数\">#</a> 整数</h2>\n<p>正数原码反码补码都一样。</p>\n<p>负数：以 -8 为例</p>\n<p>原码：10001000 最高位代表是负数。其余正常</p>\n<p>反码：11110111 除了最高位外其他位取反</p>\n<p>补码：11111000 反码＋1</p>\n<p>一个负数的补码等于将对应正数补码 <strong>各位取反、末位加一</strong></p>\n<h3 id=\"移码表示\"><a class=\"anchor\" href=\"#移码表示\">#</a> 移码表示</h3>\n<p>将每一个数值加上一个偏置常数（excess/bias）</p>\n<p>通常当编码位数为 n 时，bias 取 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>𝟐</mi><mrow><mi>n</mi><mtext>−</mtext><mi>𝟏</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">𝟐^{n−𝟏}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mtight\">−</span><span class=\"mord mathbf mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> 或 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>𝟐</mi><mrow><mi>n</mi><mtext>−</mtext><mi>𝟏</mi></mrow></msup><mtext>−</mtext><mi>𝟏</mi></mrow><annotation encoding=\"application/x-tex\">𝟐^{n−𝟏}−𝟏</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mtight\">−</span><span class=\"mord mathbf mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord\">−</span><span class=\"mord mathbf\">1</span></span></span></span></p>\n<p><img data-src=\"/image/COA/e0426457488c752c26b313852ea24f31.png\" alt=\"e0426457488c752c26b313852ea24f31.png\" /></p>\n<p><img data-src=\"/image/COA/0ff0b17b7048512c99c95c38186dc62f.png\" alt=\"0ff0b17b7048512c99c95c38186dc62f.png\" /></p>\n<p>差别在于原码里 0 有两种表示方式，因此范围少了 1.</p>\n<h2 id=\"浮点数\"><a class=\"anchor\" href=\"#浮点数\">#</a> 浮点数</h2>\n<h3 id=\"规格化数\"><a class=\"anchor\" href=\"#规格化数\">#</a> 规格化数</h3>\n<p>顺序：SEM（<em>因为比较大小，按这个顺序最快</em>）</p>\n<p><img data-src=\"/image/COA/c34977f7357bacdf73b2632bcbca4ccc.png\" alt=\"c34977f7357bacdf73b2632bcbca4ccc.png\" /></p>\n<h3 id=\"ieee-754-标准\"><a class=\"anchor\" href=\"#ieee-754-标准\">#</a> IEEE 754 标准</h3>\n<p><img data-src=\"/image/COA/0b43ada42bf4fdc23e371f4246b56cab.png\" alt=\"0b43ada42bf4fdc23e371f4246b56cab.png\" /></p>\n<p>E 为无符号，计算出的值减去 127 得到阶码（规格化情况）。</p>\n<p><img data-src=\"/image/COA/85b005e3d6f2a140acaf60d7ab17d329.png\" alt=\"85b005e3d6f2a140acaf60d7ab17d329.png\" /></p>\n<p><img data-src=\"/image/COA/659939a3329173795ff64282091978ab.png\" alt=\"659939a3329173795ff64282091978ab.png\" /></p>\n<p>非规格化数，隐藏位为 0，阶码设为 - 126.</p>\n<h2 id=\"nbcd-码\"><a class=\"anchor\" href=\"#nbcd-码\">#</a> NBCD 码</h2>\n<p><img data-src=\"/image/COA/c80e895027d637e150c7a34ba150859c.png\" alt=\"c80e895027d637e150c7a34ba150859c.png\" /></p>\n<p>前四位为符号位。1100 为正，1101 为负。</p>\n<h2 id=\"补充int-与-float-精度\"><a class=\"anchor\" href=\"#补充int-与-float-精度\">#</a> 补充：int 与 float 精度</h2>\n<p>float 能表示更大的数</p>\n<p>靠近 0，float 精度更大</p>\n<p>数字越大，int 精度越大</p>\n<p>当 e = 23 时，int 与 float 精度相似。大于 23 后，int 精度更大。</p>\n<h1 id=\"第三讲-整数运算\"><a class=\"anchor\" href=\"#第三讲-整数运算\">#</a> 第三讲 整数运算</h1>\n<h2 id=\"加法器\"><a class=\"anchor\" href=\"#加法器\">#</a> 加法器</h2>\n<p>与门延迟: 1 级门延迟 (1ty)</p>\n<p>或门延迟: 1 级门延迟 (1ty)</p>\n<p>异或门延迟: 3 级门延迟 (3ty)</p>\n<p><img data-src=\"/image/COA/c48b18d1072e007164d56c395c2ff9e1.png\" alt=\"c48b18d1072e007164d56c395c2ff9e1.png\" /></p>\n<p>F：6ty，Cout：5ty（上面那个带一个弧的是异或门）</p>\n<p>F 是和，C 是进位</p>\n<h3 id=\"全先行进位加法器\"><a class=\"anchor\" href=\"#全先行进位加法器\">#</a> 全先行进位加法器</h3>\n<p>高位的运算必须等待低位的 “进位输出信号” 能否提前计算出 “进位输出信号”？—— 使用全先行进位加法器</p>\n<p>延迟：1ty + 2ty + 3ty = 6ty</p>\n<p>延迟和加法器的位数无关</p>\n<h2 id=\"补码表示的整数运算加法减法\"><a class=\"anchor\" href=\"#补码表示的整数运算加法减法\">#</a> 补码表示的整数运算：加法，减法</h2>\n<p>如何判断溢出？若两个符号不同的数字相加，不会溢出。</p>\n<p>若同号数字相加后变号，则溢出。</p>\n<p>减法：将一方变为相反数后进行加法。溢出同理判断。</p>\n<h2 id=\"补码表示的整数运算乘法\"><a class=\"anchor\" href=\"#补码表示的整数运算乘法\">#</a> 补码表示的整数运算：乘法</h2>\n<p>布斯乘法略</p>\n<p>溢出：</p>\n<p>硬件不判断溢出：寄存器会<strong>存 2n 位乘积</strong></p>\n<p>软件判断溢出：1）编译器判断溢出；2）程序员通过高级语言判断溢出</p>\n<h2 id=\"补码表示的整数运算除法\"><a class=\"anchor\" href=\"#补码表示的整数运算除法\">#</a> 补码表示的整数运算：除法</h2>\n<p><img data-src=\"/image/COA/77e1d15d7edfcf490624205c87b0b5d6.png\" alt=\"77e1d15d7edfcf490624205c87b0b5d6.png\" /></p>\n<h3 id=\"恢复余数除法\"><a class=\"anchor\" href=\"#恢复余数除法\">#</a> 恢复余数除法</h3>\n<p><img data-src=\"/image/COA/d9a6a25979642cdfa474b902ddaefce7.png\" alt=\"d9a6a25979642cdfa474b902ddaefce7.png\" /></p>\n<h3 id=\"不恢复余数除法\"><a class=\"anchor\" href=\"#不恢复余数除法\">#</a> 不恢复余数除法</h3>\n<p><img data-src=\"/image/COA/4025536b2f6079c564778ed955f0f6d8.png\" alt=\"4025536b2f6079c564778ed955f0f6d8.png\" /></p>\n<p><img data-src=\"/image/COA/01ca87484032c3b283836c7d490afa18.png\" alt=\"01ca87484032c3b283836c7d490afa18.png\" /></p>\n<h1 id=\"第四讲-浮点数运算\"><a class=\"anchor\" href=\"#第四讲-浮点数运算\">#</a> 第四讲 浮点数运算</h1>\n<h2 id=\"加法和减法\"><a class=\"anchor\" href=\"#加法和减法\">#</a> 加法和减法</h2>\n<p>必须确保两个操作数具有相同的<strong>指数值（阶）</strong></p>\n<p>低阶向高阶对齐。</p>\n<p>最后规格化</p>\n<h2 id=\"乘法和除法\"><a class=\"anchor\" href=\"#乘法和除法\">#</a> 乘法和除法</h2>\n<p>阶码相加减</p>\n<p>尾数相乘除</p>\n<p>最后规格化结果</p>\n<h2 id=\"精度考虑数据类型\"><a class=\"anchor\" href=\"#精度考虑数据类型\">#</a> 精度考虑：数据类型</h2>\n<p><img data-src=\"/image/COA/65baa900bd7a110f58cf0126e8c3631d.png\" alt=\"65baa900bd7a110f58cf0126e8c3631d.png\" /></p>\n<ul>\n<li>\n<p>GPT 解释</p>\n<p>下面逐条解释图中的判断及其恒真性：</p>\n<h3 id=\"1-x-intfloatx-恒假\"><a class=\"anchor\" href=\"#1-x-intfloatx-恒假\">#</a> 1. <strong> <code>X == (int)(float)X</code> </strong> （恒假）</h3>\n<ul>\n<li>\n<p><code>X</code>  是  <code>int</code>  类型， <code>(float)X</code>  将  <code>X</code>  转换为  <code>float</code>  类型，可能会引入精度损失（例如，对于某些较大的  <code>int</code>  值， <code>float</code>  无法精确表示它们）。</p>\n</li>\n<li>\n<p>再将  <code>(float)X</code>  转换回  <code>int</code>  时，如果由于精度损失导致值变化，则恒假。</p>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li><code>X = 2147483647</code> （ <code>int</code>  的最大值），转换为  <code>float</code>  会失去精度，导致最终结果不等。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"2-x-intdoublex-恒真\"><a class=\"anchor\" href=\"#2-x-intdoublex-恒真\">#</a> 2. <strong> <code>X == (int)(double)X</code> </strong> （恒真）</h3>\n<ul>\n<li>\n<p><code>X</code>  是  <code>int</code>  类型， <code>(double)X</code>  将  <code>X</code>  转换为更高精度的  <code>double</code>  类型， <code>double</code>  能精确表示  <code>int</code>  范围内的所有值。</p>\n</li>\n<li>\n<p>再将  <code>(double)X</code>  转回  <code>int</code>  时，值不会发生变化，因此恒真。</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"3-f-floatdoublef-恒真\"><a class=\"anchor\" href=\"#3-f-floatdoublef-恒真\">#</a> 3. <strong> <code>F == (float)(double)F</code> </strong> （恒真）</h3>\n<ul>\n<li>\n<p><code>F</code>  是  <code>float</code>  类型， <code>(double)F</code>  将其转换为更高精度的  <code>double</code>  类型，再将其转换回  <code>float</code> 。</p>\n</li>\n<li>\n<p>虽然  <code>double</code>  有更高精度，但转换为  <code>double</code>  并不会改变  <code>float</code>  原本的值。</p>\n</li>\n<li>\n<p>最后转换回  <code>float</code>  时，值也不会发生变化，因此恒真。</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"4-d-floatd-恒假\"><a class=\"anchor\" href=\"#4-d-floatd-恒假\">#</a> 4. <strong> <code>D == (float)D</code> </strong> （恒假）</h3>\n<ul>\n<li>\n<p><code>D</code>  是  <code>double</code>  类型， <code>(float)D</code>  将其转换为精度较低的  <code>float</code>  类型，可能导致精度损失。</p>\n</li>\n<li>\n<p>如果  <code>D</code>  中包含无法用  <code>float</code>  精确表示的值（如小数点后的更多有效数字或较大的数值），则转换后会产生误差，导致不相等。</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"5-x-floatx-恒假\"><a class=\"anchor\" href=\"#5-x-floatx-恒假\">#</a> 5. <strong> <code>X == (float)X</code> </strong> （恒假）</h3>\n<ul>\n<li>\n<p><code>X</code>  是  <code>int</code>  类型， <code>(float)X</code>  将其转换为浮点数类型。</p>\n</li>\n<li>\n<p><code>float</code>  表示的整数值可能因精度限制出现误差，特别是在较大的整数时。</p>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li><code>X = 16777217</code> （ <code>float</code>  的精度极限之外的值），此时  <code>(float)X</code>  将近似为  <code>16777216</code> ，导致不相等。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"6-x-x-0-恒假\"><a class=\"anchor\" href=\"#6-x-x-0-恒假\">#</a> 6. <strong> <code>X * X &gt;= 0</code> </strong> （恒假）</h3>\n<ul>\n<li>\n<p>对于  <code>int</code>  类型， <code>X * X</code>  的结果应该始终非负。</p>\n</li>\n<li>\n<p>然而， <code>int</code>  的乘法可能溢出，导致结果变为负数。</p>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li><code>X = 46341</code> ，则  <code>X * X = 2147488281</code> （溢出为负数）。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"7-f-f-0-恒真\"><a class=\"anchor\" href=\"#7-f-f-0-恒真\">#</a> 7. <strong> <code>F * F &gt;= 0</code> </strong> （恒真）</h3>\n<ul>\n<li>\n<p>浮点数  <code>F</code>  的平方恒为非负，因为：</p>\n<ul>\n<li>\n<p>若  <code>F</code>  为正或零， <code>F * F</code>  结果为正或零。</p>\n</li>\n<li>\n<p>若  <code>F</code>  为负， <code>F * F</code>  结果仍为正。</p>\n</li>\n<li>\n<p>唯一特殊值是  <code>NaN</code> （Not-a-Number），但在比较中不会返回  <code>true</code> 。</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"8-d-f-d-f-恒假\"><a class=\"anchor\" href=\"#8-d-f-d-f-恒假\">#</a> 8. <strong> <code>(D + F) - D == F</code> </strong> （恒假）</h3>\n<ul>\n<li>\n<p><code>D</code>  是  <code>double</code>  类型， <code>F</code>  是  <code>float</code>  类型， <code>D + F</code>  会将  <code>F</code>  转换为  <code>double</code>  后再计算。</p>\n</li>\n<li>\n<p>由于  <code>F</code>  转换为  <code>double</code>  可能存在精度误差，结果中的  <code>(D + F) - D</code>  可能与  <code>F</code>  不完全相等。</p>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li><code>D = 1.000000000000001</code> ， <code>F = 1.0</code> ，此时  <code>D + F</code>  会有误差。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"9-d-f-f-d-恒假\"><a class=\"anchor\" href=\"#9-d-f-f-d-恒假\">#</a> 9. <strong> <code>(D + F) - F == D</code> </strong> （恒假）</h3>\n<ul>\n<li>类似于第 8 条， <code>F</code>  转换为  <code>double</code>  后可能失去部分精度，因此  <code>(D + F) - F</code>  可能与  <code>D</code>  不完全相等。</li>\n</ul>\n<hr />\n<h3 id=\"10-13-130-恒假\"><a class=\"anchor\" href=\"#10-13-130-恒假\">#</a> 10. <strong> <code>1/3 == 1/3.0</code> </strong> （恒假）</h3>\n<ul>\n<li>\n<p><code>1/3</code>  是整除操作，结果为  <code>0</code> （因为两个整数相除，结果仍为整数）。</p>\n</li>\n<li>\n<p><code>1/3.0</code>  是浮点数除法，结果为  <code>0.3333...</code> （近似值）。</p>\n</li>\n<li>\n<p>因为  <code>0</code>  不等于  <code>0.3333...</code> ，所以恒假。</p>\n</li>\n</ul>\n<hr />\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>这张图主要考察了<strong>类型转换</strong>和<strong>数值精度</strong>的问题，包括整数与浮点数之间的转换、浮点数的精度损失、以及溢出等特性。理解这些需要熟悉数据类型的表示和计算机的浮点数运算规则。</p>\n</li>\n</ul>\n<h2 id=\"精度考虑附加位与舍入\"><a class=\"anchor\" href=\"#精度考虑附加位与舍入\">#</a> 精度考虑：附加位与舍入</h2>\n<p>两位附加位</p>\n<p>IEEE754 规定：中间结果须在右边加 2 个附加位（Guard &amp; Round）</p>\n<p>・保护位（Guard）：在尾数右边的位，左规时被移到尾数中</p>\n<p>・舍入位（Round）：在保护位右边的位，作为舍入的依据</p>\n<p>舍入方法（四种）：</p>\n<p>向最近 (看保护位首位是 0 还是 1 各占一半 1 进 0 舍)</p>\n<p>向正无穷</p>\n<p>向负无穷</p>\n<p>向 0</p>\n<p><img data-src=\"/image/COA/2e974ef2e1df6caca99a8a32cc303978.png\" alt=\"2e974ef2e1df6caca99a8a32cc303978.png\" /></p>\n<h1 id=\"第六讲-内部存储器\"><a class=\"anchor\" href=\"#第六讲-内部存储器\">#</a> 第六讲 内部存储器</h1>\n<p>存储器（Memory）由一定数量的单元构成，每个单元可以被唯一标识，每个单元都 有存储一个数值的能力</p>\n<ul>\n<li>\n<p><strong>地址</strong>：单元的唯一标识符（采用二进制）</p>\n</li>\n<li>\n<p><strong>地址空间：<strong>可唯一标识的</strong>单元总数</strong></p>\n</li>\n<li>\n<p><strong>寻址能力：<strong>存储在</strong>每个单元中的信息的位数</strong>，即内存中能被单独识别并独立存放一个数据的<strong>最小内存空间</strong></p>\n<ul>\n<li>大多数存储器是字节（8bit）寻址的，32 位计算机的最大寻址空间（地址空间）为 4GB （$ 2^<ruby>32} B = 2<rp>(</rp><rt>{22</rt><rp>)</rp></ruby>KB = 2^{12}MB = 4GB$)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"层次结构\"><a class=\"anchor\" href=\"#层次结构\">#</a> 层次结构</h2>\n<p><img data-src=\"/image/COA/783ac71cfbade18661ef0dbeac699634.png\" alt=\"783ac71cfbade18661ef0dbeac699634.png\" /></p>\n<p>越上面的越靠近 cpu，存储空间越小，但速度越快</p>\n<h2 id=\"半导体存储器\"><a class=\"anchor\" href=\"#半导体存储器\">#</a> 半导体存储器</h2>\n<p>用<strong>半导体芯片</strong>作主存储器是目前的主流做法</p>\n<p><img data-src=\"/image/COA/0264bfc4f4884c82f7508a59267084ad.png\" alt=\"0264bfc4f4884c82f7508a59267084ad.png\" /></p>\n<h3 id=\"ram-随机存取存储器\"><a class=\"anchor\" href=\"#ram-随机存取存储器\">#</a> RAM 随机存取存储器</h3>\n<p>随机访问：对存储器中任意数据的访问所花费的时间与数据所在位置无关</p>\n<p>可以简单快速地进行读 / 写操作</p>\n<p>易失的（Volatile）</p>\n<p>类型：</p>\n<ul>\n<li>\n<p>SRAM 静态 RAM</p>\n</li>\n<li>\n<p>DRAM 动态 RAM</p>\n</li>\n</ul>\n<p>SRAM 比 DRAM 更快，但加价格也更高</p>\n<p><img data-src=\"/image/COA/bc29e5e7d8daffd937120526d1f3b06e.png\" alt=\"bc29e5e7d8daffd937120526d1f3b06e.png\" /></p>\n<h3 id=\"rom-只读存储器\"><a class=\"anchor\" href=\"#rom-只读存储器\">#</a> ROM 只读存储器</h3>\n<p>一种可以长期保存信息的存储器，具有断电后信息仍可继续保存的特点，在正常工作时只可读取数据，而<strong>不能写入数据</strong></p>\n<h4 id=\"prom-可编程rom\"><a class=\"anchor\" href=\"#prom-可编程rom\">#</a> PROM 可编程 ROM</h4>\n<p>只能被写入一次，其他和 ROM 相同</p>\n<p>写过程是用电信号执行</p>\n<p>以下是主要进行读操作的存储器：</p>\n<h3 id=\"eprom-光可擦除可编程只读存储器\"><a class=\"anchor\" href=\"#eprom-光可擦除可编程只读存储器\">#</a> EPROM 光可擦除 / 可编程只读存储器</h3>\n<p>电写入（1-&gt;0）</p>\n<p>光擦除（0-&gt;1）在写操作前将封装芯片暴露在紫外线下</p>\n<h3 id=\"eeprom-电可擦除可编程只读存储器\"><a class=\"anchor\" href=\"#eeprom-电可擦除可编程只读存储器\">#</a> EEPROM 电可擦除 / 可编程只读存储器</h3>\n<p>电写入（1-&gt;0）</p>\n<p>电擦除（0-&gt;1）</p>\n<p>最贵</p>\n<h3 id=\"flash-memory-快闪存储器\"><a class=\"anchor\" href=\"#flash-memory-快闪存储器\">#</a> Flash memory 快闪存储器</h3>\n<p>电可擦除：与 EEPROM 原理类似，优于 EPROM</p>\n<p>可以在块级擦除，不能在字节级擦除：优于 EPROM，不如 EEPROM</p>\n<p>需要先擦除再写入</p>\n<h2 id=\"寻址\"><a class=\"anchor\" href=\"#寻址\">#</a> 寻址</h2>\n<p><strong>位元（memory cell）</strong>：半导体存储器的基本元件，用于存储 1 位数据</p>\n<p><strong>寻址单元</strong>：由若干相同地址的位元组成</p>\n<h3 id=\"地址译码器\"><a class=\"anchor\" href=\"#地址译码器\">#</a> 地址译码器</h3>\n<p><img data-src=\"/image/COA/3c2a88fbaecab06ded46108ecd2546e7.png\" alt=\"3c2a88fbaecab06ded46108ecd2546e7.png\" /></p>\n<p>如何寻址：行访问，列访问</p>\n<h2 id=\"刷新\"><a class=\"anchor\" href=\"#刷新\">#</a> 刷新</h2>\n<p>约束：刷新会占用<strong>片选线、地址线、地址译码器</strong></p>\n<ul>\n<li>\n<p><strong>集中式刷新</strong></p>\n<ul>\n<li>\n<p><strong>停止</strong>读写操作，并<strong>逐行刷新</strong></p>\n</li>\n<li>\n<p>刷新时<strong>无法操作内存</strong>（死区）</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>分散式刷新</strong></p>\n<ul>\n<li>\n<p>在每个存储周期中，当<strong>读写操作完成时</strong>进行刷新</p>\n</li>\n<li>\n<p>一次读写刷新一行，<strong>逐行刷新</strong></p>\n</li>\n<li>\n<p>会<strong>增加</strong>每个存储周期的时间</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>异步刷新</strong></p>\n<ul>\n<li>\n<p>每一行各自以<strong>固定间隔</strong>（小于最大刷新周期，毫秒级）刷新</p>\n</li>\n<li>\n<p>将 DRAM 的刷新安排在<strong> CPU 对指令的译码阶段</strong>，可有效避免死区</p>\n</li>\n<li>\n<p><strong>效率高</strong>：常用</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"dram架构\"><a class=\"anchor\" href=\"#dram架构\">#</a> DRAM 架构</h2>\n<p>传统 DRAM 是<strong>异步</strong>的。频率通常<strong>不超过 66MHz</strong></p>\n<p>高级 DRAM 架构是<strong>同步</strong>的。</p>\n<p>同步 DRAM（Synchronous DRAM, <strong>SDRAM</strong>）：频率通常<strong>不超过 133MHz</strong></p>\n<p>双速率 SDRAM（Double-Data-Rate SDRAM，<strong>DDR SDRAM / DDR</strong>）：</p>\n<p>DDR5 频率<strong>可达 4800MHz</strong></p>\n<h3 id=\"ddr-sdram\"><a class=\"anchor\" href=\"#ddr-sdram\">#</a> DDR SDRAM</h3>\n<p>实际上也是动态 RAM 的一种吧。</p>\n<p>Double Data Rate：每个时钟周期<strong>发送两次数据</strong>，一次在时钟脉冲的上升沿，一次在下降沿</p>\n<h2 id=\"从位元到主存\"><a class=\"anchor\" href=\"#从位元到主存\">#</a> 从位元到主存</h2>\n<p><strong>位元→寻址单元→存储阵列→芯片→模块组织→主存</strong></p>\n<p><img data-src=\"/image/COA/64ebd2f1b6d941ae7106e2837ddffef8.png\" alt=\"64ebd2f1b6d941ae7106e2837ddffef8.png\" /></p>\n<p><img data-src=\"/image/COA/2b24ac4c2a179776d358d2aeb9944cc8.png\" alt=\"2b24ac4c2a179776d358d2aeb9944cc8.png\" /></p>\n<p><strong>模块组织</strong></p>\n<ul>\n<li>\n<p><strong>位扩展</strong>：地址线不变，<strong>数据线增加</strong></p>\n<ul>\n<li>\n<p>使用 8 块 4K×1 bit 的芯片组成 4K×<strong>8</strong> bit 的存储器</p>\n</li>\n<li>\n<p>即一个单元内存储数增加了</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>字扩展</strong>：<strong>地址线增加</strong>，数据线不变</p>\n<ul>\n<li>\n<p>使用 4 个 16K×8 bit 的芯片组成 <strong>64K</strong>×8 bit 的存储器</p>\n</li>\n<li>\n<p>即增加了单元数</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>字、位同时扩展</strong>：地址线增加，数据线增加</p>\n<ul>\n<li>使用 8 个 16K×4 bit 的芯片组成 64K×8 bit 的存储器</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "计算机组织结构",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/CN12/",
            "url": "https://erinwithbmq.github.io/2025/01/11/CN12/",
            "title": "计网 名词解释整理",
            "date_published": "2025-01-11T11:01:00.000Z",
            "content_html": "<div class=\"note danger\">\n<p><strong>注意，也可能不全！！！！！！</strong></p>\n</div>\n<div class=\"note info\">\n<p>1 为闲着无聊统计考过的次数，数据不全，比如刚考的就没加进去。</p>\n</div>\n<h1 id=\"第一章\"><a class=\"anchor\" href=\"#第一章\">#</a> 第一章</h1>\n<ol>\n<li>\n<p><strong>LAN</strong>（Local Area Networks）局域网</p>\n</li>\n<li>\n<p><strong>WAN</strong>（Wide Area Networks）广域网</p>\n</li>\n<li>\n<p><strong>ISP，Internet Service Providers</strong>：互联网服务提供商 11</p>\n</li>\n<li>\n<p><strong>ISO，International Organization for Standardization，国际标准化组织</strong></p>\n</li>\n<li>\n<p><strong>OSI（开放系统互联参考模型，Open Systems Interconnection Model）</strong></p>\n<ul>\n<li>是由国际标准化组织（ISO）于 1984 年发布的一个标准化网络通信模型。OSI 模型将网络通信分为七个层次：......1</li>\n</ul>\n</li>\n<li>\n<p><strong>TCP/IP</strong>（传输控制协议 / 互联网协议模型），包含四个层次：....</p>\n</li>\n<li>\n<p>通信方式的三种类型：</p>\n<ul>\n<li>\n<p>单工通信（<strong>Simplex</strong>）：数据只能在一个方向上传输，无法实现双向通信。</p>\n</li>\n<li>\n<p>半双工通信（<strong>Half-Duplex</strong>）：数据可以在两个方向上传输，但在某一时刻只能在一个方向上传输。</p>\n</li>\n<li>\n<p>全双工通信（<strong>Full-Duplex</strong>）：数据可以在两个方向同时传输，发送和接收可以同时进行。<strong>11</strong></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>PDU（Protocol Data Unit）协议数据单元</strong>：协议数据单元，是指在分层网络结构，例如在开放式系统互联（OSI）模型中，在传输系统的每一层都将建立协议数据单元（PDU）。</p>\n</li>\n</ol>\n<h1 id=\"物理层\"><a class=\"anchor\" href=\"#物理层\">#</a> 物理层</h1>\n<ol>\n<li>\n<p><strong>无屏蔽双绞线（Unshielded Twisted Pair，UTP）</strong></p>\n<ul>\n<li>\n<p>易于安装且成本较低，线薄接口小</p>\n</li>\n<li>\n<p>三种类型：</p>\n<ul>\n<li>\n<p><strong>直通线 Straight Cable</strong>：连接不同类型的设备</p>\n</li>\n<li>\n<p><strong>反转线 Rollover Cable</strong>：配置路由器 / 交换机</p>\n</li>\n<li>\n<p><strong>交叉线 Crossover Cable</strong>：连接相同的设备</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>有屏蔽双绞线 STP</strong></p>\n</li>\n<li>\n<p><strong>同轴电缆 Coaxial Cable</strong></p>\n</li>\n<li>\n<p><strong>Collision Domains 冲突域</strong></p>\n<ul>\n<li>指在同一个网络环境中，多个设备在同一时间发送数据时，可能会发生 <strong>数据冲突</strong>（Collision）的区域</li>\n</ul>\n<p><strong>Broadcast Domain 广播域</strong></p>\n<ul>\n<li>指在一个局域网内，通过 <strong>广播</strong>（Broadcast）方式发送的数据包可以被所有设备接收到的区域</li>\n</ul>\n</li>\n<li>\n<p><strong>code 码元</strong></p>\n<ul>\n<li>在使用<strong>时间域</strong>的波形表示数字信号时，代表不同离散数值的基本波形</li>\n</ul>\n</li>\n<li>\n<p><strong>NRZ</strong> 不归零编码</p>\n</li>\n<li>\n<p><strong>RZ</strong> 归零编码</p>\n</li>\n<li>\n<p><strong>时分复用 TDM（ Time Division Multiplexing）111111</strong></p>\n<ul>\n<li>\n<p>时分复用（Time Division Multiplexing，TDM）是将时间划分为一段段等长的时分复用（TDM）帧， 每个时分复用的用户在每个 TDM 帧中占用固定序号的时隙。</p>\n</li>\n<li>\n<p>STDM： 统计时分复用</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>频分复用 FDM（ Frequency Division Multiplexing）</strong></p>\n<ul>\n<li>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li>\n</ul>\n</li>\n<li>\n<p><strong>波分复用 WDM（ Wavelength Division Multiplexing）</strong></p>\n<ul>\n<li>就是<strong>光的频分复用</strong>：频率和波长是成倒数关系的。</li>\n</ul>\n</li>\n<li>\n<p><strong>码分复用 CDM（Code Division Multiplexing）</strong></p>\n<ul>\n<li>\n<p>常用的名词是<strong>码分多址 CDMA (Code Division Multiple Access)</strong></p>\n</li>\n<li>\n<p>各用户使用经过特殊挑选的不同码型，彼此不会造成干扰。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"数据链路层\"><a class=\"anchor\" href=\"#数据链路层\">#</a> 数据链路层</h1>\n<ol>\n<li>\n<p><strong>MAC</strong> <strong>Media Access Control 介质访问控制</strong></p>\n<ul>\n<li><strong>介质访问控制</strong>是计算机网络中 <strong>数据链路层</strong> 的一个子层，专门负责管理多个设备如何共享通信介质。</li>\n</ul>\n</li>\n<li>\n<p><strong>LLC Logical Link Control 逻辑链路控制</strong></p>\n<ul>\n<li><strong>逻辑链路控制</strong>是 <strong>数据链路层（Data Link Layer）</strong> 的一部分，用于提供 <strong>数据链路层服务</strong>，并在不同类型的网络协议之间提供统一的接口。</li>\n</ul>\n</li>\n<li>\n<p><strong>CSMA/CD</strong> <strong>Carrier Sense Multiple Access with Collision Detection）带冲突检测的载波侦听多路访问 11111</strong></p>\n<ul>\n<li>适配器边发送数据边检<strong>测信道上的信号电压的变化情况</strong>，以便判断⾃⼰在发送数据时<strong>其他站是否也在发送数据。<strong>若</strong>发现碰撞</strong>，⽴即<strong>停⽌发送</strong>，按退避算法<strong>等待⼀段随机时间</strong>后再次发送。</li>\n</ul>\n</li>\n<li>\n<p><strong>CSMA/CA (Carrier Sense Multiple Access with Collision Avoidance) 避免冲突的载波侦听多路访问 1</strong></p>\n<ul>\n<li>发送站点<strong>在发送数据前</strong>，以控制短帧刺激接收站点<strong>发送应答短帧</strong>，使接收站点周围的站点<strong>监听到该帧</strong>，从而在一定时间内<strong>避免数据发送</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>NIC</strong> <strong>Network Interface Controller 网卡</strong></p>\n</li>\n</ol>\n<h1 id=\"网络层\"><a class=\"anchor\" href=\"#网络层\">#</a> 网络层</h1>\n<ol>\n<li>\n<p><strong>ARP Address Resolution Protocol 地址解析协议 11</strong></p>\n<ul>\n<li>使计算机能够查找与 IP 地址关联的计算机的 MAC 地址。</li>\n</ul>\n</li>\n<li>\n<p><strong>RARP（Reverse Address Resolution Protocol，反向地址解析协议）11111</strong></p>\n<ul>\n<li>将<strong> MAC 地址</strong>解析为对应的<strong> IP 地址</strong>。</li>\n</ul>\n</li>\n<li>\n<p><strong>IGP （Interior Gateway Protocols）内部网关协议</strong></p>\n<ul>\n<li>\n<p>在自治系统中使用</p>\n</li>\n<li>\n<p>又分为：</p>\n<ul>\n<li>\n<p><strong>距离矢量协议 DVP（Distance-Vector Protocols）</strong></p>\n<ul>\n<li>从<strong>邻居</strong>的角度查看网络拓扑</li>\n</ul>\n</li>\n<li>\n<p><strong>链路状态协议 LSP（Link State Protocols）</strong></p>\n<ul>\n<li>获取整个网络拓扑的通用视图</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>EGP（Exterior Gateway Protocols）外部网关协议</strong></p>\n<ul>\n<li>用于在自治系统之间路由数据包。</li>\n</ul>\n</li>\n<li>\n<p><strong>RIP（Routing Information Protocol）路由信息协议</strong></p>\n<ul>\n<li>基于距离矢量的内部网关协议</li>\n</ul>\n</li>\n<li>\n<p><strong>IGRP（Interior Gateway Routing Protocol）内部网关路由协议</strong></p>\n<ul>\n<li>基于距离矢量的内部网关协议。**EIGRP（Enhanced IGRP）** 是它的升级版。</li>\n</ul>\n</li>\n<li>\n<p><strong>OSPF（Open Shortest Path First）最短路径优先协议 1</strong></p>\n<ul>\n<li>基于链路状态的内部网关协议，消耗 CPU 和内存</li>\n</ul>\n</li>\n<li>\n<p><strong>VLSM</strong> <strong>Variable Length Subnet Mask 可变长度子网掩码 1</strong></p>\n<ul>\n<li>允许单个自治系统的网络具有不同的子网掩码</li>\n</ul>\n</li>\n<li>\n<p><strong>CIDR Classless InterDomain Routing 无类域间路由 11</strong></p>\n<ul>\n<li>一种用于 IP 地址分配和路由的机制。核心特点是无类别，采用斜杠表示法，可以聚合路由。</li>\n</ul>\n</li>\n<li>\n<p><strong>ICMP（Internet Control Message Protocol）因特网控制报文协议 111111</strong></p>\n<ul>\n<li>为了提高 IP 数据报交付成功的机会（消息管理和协商），允许主机或路由器<strong>报告差错情况和提供有关异常情况的报告</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>PING</strong>（Packet InterNet Groper）数据包因特网探索器</p>\n<ul>\n<li>用来测试两个主机之间的连通性</li>\n</ul>\n</li>\n<li>\n<p><strong>IGMP</strong>（Internet Group Management Protocol）互联网组管理协议</p>\n<ul>\n<li>专门用于 <strong>IPv4 网络</strong> 中的组播（Multicast）通信管理</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"传输层\"><a class=\"anchor\" href=\"#传输层\">#</a> 传输层</h1>\n<ol>\n<li>\n<p><strong>TCP（Transmission Control Protocol）传输控制协议</strong></p>\n<ul>\n<li>TCP 是一种<strong>面向连接的</strong>、<strong>可靠的</strong>传输协议，适用于需要确保数据正确性和顺序的通信场景。</li>\n</ul>\n</li>\n<li>\n<p><strong>UDP（User Datagram Protocol）用户数据报协议 1</strong></p>\n<ul>\n<li>UDP 是一种<strong>无连接的</strong>、<strong>快速的</strong>传输协议，适用于对速度要求高而对可靠性要求低的场景。</li>\n</ul>\n</li>\n<li>\n<p><strong>Socket 套接字</strong></p>\n<ul>\n<li>是网络通信的一个抽象概念，它是应用层和传输层之间的接口，用于实现网络数据通信。</li>\n</ul>\n</li>\n<li>\n<p><strong>NAT（Network Address Translation）网络地址转换 1</strong></p>\n<ul>\n<li>在 IP 数据包头中将一个地址交换为另一个地址，是网络地址即将用完的解决方案之一</li>\n</ul>\n</li>\n<li>\n<p><strong>PAT（端口地址转换，Port address translation）</strong></p>\n</li>\n</ol>\n<h1 id=\"应用层\"><a class=\"anchor\" href=\"#应用层\">#</a> 应用层</h1>\n<ol>\n<li>\n<p><strong>URL（Uniform Resource Locator）统一资源定位符 1</strong></p>\n<ul>\n<li>一种标准化的资源标识方法，用于定位互联网上的资源（如网页、文件、图片等）</li>\n</ul>\n</li>\n<li>\n<p><strong>HTTP（HyperText Transfer Protocol，超文本传输协议）111</strong></p>\n<ul>\n<li>一种<strong>应用层协议</strong>，用于在客户端和服务器之间传输超文本（如 HTML 文档）、图片、视频等资源。TCP，80</li>\n</ul>\n</li>\n<li>\n<p><strong>HTML（HyperText Markup Language，超文本标记语言）11</strong></p>\n<ul>\n<li>用于创建和设计网页的标记语言。</li>\n</ul>\n</li>\n<li>\n<p><strong>FTP （File Transfer Protocol）文件传输协议 11</strong></p>\n<ul>\n<li>一种可靠的，<strong>面向连接</strong>的传输文件协议，使用 TCP，20/21</li>\n</ul>\n</li>\n<li>\n<p><strong>TFTP （Trivial File Transfer Protocol）简单文件传输协议</strong></p>\n<ul>\n<li>一种简单的文件传输协议，使用 UDP， 69</li>\n</ul>\n</li>\n<li>\n<p><strong>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）11</strong></p>\n<ul>\n<li>是一种用于电子邮件<strong>发送</strong>的协议，邮件发送，登录发送等操作。TCP，25</li>\n</ul>\n</li>\n<li>\n<p><strong>POP3（Post Office Protocol version 3，邮局协议版本 3）</strong></p>\n<ul>\n<li>是一种用于<strong>接收邮件</strong>的协议. TCP，110</li>\n</ul>\n</li>\n<li>\n<p><strong>MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展）</strong></p>\n<ul>\n<li>是一种互联网标准，用于扩展电子邮件协议，使其能够支持文本之外的多种类型的数据</li>\n</ul>\n</li>\n<li>\n<p><strong>SNMP（Simple Network Management Protocol，简单网络管理协议）</strong></p>\n<ul>\n<li>是一种应用程序层协议，可简化网络设备之间的管理信息交换。UDP, 161/162</li>\n</ul>\n</li>\n<li>\n<p><strong>DNS（Domain Name System）域名系统 1111</strong></p>\n<ul>\n<li>是网络上的服务，该服务管理域名并响应客户端将域名转换为关联 IP 地址的请求。UDP，53</li>\n</ul>\n</li>\n<li>\n<p><strong>DHCP（Dynamic Host Configuration Protocol）动态主机配置协议</strong></p>\n<ul>\n<li>是一种网络管理协议，用于自动分配 IP 地址和其他网络参数（如子网掩码、默认网关、DNS 服务器）给网络中的设备。UDP, 67/68</li>\n</ul>\n</li>\n<li>\n<p><strong>Telnet 协议</strong></p>\n<ul>\n<li>用于远程连接主机。TCP, 23</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"路由器\"><a class=\"anchor\" href=\"#路由器\">#</a> 路由器</h1>\n<p>解决路由环路问题的四个办法：</p>\n<ol>\n<li>\n<p><strong>路由中毒（Route Poisoning）1</strong></p>\n<ul>\n<li>路由中毒，信息在路由表中失效的时候，把该表项的的度量值（metric）设为无穷大 16。</li>\n</ul>\n</li>\n<li>\n<p><strong>水平分隔（Split Horizon）11</strong></p>\n<ul>\n<li>从某个端口收到的报文信息，不能再从该端口发送回去</li>\n</ul>\n</li>\n<li>\n<p><strong>定义最大值（Maximum）</strong></p>\n<ul>\n<li>设置最大跳数</li>\n</ul>\n</li>\n<li>\n<p><strong>计时器（Hold-Down Timers）</strong></p>\n<ul>\n<li>标记为不可达时启动一个计时器，若在计时期间收到新的、更优的路径信息，会更新；否则，计时结束还没有新的有效路径信息，则删除该条目</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"路由协议\"><a class=\"anchor\" href=\"#路由协议\">#</a> 路由协议</h1>\n<ol>\n<li>\n<p><strong>指定路由器（Designated Router，DR）</strong>：只有在<strong>多路复用</strong>的链路下使用，被选举出来</p>\n</li>\n<li>\n<p><strong>备用指定路由器（Backup Designated Router，BDR）</strong>：如果 DR 坏了，再次选举会出现问题，如果 DR 损坏，BDR 立即成为 DR，目的是提高交换效率</p>\n</li>\n<li>\n<p><strong>ABR（Area Border Router）：区域边界路由器</strong>，有一定的约束（一个路由器最多连接 3 个路由器）。</p>\n</li>\n<li>\n<p><strong>TTL（Time To Live）被路由器丢弃之前允许通过的最大网段数量</strong></p>\n</li>\n</ol>\n<h1 id=\"局域网交换与-vlan\"><a class=\"anchor\" href=\"#局域网交换与-vlan\">#</a> 局域网交换与 VLAN</h1>\n<ol>\n<li>\n<p><strong>对称交换（Symmetric Switching）</strong></p>\n<p>可在具有<strong>相同带宽</strong>（10/10 Mbps 或 100/100 Mbps）的端口之间提供交换连接。</p>\n</li>\n<li>\n<p><strong>非对称交换（Asymmetric Switching）</strong></p>\n<p>通过将带有服务器的网段连接到更高带宽的端口（100 Mbps），减少了服务器上潜在瓶颈的可能性。</p>\n</li>\n<li>\n<p>交换机的交换方式：</p>\n<ol start=\"2\">\n<li>\n<p><strong>储存转发（Store-and-Forward）</strong></p>\n<ul>\n<li>交换机<strong>接收整个帧</strong>，最后校验其 CRC，然后再将其发送到目的地。</li>\n</ul>\n</li>\n<li>\n<p><strong>直通（Cut-through）</strong></p>\n<ul>\n<li>\n<p>分为两种。</p>\n</li>\n<li>\n<p><strong>Fast forward switching 快速转发切换：<strong>仅在立即转发帧之前检查目标 MAC，即</strong>只要看到帧的目的地址就转发，而不看帧的后面的部分</strong>（Cut through 有的时候也直接指这个）</p>\n</li>\n<li>\n<p><strong>Fragment Free 碎片释放：<strong>在转发帧之前</strong>读取前 64 个字节</strong>以减少错误：避免碰撞和帧碎片</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>生成树协议（STP, The Spanning-Tree Protocol）1</strong></p>\n<ul>\n<li>是一种网络协议，用于以太网交换机环境中防止网络中的 <strong>环路</strong> 问题。</li>\n</ul>\n</li>\n<li>\n<p><strong>VLAN（Virtual Local Area Network）虚拟局域网</strong></p>\n<ul>\n<li>一种在局域网（LAN）中实现逻辑分段的技术，通过将一个物理网络划分为多个虚拟网络，实现对广播域的隔离。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"广域网\"><a class=\"anchor\" href=\"#广域网\">#</a> 广域网</h1>\n<ol>\n<li>\n<p><strong>PPP（Point-to-Point Protocol）点对点协议 111111</strong></p>\n<ul>\n<li>一种数据链路层通信协议，主要用于在两点之间建立直接连接的链路。</li>\n</ul>\n</li>\n<li>\n<p><strong>CHAP（Challenge Handshake Authentication Protocol）挑战握手认证协议 111</strong></p>\n<ul>\n<li>一种网络认证协议，常用于点对点协议（PPP）连接中，用于验证远程客户端的身份。三次握手，避免了密码的明文传输，更安全</li>\n</ul>\n</li>\n<li>\n<p><strong>ISDN（Integrated Services Digital Networks）综合数字服务网络</strong></p>\n<ul>\n<li>允许通过现有电话线传输数字信号，提供远程站点的连接</li>\n</ul>\n</li>\n<li>\n<p><strong>ADSL（Asymmetric Digital Subscriber Line）非对称数字用户线路</strong></p>\n<ul>\n<li>一种宽带接入技术，通过普通电话线（铜线）提供高速互联网接入</li>\n</ul>\n</li>\n<li>\n<p><strong>SONET（Synchronous Optical Network）同步光纤网</strong></p>\n<ul>\n<li>一种高性能的光纤通信标准</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"网络安全\"><a class=\"anchor\" href=\"#网络安全\">#</a> 网络安全</h1>\n<ol>\n<li>\n<p><strong>ACL（Access Control Lists）访问控制列表</strong></p>\n<ul>\n<li>是指令列表，它告诉<strong>路由器</strong>允许或拒绝什么类型的数据包。</li>\n</ul>\n</li>\n</ol>\n<br>\n<br>\n<p>其他需要背的：</p>\n<p>编码方式</p>\n<p>TCP 三次握手四次挥手</p>\n<p>端口号</p>\n<p>UDP 首部</p>\n<br>\n<br>\n<p>注：以下都有例外，仅为参考</p>\n<p>P：基本都是 Protocol</p>\n<p>A：Access 或者 Address</p>\n<p>I：Inter+xxx</p>\n<p>C：基本都是 Control</p>\n<p>T：大部分都是和 Transfer，Transmission，Translation 有关的</p>\n<p>N：大部分都是 Network</p>\n<br>\n<br>\n<p>2023 级考的名词解释是 DHCP CSMA/CD VLSM OSPF UDP PDU URL SMTP</p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "互联网计算",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/CN11/",
            "url": "https://erinwithbmq.github.io/2025/01/11/CN11/",
            "title": "计网第十一章 网络安全",
            "date_published": "2025-01-11T10:56:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>互联网计算系列整理主要内容来自软院 2020 级学长<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=\"> EagleBear2002 的博客</span>，为博主本人阅读后提炼整理的内容。<br />\n内容不算全面，仅推荐大家复习时参考。</p>\n</div>\n<p><strong>数据加密标准 DES Data Encryption Standard</strong></p>\n<p>数据加密标准 DES 属于常规密钥密码体制，是一种分组密码（对称加密算法）</p>\n<h1 id=\"acl\"><a class=\"anchor\" href=\"#acl\">#</a> ACL</h1>\n<p><strong>访问控制列表 ACL（Access Control Lists）<strong>是指令列表，它告诉</strong>路由器</strong>允许或拒绝什么类型的数据包。</p>\n<p>可以根据以下情况允许或拒绝数据包：</p>\n<ol>\n<li>\n<p>源地址</p>\n</li>\n<li>\n<p>目的地址</p>\n</li>\n<li>\n<p>上层的协议，比如 TCP 或 UDP 端口</p>\n</li>\n</ol>\n<p>ACL 末尾有一个隐含的  <code>deny any</code>  语句：如果数据包与 ACL 中的任何语句都不匹配，则将其<strong>丢弃</strong>。</p>\n<h3 id=\"exampleacl-例子\"><a class=\"anchor\" href=\"#exampleacl-例子\">#</a> Example：ACL 例子</h3>\n<p>如果我们有如下所述的 ACL 列表：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Permit packets <span class=\"selector-tag\">from</span> <span class=\"number\">192.168</span>.<span class=\"number\">100.1</span> <span class=\"selector-tag\">to</span> pass</span><br><span class=\"line\">Permit packets <span class=\"selector-tag\">from</span> <span class=\"number\">192.168</span>.<span class=\"number\">100.2</span> <span class=\"selector-tag\">to</span> pass</span><br><span class=\"line\">Deny packets <span class=\"selector-tag\">from</span> <span class=\"number\">192.168</span>.<span class=\"number\">100.3</span></span><br></pre></td></tr></table></figure>\n<p>然后：</p>\n<ol>\n<li>\n<p>Packets from 192.168.100.1 will be forwarded</p>\n</li>\n<li>\n<p>Packets from 192.168.100.3 will be denied</p>\n</li>\n<li>\n<p>But how does the router process the packets from 192.168.100.4? <strong>denied（默认被丢弃掉）</strong></p>\n</li>\n</ol>\n<h2 id=\"出站标准-acl-流程\"><a class=\"anchor\" href=\"#出站标准-acl-流程\">#</a> 出站标准 ACL 流程</h2>\n<ol>\n<li>\n<p>收到 packet，确定路由表确认路由表看能够转发</p>\n</li>\n<li>\n<p>可以转发的话，进入 ACL 确认</p>\n<ol start=\"3\">\n<li>\n<p>如果当前端口没有 ACL 配置，则直接进行转发</p>\n</li>\n<li>\n<p>如果当前端口有 ACL 配置，开始匹配 source 地址（标准的 ACL，只能对原地址进行判断）</p>\n<ol start=\"5\">\n<li>\n<p>语句满足条件，</p>\n<ol start=\"6\">\n<li>\n<p>deny</p>\n</li>\n<li>\n<p>premit</p>\n</li>\n</ol>\n</li>\n<li>\n<p>语句不满足条件，看下一条，如果没有下一条，则<strong>默认 deny</strong></p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>标准 ACL 只能显示声明拒绝规则，而扩展 ACL 可以显式声明拒绝规则和允许规则。因此，标准 ACL 的拒绝规则应当尽量放在出口</p>\n<p>在全局配置模式下顺序编写 ACL 语句：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Router(config)<span class=\"selector-id\">#access-list</span> <span class=\"selector-attr\">[access-list-number]</span> &#123;permit/deny&#125; &#123;test-conditions&#125;</span><br><span class=\"line\">Lab-D(config)<span class=\"selector-id\">#access-list</span> <span class=\"number\">1</span> deny <span class=\"number\">192.5</span>.<span class=\"number\">5.10</span> <span class=\"number\">0.0</span>.<span class=\"number\">0.0</span> 拒绝来自 <span class=\"number\">192.5</span>.<span class=\"number\">5.10</span> 的报文</span><br><span class=\"line\">Lab-D(config)<span class=\"selector-id\">#access-list</span> <span class=\"number\">1</span> deny host <span class=\"number\">192.5</span>.<span class=\"number\">5.10</span> 与上一行等价</span><br></pre></td></tr></table></figure>\n<p>在接口配置模式下将 ACL 分组（Group）到一个或多个接口。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Router(config-if)#&#123;protocol&#125; access-group access-list-number &#123;in/out&#125;</span><br><span class=\"line\">Lab-D(config-if)<span class=\"selector-id\">#ip</span> access-group <span class=\"number\">1</span> out/in</span><br></pre></td></tr></table></figure>\n<p>in：进入流量  out：发出流量</p>\n<h3 id=\"access-list-number-参数\"><a class=\"anchor\" href=\"#access-list-number-参数\">#</a> access-list-number 参数</h3>\n<table>\n<thead>\n<tr>\n<th>ACL Type</th>\n<th>ACL Number</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IP Standard</td>\n<td>1 to 99</td>\n</tr>\n<tr>\n<td>IP Extended</td>\n<td>100 to 199</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"通配符掩码\"><a class=\"anchor\" href=\"#通配符掩码\">#</a> 通配符掩码</h3>\n<p>编写通配符掩码（Wildcard Mask）以告知路由器地址中要匹配的位以及要忽略的位：<strong>0 位表示检查该位位置，1 表示忽略该位位置</strong>。</p>\n<h4 id=\"例子\"><a class=\"anchor\" href=\"#例子\">#</a> 例子：</h4>\n<ol>\n<li>\n<p>检查 192.5.5.0 255.255.255.0 该网络上的所有主机</p>\n<ul>\n<li>Answer： 192.5.5.0 0.0.0.255（和 net mask 是取反的）</li>\n</ul>\n</li>\n<li>\n<p>检查 192.5.5.32 255.255.255.224 子网中的所有主机</p>\n<ul>\n<li>192.5.5.32 0.0.0.31</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"any-命令\"><a class=\"anchor\" href=\"#any-命令\">#</a> any 命令</h3>\n<p><strong>必须编写语句以允许其他人通过。</strong></p>\n<p><code>Lab-A（config）#access-list 1 permit any</code>  ==  <code>Lab-A（config）#access-list 1 permit 0.0.0.0 255.255.255.255</code></p>\n<h3 id=\"主机名支持\"><a class=\"anchor\" href=\"#主机名支持\">#</a> 主机名支持</h3>\n<p><code>Lab-A（config）#access-list 1 permit host 192.5.5.10（host 专指 192.5.5.10）</code></p>\n<h2 id=\"标准-acl-的配置\"><a class=\"anchor\" href=\"#标准-acl-的配置\">#</a> 标准 ACL 的配置</h2>\n<p>标准 ACL 没有目标参数。因此，将标准 ACL 放置在尽可能靠近目标的位置。</p>\n<h2 id=\"扩展-acl\"><a class=\"anchor\" href=\"#扩展-acl\">#</a> 扩展 ACL</h2>\n<p>扩展 ACL 的编号范围为 100-199</p>\n<p>扩展功能包括基于过滤流量的功能。</p>\n<ol>\n<li>\n<p>目的地址</p>\n</li>\n<li>\n<p>ip 协议的部分（更加细分）：您可以编写语句以仅拒绝 ICMP 等协议或 RIP 和 IGRP 之类的路由协议</p>\n</li>\n</ol>\n<p>指令语法更加丰富：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Router(config)# access-list access-list-number &#123;permit|deny&#125; &#123;protocol|protocol-keyword&#125;&#123;<span class=\"selector-tag\">source</span> <span class=\"selector-tag\">source</span>-wildcard&#125; &#123;destination destination-wildcard&#125; <span class=\"selector-attr\">[protocol-specific options]</span> <span class=\"selector-attr\">[log]</span></span><br><span class=\"line\">Lab-<span class=\"selector-tag\">A</span>(config)<span class=\"selector-id\">#access-list</span> <span class=\"number\">101</span> deny tcp <span class=\"number\">192.5</span>.<span class=\"number\">5.0</span> <span class=\"number\">0.0</span>.<span class=\"number\">0.255</span> <span class=\"number\">210.93</span>.<span class=\"number\">105.0</span> <span class=\"number\">0.0</span>.<span class=\"number\">0.255</span> eq telnet log</span><br><span class=\"line\">#举例</span><br><span class=\"line\">Router1(config)<span class=\"selector-id\">#access-list</span> <span class=\"number\">100</span> deny ip host <span class=\"number\">201.201</span>.<span class=\"number\">201.4</span> host <span class=\"number\">205.205</span>.<span class=\"number\">205.2</span></span><br><span class=\"line\">Router1(config)<span class=\"selector-id\">#access-list</span> <span class=\"number\">100</span> permit ip any any</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Router(config-if)#&#123;protocol&#125; access-group</span><br><span class=\"line\">access-list-number &#123;in/out&#125;</span><br><span class=\"line\">Lab-<span class=\"selector-tag\">A</span>(config-if)<span class=\"selector-id\">#ip</span> access-group <span class=\"number\">101</span> out</span><br></pre></td></tr></table></figure>\n<p>参数：</p>\n<ol>\n<li>\n<p><code>access-list-number</code> ：choose from the range 100 to 199</p>\n</li>\n<li>\n<p><code>&#123;protocol | protocol-number&#125;</code> ：For the CCNA, you only need to know ip and tcp--many more are available，只用考虑 ip 和 tcp</p>\n</li>\n<li>\n<p><code>&#123;source source-wildcard&#125;</code> ：same as in standard 和标准的相似。可以用 host 而不写 wild</p>\n</li>\n<li>\n<p><code>&#123;destination destination-wildcard&#125;</code> ：formatted like the standard, but specifies the destination。可以用 host 而不写 wild</p>\n</li>\n<li>\n<p><code>[protocol-specific options]</code> ：这个参数用于确认协议的过滤部分，可选</p>\n</li>\n</ol>\n<p>如：拒绝网络 221.23.123.0 访问服务器 198.150.13.34</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Router-C(config)<span class=\"selector-id\">#access-list</span> <span class=\"number\">100</span> deny ip <span class=\"number\">221.23</span>.<span class=\"number\">123.0</span> <span class=\"number\">0.0</span>.<span class=\"number\">0.255</span> <span class=\"number\">198.150</span>.<span class=\"number\">13.34</span> <span class=\"number\">0.0</span>.<span class=\"number\">0.0</span></span><br><span class=\"line\">Router-C(config)<span class=\"selector-id\">#access-list</span> <span class=\"number\">100</span> permit ip any any</span><br><span class=\"line\">Router-C(config)<span class=\"selector-id\">#int</span> e0</span><br><span class=\"line\">Router-C(config-if)<span class=\"selector-id\">#ip</span> access-group <span class=\"number\">100</span> in</span><br></pre></td></tr></table></figure>\n<h3 id=\"acl-的校验\"><a class=\"anchor\" href=\"#acl-的校验\">#</a> ACL 的校验</h3>\n<ol>\n<li>\n<p><code>show access-lists</code>  查看全部</p>\n</li>\n<li>\n<p><code>shows all access-lists configured on the router</code>  显示路由器上配置的所有访问列表</p>\n</li>\n<li>\n<p><code>show access-lists &#123;name | number&#125;</code>  查看某一个端口的</p>\n</li>\n</ol>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "互联网计算",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/CN10/",
            "url": "https://erinwithbmq.github.io/2025/01/11/CN10/",
            "title": "计网第十章 广域网",
            "date_published": "2025-01-11T10:53:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>互联网计算系列整理主要内容来自软院 2020 级学长<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=\"> EagleBear2002 的博客</span>，为博主本人阅读后提炼整理的内容。<br />\n内容不算全面，仅推荐大家复习时参考。</p>\n</div>\n<p>WAN 在 OSI 的前三层运行，但<strong>主要集中在物理层和数据链路层</strong>。广域网和局域网相比相对低效。</p>\n<h1 id=\"ppp\"><a class=\"anchor\" href=\"#ppp\">#</a> PPP</h1>\n<p><strong>点对点协议（PPP，Point-to-Point Protocol）</strong>：PPP 包含用于识别网络层协议的协议字段（包含一个协议单元，指定网络协议），根据不同的网络协议对帧做控制与检查。</p>\n<p>串行链路上使用最广泛的<strong>第二层协议</strong></p>\n<p>PPP 提供以下功能：</p>\n<ol>\n<li>\n<p>网络协议多路复用</p>\n</li>\n<li>\n<p>动态分配 IP 地址</p>\n</li>\n<li>\n<p>验证：PAP，CHAP</p>\n</li>\n<li>\n<p>压缩</p>\n</li>\n<li>\n<p>错误检测</p>\n</li>\n</ol>\n<h2 id=\"pap-安全认证协议\"><a class=\"anchor\" href=\"#pap-安全认证协议\">#</a> PAP 安全认证协议</h2>\n<p>PPP 中一个可选择的方法</p>\n<p>PAP 由一方向另一方发起请求，另一方选择是否接受，双方具有相同的用户名和密码，发起方可以多次尝试</p>\n<h2 id=\"chap\"><a class=\"anchor\" href=\"#chap\">#</a> CHAP</h2>\n<p><strong>挑战握手认证协议（Challenge Handshake Authentication Protocol，CHAP）</strong></p>\n<p>避免明文发送，三阶段握手，发起方是 HQ，找一个时间来 Challenge，然后由用户进行 response，之后决定是否接受。密码密文发送比较安全，而且更加合理的设计。</p>\n<p><img data-src=\"/image/CN10/image.png\" alt=\"image.png\" /></p>\n<p>HQ 定期向用户发起 Challenge，是一个随机数</p>\n<p>用户获得随机数，将数字、用户名、密码通过特定加密算法加密后返回给 HQ</p>\n<p>HQ 将结果与自己的值检查响应，匹配则验证成功。</p>\n<h1 id=\"isdn\"><a class=\"anchor\" href=\"#isdn\">#</a> ISDN</h1>\n<p>** 综合数字服务网络（ISDN，Integrated Services Digital Networks）** 允许通过现有电话线传输数字信号：提供远程站点的连接</p>\n<p>ISDN 服务有两种：</p>\n<ol>\n<li>\n<p>BRI（基本速率接口，Basic Rate Interface），用户虚拟电路数据传，HDLC，PPP，两个 B 通道 + 一个 D 通道</p>\n</li>\n<li>\n<p>PRI（主速率接口，Primary Rate Interface），发送控制信息，LAPD</p>\n</li>\n</ol>\n<p><strong>B 通道</strong>：用于承载用户数据，每个通道的带宽为 <strong>64 Kbps</strong>。</p>\n<p><strong>D 通道</strong>：用于信令和控制，带宽为 <strong>16 Kbps</strong>。</p>\n<h1 id=\"adsl\"><a class=\"anchor\" href=\"#adsl\">#</a> ADSL</h1>\n<p><strong>非对称数字用户线路（ADSL，Asymmetric Digital Subscriber Line）</strong></p>\n<p>ADSL 的极限传输距离与<strong>数据率</strong>以及<strong>用户线的线径</strong>都有很大的关系（用户线越细，信号传输时的衰减就越大），而所能得到的最高数据传输速率与实际的用户线上的<strong>信噪比</strong>密切相关。ADSL 的 “非对称” 指的是其上行和下行带宽的不对称性，下行速度（从互联网到用户）通常远高于上行速度（从用户到互联网），适合用户以下载为主的使用需求。</p>\n<h1 id=\"sonet\"><a class=\"anchor\" href=\"#sonet\">#</a> SONET</h1>\n<p><strong>同步光纤网 SONET（Synchronous Optical Network）</strong></p>\n<p><strong>同步数字系列（Synchronous Digital Hierarchy，SDH）</strong></p>\n<p>SDH 的基本速率为 155.52 Mb/s</p>\n<p>SONET 第 1 级同步传送信号 STS-1（ Synchronous Transport Signal） 的传输速率为 51.84 Mb/s，第 3 级同步传送信号 STS-3 传输速率是 STS-1 的 3 倍，为 155.52 Mb/s， …，等等，依此类推。</p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "互联网计算",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/CN9/",
            "url": "https://erinwithbmq.github.io/2025/01/11/CN9/",
            "title": "计网第九章 局域网交换与 VLAN",
            "date_published": "2025-01-11T10:50:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>互联网计算系列整理主要内容来自软院 2020 级学长<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=\"> EagleBear2002 的博客</span>，为博主本人阅读后提炼整理的内容。<br />\n内容不算全面，仅推荐大家复习时参考。</p>\n</div>\n<h1 id=\"交换机\"><a class=\"anchor\" href=\"#交换机\">#</a> 交换机</h1>\n<p>交换机是基于<strong>硬件</strong>的。</p>\n<h2 id=\"基本功能\"><a class=\"anchor\" href=\"#基本功能\">#</a> 基本功能</h2>\n<ol>\n<li>\n<p>根据 MAC 地址建立和维护<strong>交换表</strong>（类似于网桥表）</p>\n</li>\n<li>\n<p>将帧切换出接口到目标</p>\n</li>\n</ol>\n<h2 id=\"对称交换\"><a class=\"anchor\" href=\"#对称交换\">#</a> 对称交换</h2>\n<p><strong>对称交换（Symmetric Switching）<strong>可在具有</strong>相同带宽</strong>（10/10 Mbps 或 100/100 Mbps）的端口之间提供交换连接。</p>\n<h2 id=\"非对称交换\"><a class=\"anchor\" href=\"#非对称交换\">#</a> 非对称交换</h2>\n<p>** 非对称交换（Asymmetric Switching）** 通过将带有服务器的网段连接到更高带宽的端口（100 Mbps），减少了服务器上潜在瓶颈的可能性。</p>\n<p>非对称交换需要在交换器中进行<strong>内存缓冲</strong>。</p>\n<p>内存缓冲：<strong>交换机中存储目标和传输数据的内存区域</strong>，直到可以将其切换出正确的端口为止。</p>\n<h2 id=\"交换方式\"><a class=\"anchor\" href=\"#交换方式\">#</a> 交换方式</h2>\n<h3 id=\"储存转发\"><a class=\"anchor\" href=\"#储存转发\">#</a> 储存转发</h3>\n<p><strong>储存转发（Store-and-Forward）</strong>：网桥、路由器等通过软件转发的设备使用。</p>\n<p>交换机<strong>接收整个帧</strong>，最后校验其 CRC，然后再将其发送到目的地。</p>\n<h3 id=\"直通\"><a class=\"anchor\" href=\"#直通\">#</a> 直通</h3>\n<p><strong>直通（Cut-through）</strong></p>\n<p>上述存储转发会增加延迟，通过使用直通切换方法可以<strong>减少延迟</strong>。分为下面两种</p>\n<p>快速转发切换（Fast forward switching）：仅在立即转发帧之前检查目标 MAC，即<strong>只要看到帧的目的地址就转发，而不看帧的后面的部分</strong></p>\n<p>碎片释放（Fragment Free）：在转发帧之前<strong>读取前 64 个字节</strong>以减少错误：避免碰撞和帧碎片</p>\n<p><img data-src=\"/image/CN9/image.png\" alt=\"image.png\" /></p>\n<h2 id=\"不同层的交换机\"><a class=\"anchor\" href=\"#不同层的交换机\">#</a> 不同层的交换机</h2>\n<p>一般用第二层。略</p>\n<h1 id=\"生成树协议\"><a class=\"anchor\" href=\"#生成树协议\">#</a> 生成树协议</h1>\n<p><strong>生成树协议（STP, The Spanning-Tree Protocol）</strong></p>\n<p>往往是<strong>第二层交换机</strong>的冗余导致的桥回路。</p>\n<h2 id=\"生成树协议综述\"><a class=\"anchor\" href=\"#生成树协议综述\">#</a> 生成树协议综述</h2>\n<p>生成树协议的元素：</p>\n<ol>\n<li>\n<p>主要功能：在<strong>交换机 / 桥接网络</strong>中允许<strong>冗余路径</strong>，而不会因环路的影响而引起延迟。</p>\n</li>\n<li>\n<p>STP 通过计算<strong>稳定的生成树</strong>网络拓扑<strong>来防止环路</strong></p>\n</li>\n<li>\n<p><strong>生成树帧</strong>（称为桥协议数据单元，bridge protocol data unit，BPDU）用于确定生成树拓扑</p>\n</li>\n</ol>\n<p>在正常情况下禁用一些端口来防止出现冗余。</p>\n<h3 id=\"桥协议数据单元\"><a class=\"anchor\" href=\"#桥协议数据单元\">#</a> 桥协议数据单元</h3>\n<ol>\n<li>\n<p><strong>BPDU</strong> 是交换机之间的流量；它们不承载最终用户（end-user）流量。</p>\n</li>\n<li>\n<p>STP 建立一个称为<strong>根网桥的根节点</strong>，生成的树源自根桥。</p>\n</li>\n</ol>\n<h3 id=\"网桥标识-bid\"><a class=\"anchor\" href=\"#网桥标识-bid\">#</a> 网桥标识 BID</h3>\n<p>网桥 ID（BID）：8 个字节（2 + 6）</p>\n<ol>\n<li>\n<p>高阶子字段（2 个字节）：<strong>网桥优先级</strong>，值域：0-65535（默认值：32,768），通常以十进制格式表示</p>\n</li>\n<li>\n<p>低阶子字段（6 个字节）：分配给交换机的 <strong>MAC 地址</strong>，以十六进制格式表示</p>\n</li>\n</ol>\n<h3 id=\"路径代价\"><a class=\"anchor\" href=\"#路径代价\">#</a> 路径代价</h3>\n<p>记住 g 口相连代价为 4，f 口相连代价为 19</p>\n<h2 id=\"初始-stp-收敛\"><a class=\"anchor\" href=\"#初始-stp-收敛\">#</a> 初始 STP 收敛</h2>\n<h3 id=\"根交换机决定\"><a class=\"anchor\" href=\"#根交换机决定\">#</a> 根交换机决定</h3>\n<p>具有最低 BID 的交换机成为根交换机</p>\n<h3 id=\"选择根端口\"><a class=\"anchor\" href=\"#选择根端口\">#</a> 选择根端口</h3>\n<p>每个非根交换机都需要选择一个根端口。</p>\n<ol>\n<li>\n<p>离根交换机的 cost 最低</p>\n</li>\n<li>\n<p>若 cost 相同，则选择对端端口 ID（PID）最小的。（PID：优先级 + 端口号）</p>\n</li>\n</ol>\n<h3 id=\"选择指定端口\"><a class=\"anchor\" href=\"#选择指定端口\">#</a> 选择指定端口</h3>\n<p>每个网段都需要有一个指定端口。</p>\n<ol>\n<li>\n<p>根交换机的所有端口都是指定端口</p>\n</li>\n<li>\n<p>根端口的对端肯定是指定端口</p>\n</li>\n<li>\n<p>端口到根交换机的 cost 最低</p>\n</li>\n<li>\n<p>若 cost 相同，则选择本端交换机 BID 最小的</p>\n</li>\n</ol>\n<h1 id=\"vlan\"><a class=\"anchor\" href=\"#vlan\">#</a> VLAN</h1>\n<p><strong>虚拟局域网（Virtual Local Area Network，VLAN）</strong></p>\n<p>VLAN：</p>\n<ol>\n<li>\n<p>在第 2 层和第 3 层工作</p>\n</li>\n<li>\n<p>控制网络广播</p>\n</li>\n<li>\n<p>允许用户由网络管理员分配</p>\n</li>\n<li>\n<p>提供更严格的网络安全性</p>\n</li>\n</ol>\n<h2 id=\"vlan-的结构\"><a class=\"anchor\" href=\"#vlan-的结构\">#</a> VLAN 的结构</h2>\n<h3 id=\"骨干网-backbone\"><a class=\"anchor\" href=\"#骨干网-backbone\">#</a> 骨干网 BackBone</h3>\n<h3 id=\"路由器的作用\"><a class=\"anchor\" href=\"#路由器的作用\">#</a> 路由器的作用</h3>\n<p>通过路由器，vlan1 向 vlan2 发送信息</p>\n<p>trunk 链路要用交叉线来连接</p>\n<h2 id=\"vlan-的实现\"><a class=\"anchor\" href=\"#vlan-的实现\">#</a> VLAN 的实现</h2>\n<h3 id=\"静态-vlan\"><a class=\"anchor\" href=\"#静态-vlan\">#</a> 静态 VLAN</h3>\n<p>写死在交换机端口上</p>\n<h3 id=\"动态-vlan\"><a class=\"anchor\" href=\"#动态-vlan\">#</a> 动态 VLAN</h3>\n<p>交换机通过 MAC 地址或者哪一个协议，指定是哪一个 VLAN。</p>\n<h3 id=\"访问连接-access-links\"><a class=\"anchor\" href=\"#访问连接-access-links\">#</a> 访问连接 Access Links</h3>\n<p>访问连接是仅作为一个 VLAN 成员的交换机上的连接。</p>\n<p>此 VLAN 被称为端口的本机 VLAN，连接到端口的任何设备都完全不知道 VLAN 存在。</p>\n<h3 id=\"主干链路-trunk-links\"><a class=\"anchor\" href=\"#主干链路-trunk-links\">#</a> 主干链路 Trunk Links</h3>\n<p>主干链路能够支持多个 VLAN</p>\n<p>主干链路通常用于将交换机连接到其他交换机或路由器。</p>\n<p>一般 Trunk 就是 BackBone。</p>\n<h3 id=\"vlan-配置\"><a class=\"anchor\" href=\"#vlan-配置\">#</a> VLAN 配置</h3>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">Switch</span># vlan database</span><br><span class=\"line\"><span class=\"selector-tag\">Switch</span>(vlan)# vlan <span class=\"selector-attr\">[vlanid]</span></span><br><span class=\"line\"><span class=\"selector-tag\">Switch</span>(vlan)# exit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">Switch</span># show vlan <span class=\"selector-attr\">[vlanid]</span></span><br></pre></td></tr></table></figure>\n<p>不也可以直接在 config 里配置 vlan 吗。</p>\n<h2 id=\"在局域网之间的路由\"><a class=\"anchor\" href=\"#在局域网之间的路由\">#</a> 在局域网之间的路由</h2>\n<p>可以使用子接口，在路由器指定接口上划分多个接口。</p>\n<p><img data-src=\"/image/CN9/image%201.png\" alt=\"image.png\" /></p>\n<p><img data-src=\"/image/CN9/image%202.png\" alt=\"image.png\" /></p>\n<p><img data-src=\"/image/CN9/image%203.png\" alt=\"image.png\" /></p>\n<ol>\n<li>\n<p>如果是 Trunk Link：应该使用交叉线，而不是直通线</p>\n</li>\n<li>\n<p>如果是 Access Link：直通线</p>\n</li>\n</ol>\n<h3 id=\"vlan-题目备注\"><a class=\"anchor\" href=\"#vlan-题目备注\">#</a> VLAN 题目备注</h3>\n<ol>\n<li>\n<p>同一 VLAN 中的两台主机可以<strong>跨越多台交换机</strong></p>\n</li>\n<li>\n<p>必须是第三层及以上的交换机才能用来构建 VLAN</p>\n</li>\n</ol>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "互联网计算",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/CN8/",
            "url": "https://erinwithbmq.github.io/2025/01/11/CN8/",
            "title": "计网第八章 路由协议",
            "date_published": "2025-01-11T10:45:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>互联网计算系列整理主要内容来自软院 2020 级学长<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=\"> EagleBear2002 的博客</span>，为博主本人阅读后提炼整理的内容。<br />\n内容不算全面，仅推荐大家复习时参考。</p>\n</div>\n<h1 id=\"rip\"><a class=\"anchor\" href=\"#rip\">#</a> RIP</h1>\n<p>**RIP（Routing Information Protocol）** 是一种基于距离向量（Distance Vector）的动态路由协议。</p>\n<h2 id=\"ripv1\"><a class=\"anchor\" href=\"#ripv1\">#</a> RIPv1</h2>\n<p>距离向量协议。使用<strong>跳数</strong>作为度量标准，最大跳数为<strong> 15</strong>，达到 16 跳的报文自动抛弃。</p>\n<p>RIPv1 具有以下限制：</p>\n<ol>\n<li>\n<p>它不会在其更新中发送子网掩码信息：意味着必须用同样的子网掩码，不支持 VLSM 或无类域间路由（CIDR）。</p>\n</li>\n<li>\n<p>以 255.255.255.255 的广播形式发送更新：只能发给邻居，不能通过路由器转发。</p>\n</li>\n<li>\n<p>不支持身份验证</p>\n</li>\n</ol>\n<h3 id=\"rip-配置\"><a class=\"anchor\" href=\"#rip-配置\">#</a> RIP 配置</h3>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router rip # 选择 RIP 路由协议</span><br><span class=\"line\">network <span class=\"number\">1.0</span>.<span class=\"number\">0.0</span></span><br><span class=\"line\">network <span class=\"number\">2.0</span>.<span class=\"number\">0.0</span></span><br><span class=\"line\">凡是属于上面的网段的端口都运行 RIP 协议</span><br><span class=\"line\">这些网段必须做到直连该路由器</span><br></pre></td></tr></table></figure>\n<h2 id=\"ripv2\"><a class=\"anchor\" href=\"#ripv2\">#</a> RIPv2</h2>\n<p>新增了以下的功能：</p>\n<ol>\n<li>\n<p>这是一种使用<strong>跳数指标</strong>的距离矢量协议。</p>\n</li>\n<li>\n<p>它使用<strong>抑制计时器</strong>来防止路由循环，默认值为<strong> 180 秒</strong>，6 倍于交换时间</p>\n</li>\n<li>\n<p>它使用<strong>水平分割</strong>（Split Horizon）来防止路由循环（Routing Loops）</p>\n</li>\n<li>\n<p>它使用 16 跳作为<strong>无限距离的度量</strong>。（15 跳及以内可达）</p>\n</li>\n<li>\n<p>支持子网掩码的信息传播，允许使用 VLSM 和 CIDR（无类域间路由）。</p>\n</li>\n<li>\n<p>路由更新通过多播地址（ <code>224.0.0.9</code> ）发送，仅发送给支持 RIP 的设备</p>\n</li>\n<li>\n<p>支持路由更新消息的认证</p>\n</li>\n</ol>\n<p><code>version 2</code> ：表示启动 RIPv2，直接使用  <code>router rip</code>  默认为 v1，一定要输入这个命令才能启动 RIPv2</p>\n<h3 id=\"ripv1-和-ripv2-的对比\"><a class=\"anchor\" href=\"#ripv1-和-ripv2-的对比\">#</a> <strong>RIPv1 和 RIPv2 的对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>RIPv1</th>\n<th>RIPv2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>子网掩码支持</strong></td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td><strong>更新方式</strong></td>\n<td>广播（255.255.255.255）</td>\n<td>多播（224.0.0.9）</td>\n</tr>\n<tr>\n<td><strong>认证功能</strong></td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td><strong>路由环路避免</strong></td>\n<td>基本机制（分割视域等）</td>\n<td>增强机制（触发更新等）</td>\n</tr>\n<tr>\n<td><strong>最大跳数</strong></td>\n<td>15</td>\n<td>15</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>小型简单网络</td>\n<td>小型或中型网络</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"验证与故障排除\"><a class=\"anchor\" href=\"#验证与故障排除\">#</a> 验证与故障排除</h3>\n<p>故障排除 RIPv2：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Router<span class=\"selector-id\">#debug</span> ip rip #显示更新路由表的时候的更新</span><br><span class=\"line\">Router<span class=\"selector-id\">#undebug</span> <span class=\"attribute\">all</span> #（或 no debug <span class=\"attribute\">all</span>）：停止 debug</span><br></pre></td></tr></table></figure>\n<p><code>debug ip rip</code>  命令显示 RIP 路由更新的发送和接收。</p>\n<h1 id=\"ospf\"><a class=\"anchor\" href=\"#ospf\">#</a> OSPF</h1>\n<p>** 开放最短路径优先（OSPF，Open Shortest Path First）** 是基于开放标准（即该标准可以再扩充）的链路状态路由协议。</p>\n<p>与 RIPv1 和 RIPv2 相比，OSPF 正在成为首选的 IGP 协议（内部网关协议），因为它具有可伸缩性。</p>\n<h2 id=\"ospf-的核心特点\"><a class=\"anchor\" href=\"#ospf-的核心特点\">#</a> <strong>OSPF 的核心特点</strong></h2>\n<ol>\n<li>\n<p><strong>链路状态路由协议</strong><br />\n OSPF 路由器通过生成 LSA（Link State Advertisement，链路状态通告）来共享自身的链路状态信息，最终构建出整个网络的拓扑图。</p>\n</li>\n<li>\n<p><strong>Dijkstra 算法</strong><br />\n OSPF 使用 SPF（Shortest Path First）算法计算最短路径，基于拓扑数据库选择最优路由。</p>\n</li>\n<li>\n<p><strong>分层架构</strong></p>\n<ul>\n<li>\n<p>支持<strong>多区域</strong>设计（Area），以减少路由表规模和 SPF 计算量。</p>\n</li>\n<li>\n<p>区域 0 是主干区域（Backbone Area），其他区域必须通过主干区域互联。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>快速收敛</strong><br />\n网络拓扑发生变化时，OSPF 能够快速更新路由，减少收敛时间。</p>\n</li>\n<li>\n<p><strong>支持 VLSM 和 CIDR</strong><br />\nOSPF 可以传播子网掩码信息，支持灵活的 IP 地址分配。</p>\n</li>\n<li>\n<p><strong>认证机制</strong><br />\n支持明文和加密（MD5 或 SHA）认证，提供更高的安全性。</p>\n</li>\n<li>\n<p><strong>多播传输</strong><br />\n OSPF 使用多播地址  <code>224.0.0.5</code> （所有 OSPF 路由器）和  <code>224.0.0.6</code> （所有 DR/BDR 路由器）发送路由更新，减少广播风暴。</p>\n</li>\n</ol>\n<h2 id=\"ospf-与-rip-差别\"><a class=\"anchor\" href=\"#ospf-与-rip-差别\">#</a> OSPF 与 RIP 差别</h2>\n<p>OSPF：用于大型网络，基于带宽，可以分层（将网络划分成 2 层），收敛更快，支持多路负载均衡</p>\n<p><img data-src=\"/image/CN8/image.png\" alt=\"image.png\" /></p>\n<p>例如这张图，OSPF 走上（带宽大，计算出速度更快），RIP 走下（跳数更少）</p>\n<h2 id=\"ospf-术语\"><a class=\"anchor\" href=\"#ospf-术语\">#</a> OSPF 术语</h2>\n<h3 id=\"link-连接\"><a class=\"anchor\" href=\"#link-连接\">#</a> Link 连接</h3>\n<h3 id=\"link-state-链路状态\"><a class=\"anchor\" href=\"#link-state-链路状态\">#</a> Link-State 链路状态</h3>\n<p>邻居（Neighbors）：相邻的路由器</p>\n<p>物理链路的信息，包括路由器连接关系、通过什么接口、链路带宽、网络类型（点对点、多路复用）等，不同网络类型处理代价不同</p>\n<blockquote>\n<p>两种网络类型：点对点，多路复用</p>\n</blockquote>\n<ul>\n<li><strong>点对点与多路复用的区别</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>点对点网络</th>\n<th>多路复用网络</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>通信范围</strong></td>\n<td>两个节点之间</td>\n<td>多个节点共享同一链路</td>\n</tr>\n<tr>\n<td><strong>拓扑复杂性</strong></td>\n<td>简单</td>\n<td>较复杂</td>\n</tr>\n<tr>\n<td><strong>通信效率</strong></td>\n<td>高（独占带宽）</td>\n<td>可能因冲突或广播风暴受影响</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>点对点连接、链路少的场景</td>\n<td>局域网、大型网络</td>\n</tr>\n<tr>\n<td><strong>路由设计</strong></td>\n<td>不需要复杂路由算法</td>\n<td>通常需要 DR 和 BDR 协调</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"cost-代价费用\"><a class=\"anchor\" href=\"#cost-代价费用\">#</a> Cost 代价 / 费用</h3>\n<p><strong>一般是固定值除以带宽</strong>，与带宽成反比</p>\n<h3 id=\"area-区域\"><a class=\"anchor\" href=\"#area-区域\">#</a> Area 区域</h3>\n<p>具有相同区域 ID 的网络 / 路由器集合 。区域内的每个路由器都有相同的链路状态信息。</p>\n<p>Area 是对<strong>端口</strong>的划分，即一个路由器的不同端口可以属于不同 area。</p>\n<p>应该就是一个 Area 内互相传递 LSA？</p>\n<h3 id=\"autonomous-systemas-自治系统\"><a class=\"anchor\" href=\"#autonomous-systemas-自治系统\">#</a> Autonomous System，AS 自治系统</h3>\n<p>多个 Area 形成一个自治系统</p>\n<ul>\n<li>\n<p>Neighbours 必须在一个 Area 中，Neighbour 之间交换拓扑数据库（Topology Databases）当中存的是 link-state</p>\n</li>\n<li>\n<p>一个 Area 中获得全部 Link-State 后计算 Tree，生成表</p>\n</li>\n</ul>\n<p><img data-src=\"/image/CN8/image-20230716093615650.png\" alt=\"https://eaglebear2002.github.io/28848/image-20230716093615650.png\" /></p>\n<ul>\n<li>\n<p><strong>指定路由器（Designated Router，DR）</strong>：只有在<strong>多路复用</strong>的链路下使用，被选举出来</p>\n</li>\n<li>\n<p><strong>备用指定路由器（Backup Designated Router，BDR）</strong>：如果 DR 坏了，再次选举会出现问题，如果 DR 损坏，BDR 立即成为 DR，目的是提高交换效率</p>\n</li>\n</ul>\n<h3 id=\"ospf-域\"><a class=\"anchor\" href=\"#ospf-域\">#</a> OSPF 域</h3>\n<p>在多区域 OSPF 网络中，要求所有区域都连接到区域 0（主干）。</p>\n<p><img data-src=\"/image/CN8/image%201.png\" alt=\"image.png\" /></p>\n<p><strong>ABR（Area Border Router）：区域边界路由器</strong>，有一定的约束（一个路由器最多连接 3 个路由器）。</p>\n<p>一个 Area 中不能有超过 50 台路由器，否则会导致 SPF 算法产生的计算量和内存过大。</p>\n<h2 id=\"ospf-行为\"><a class=\"anchor\" href=\"#ospf-行为\">#</a> OSPF 行为</h2>\n<p>OSPF <strong>操作</strong>包括五个步骤：</p>\n<ol>\n<li>\n<p>建立邻接关系</p>\n</li>\n<li>\n<p>选择 DR 和 BDR（如果需要）：<strong>多路复用的时候才需要</strong></p>\n</li>\n<li>\n<p>发现路线</p>\n</li>\n<li>\n<p>选择适当的路线</p>\n</li>\n<li>\n<p>维护路线信息</p>\n</li>\n</ol>\n<p>OSPF 具有七个<strong>状态</strong>，它们是：</p>\n<ol>\n<li>\n<p>初始化（Init）</p>\n</li>\n<li>\n<p>双向操作（2Way）</p>\n</li>\n<li>\n<p>预先启动（Ex Start）</p>\n</li>\n<li>\n<p>交换（Exchange）</p>\n</li>\n<li>\n<p>加载（Loading）</p>\n</li>\n<li>\n<p>完成（Full）</p>\n</li>\n</ol>\n<p><img data-src=\"/image/CN8/image%202.png\" alt=\"image.png\" /></p>\n<h2 id=\"dr-与-bdr\"><a class=\"anchor\" href=\"#dr-与-bdr\">#</a> DR 与 BDR</h2>\n<p><img data-src=\"/image/CN8/image%203.png\" alt=\"image.png\" /></p>\n<p>OSPF 网络类型</p>\n<ol>\n<li>\n<p>广播多路复用网络，例如以太网</p>\n</li>\n<li>\n<p>点对点网络</p>\n</li>\n<li>\n<p>非广播多路复用网络（NBMA，Non-broadcast multi-access）</p>\n</li>\n</ol>\n<p>多路复用时要选举 DR/BDR，减少连接量与交流量</p>\n<ul>\n<li>\n<p>每个路由器都会与 DR（指定路由器）和 BDR（备份指定路由器）建立邻接关系。</p>\n</li>\n<li>\n<p>DR 使用 224.0.0.5 的多播地址（适用于所有 OSPF 路由器）向同一网络段中的所有其他路由器发送链路状态信息。</p>\n</li>\n<li>\n<p>为了确保 DR 和 BDR 能够接收到网络段上所有路由器发送的链路状态信息，使用 224.0.0.6 的多播地址（适用于所有 DR 和 BDR）。</p>\n</li>\n</ul>\n<p><strong>224.0.0.5</strong>：OSPF 所有路由器的多播地址，于让网络段上的所有 OSPF 路由器接收消息。<br />\n<strong>224.0.0.6</strong>：专用于 DR 和 BDR 的多播地址，用于路由器发送消息给 DR 和 BDR。</p>\n<h2 id=\"ospf-报文\"><a class=\"anchor\" href=\"#ospf-报文\">#</a> OSPF 报文</h2>\n<p>只有 5 个类型的报文</p>\n<table>\n<thead>\n<tr>\n<th>Fuction</th>\n<th>Name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Hello</td>\n<td>Hello</td>\n</tr>\n<tr>\n<td>Database Description</td>\n<td>DBD</td>\n</tr>\n<tr>\n<td>Link-State Request</td>\n<td>LSR</td>\n</tr>\n<tr>\n<td>Link-State Update</td>\n<td>LSU</td>\n</tr>\n<tr>\n<td>Link-State Acknowledgement</td>\n<td>LSAck</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"hello\"><a class=\"anchor\" href=\"#hello\">#</a> Hello</h3>\n<p>保持心跳，确定还活着。Hello 几乎是空报文，给所有跑 OSPF 的路由器发送。</p>\n<p>每 10 秒发送一次，数据包的地址为 224.0.0.5（多播）</p>\n<p>Hello 报文的 Type 字段设置为 1</p>\n<p><strong>TTL（Time To Live，被路由器丢弃之前允许通过的最大网段数量）</strong> 是 1，所以不会跨路由器传播，收到即丢弃</p>\n<h3 id=\"dr-选举\"><a class=\"anchor\" href=\"#dr-选举\">#</a> DR 选举</h3>\n<p><strong>优先级</strong>为第一关键字，<strong>Router ID</strong> 为第二关键字，最大的是 DR，第二大的是 BDR。</p>\n<p>优先级为零表示 “从不 DR”</p>\n<h2 id=\"ospf-操作\"><a class=\"anchor\" href=\"#ospf-操作\">#</a> OSPF 操作</h2>\n<ol>\n<li>\n<p>建立邻接关系</p>\n</li>\n<li>\n<p>选择 DR 和 BDR（如果需要）：<strong>多路复用的时候才需要</strong></p>\n</li>\n<li>\n<p>发现路线</p>\n</li>\n<li>\n<p>选择适当的路线</p>\n</li>\n<li>\n<p>维护路线信息</p>\n</li>\n</ol>\n<h3 id=\"1-建立路由器邻接\"><a class=\"anchor\" href=\"#1-建立路由器邻接\">#</a> 1. 建立路由器邻接</h3>\n<ol>\n<li>\n<p>路由器每隔一段时间发送一次 hello 数据包，Hello 报文的 TTL 是 1，表明不会跨路由传播</p>\n</li>\n<li>\n<p>如果邻居被发现了：将邻居添加到邻居数据库</p>\n</li>\n<li>\n<p>发现网络类型</p>\n<ol start=\"4\">\n<li>\n<p>如果是<strong>多路复用网络</strong>，进入 DR/BDR 选举过程，然后进入步骤 2</p>\n</li>\n<li>\n<p>如果是点对点或点对多点网络，则不会举行 DR/BDR 选举过程，并跳过步骤 2</p>\n</li>\n<li>\n<p>如果 hello 数据包标头中的 <strong>DR/BDR 字段已被占用</strong>（即 DR/BDR 对<strong>已经存在</strong>），则不会进行 DR/BDR 选举，并跳过步骤 2</p>\n</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>如果对方的 DP/BDP 优于我的 DP/BDP，则接受对方的。</p>\n</blockquote>\n<h3 id=\"2-选举-dr-和-bdr\"><a class=\"anchor\" href=\"#2-选举-dr-和-bdr\">#</a> 2. 选举 DR 和 BDR</h3>\n<p>按照选举规则进行选举。当 DR 无效时，BDR 成为新的 DR</p>\n<p>注：</p>\n<ol>\n<li>\n<p>如果新的 OSPF 路由器以更高的优先级或 Router ID 加入网络，则当前的 DR 和 BDR <strong>不会更改</strong></p>\n</li>\n<li>\n<p>仅当当前 DR 失败时，它才成为新的 BDR</p>\n</li>\n</ol>\n<h3 id=\"3-发现路线\"><a class=\"anchor\" href=\"#3-发现路线\">#</a> 3. 发现路线</h3>\n<p>交换 LSA，直到同步链路状态数据库</p>\n<h3 id=\"4-选择适当路线\"><a class=\"anchor\" href=\"#4-选择适当路线\">#</a> 4. 选择适当路线</h3>\n<p>同步后，所有路由器进行 SPF 算法计算最短路径。</p>\n<p>OSPF 然后在路由表中安装成本最低的路径</p>\n<h3 id=\"5-维护路由信息\"><a class=\"anchor\" href=\"#5-维护路由信息\">#</a> 5. 维护路由信息</h3>\n<p>Hello 交换还用来判断邻居有没有死掉。</p>\n<p>问候间隔一般是 10s，即每 10s 发送一次 Hello。</p>\n<ul>\n<li>\n<p>广播多路访问和点对点链接，速度为 T1（1.544 Mbps） 或更高的链接：每 10 秒</p>\n</li>\n<li>\n<p>非广播多路访问链接，小于 T1 的链接：每 30 秒</p>\n</li>\n</ul>\n<p>死亡间隔是问候间隔的四倍。以 10s 为例，如果 40s 后还没有回应，那么邻居死了（不可达）。</p>\n<h3 id=\"链路状态变化出现\"><a class=\"anchor\" href=\"#链路状态变化出现\">#</a> 链路状态变化出现</h3>\n<p>Router A tells all OSPF DRs on <strong>224.0.0.6</strong>（组播地址），使用 <strong>LSU</strong>（linkState update）</p>\n<p>DR tells others on <strong>224.0.0.5</strong>，通过 <strong>LSU</strong> 告知所有的路由器</p>\n<h2 id=\"基本的-ospf-配置\"><a class=\"anchor\" href=\"#基本的-ospf-配置\">#</a> 基本的 OSPF 配置</h2>\n<ol>\n<li>\n<p>在路由器上启动 OSPF</p>\n<ol start=\"2\">\n<li>\n<p><code>Router（config）## router ospf process-id</code></p>\n</li>\n<li>\n<p>进程号：process-id</p>\n<ol start=\"4\">\n<li>\n<p>取值： 1 ~ 65535</p>\n</li>\n<li>\n<p>在一台路由器上识别多个 OSPF 进程</p>\n</li>\n<li>\n<p>通常在整个 AS（自治系统）中保持相同的进程 ID</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>在路由器上识别 IP 网络</p>\n<ol start=\"8\">\n<li>\n<p><code>Router（config-router） ## network address wildcardmask area area-id</code>  <strong>wildcardmask 和 subnet mask 相反（如子网 255.255.255.0，那么 wild 就是 0.0.0.255）</strong></p>\n</li>\n<li>\n<p>网络地址可以是整个网络，子网或接口的地址。</p>\n</li>\n<li>\n<p>若只有一个 Area，则为 area0</p>\n</li>\n<li>\n<p>写 IP 和写网段最后都是一样的。（IP 地址是单个设备具体地址，网段地址是主机号全为 0，表示一个范围的地址）</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"/image/CN8/image%204.png\" alt=\"image.png\" /></p>\n<h3 id=\"配置回路loop地址\"><a class=\"anchor\" href=\"#配置回路loop地址\">#</a> 配置回路（Loop）地址</h3>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Router(config)<span class=\"selector-id\">#interface</span> loopback number</span><br><span class=\"line\">Router(config-if)<span class=\"selector-id\">#ip</span> <span class=\"selector-tag\">address</span> <span class=\"selector-tag\">address</span> subnet-<span class=\"attribute\">mask</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>\n<p>必须在 OSPF 进程开始之<strong>前</strong>配置回环接口：会涉及到主从关系确定和 DR 的选举</p>\n</li>\n<li>\n<p>配置环回地址时，请使用 <strong>/32</strong> 掩码以避免潜在的路由问题</p>\n</li>\n<li>\n<p>I 建议您在基于 OSPF 的网络中的所有关键路由器上使用环回地址（专用或公用地址）。</p>\n</li>\n<li>\n<p>一旦配置立刻生效，不需要 no shutdown 的命令即可。</p>\n</li>\n</ol>\n<h3 id=\"修改-ospf-接口优先级\"><a class=\"anchor\" href=\"#修改-ospf-接口优先级\">#</a> 修改 OSPF 接口优先级</h3>\n<p><code>Router（config-if） ## ip ospf priority number</code></p>\n<p>优先级：越大越高</p>\n<ol>\n<li>\n<p>值：0-255, 默认为 1</p>\n</li>\n<li>\n<p>优先级 0 表示接口不能被选为 DR 或 BDR</p>\n</li>\n</ol>\n<p>查看 OSPF 的端口的优先级： <code>Router ## show ip ospf [interface type number]</code></p>\n<h3 id=\"修改接口成本\"><a class=\"anchor\" href=\"#修改接口成本\">#</a> 修改接口成本</h3>\n<p>直接修改成本： <code>ip ospf cost number（1-65535）</code></p>\n<p>配置带宽： <code>bandwidth number（单位Kbps）</code> 改变接口带宽（但是实际物理带宽不会改变）</p>\n<p>不是改变参考带宽！即改变除数。</p>\n<h3 id=\"设置计时器\"><a class=\"anchor\" href=\"#设置计时器\">#</a> 设置计时器</h3>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Router(config-if)## ip ospf hello-interval seconds</span><br><span class=\"line\">Router(config-if)## ip ospf dead-interval seconds</span><br></pre></td></tr></table></figure>\n<p>改变问候间隔与死亡间隔</p>\n<p>若只改变问候间隔，则死亡间隔自动变为四倍。</p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "互联网计算",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/CN7/",
            "url": "https://erinwithbmq.github.io/2025/01/11/CN7/",
            "title": "计网第七章 路由与路由器",
            "date_published": "2025-01-11T10:43:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>互联网计算系列整理主要内容来自软院 2020 级学长<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=\"> EagleBear2002 的博客</span>，为博主本人阅读后提炼整理的内容。<br />\n内容不算全面，仅推荐大家复习时参考。</p>\n</div>\n<h1 id=\"路由器基础\"><a class=\"anchor\" href=\"#路由器基础\">#</a> 路由器基础</h1>\n<h2 id=\"内部组件\"><a class=\"anchor\" href=\"#内部组件\">#</a> 内部组件</h2>\n<p><img data-src=\"/image/CN7/image.png\" alt=\"image.png\" /></p>\n<h3 id=\"ram-随机存取存储器\"><a class=\"anchor\" href=\"#ram-随机存取存储器\">#</a> RAM 随机存取存储器</h3>\n<p><strong>RAM（Random Access Memory，随机存取存储器）</strong></p>\n<ol>\n<li>\n<p>路由器配置文件的临时存储，一般做为内存使用</p>\n</li>\n<li>\n<p>断电或重新启动时 RAM 内容丢失</p>\n</li>\n<li>\n<p>访问很快</p>\n</li>\n</ol>\n<h3 id=\"nvram-非易失随机存取存储器\"><a class=\"anchor\" href=\"#nvram-非易失随机存取存储器\">#</a> NVRAM 非易失随机存取存储器</h3>\n<p><strong>NVRAM（Non-volatile RAM）</strong></p>\n<p>存储备份（backup）/ 启动（startup）配置文件</p>\n<p>路由器掉电或重启时内容不会丢失。</p>\n<p>保证快速访问，但是存储空间有限。</p>\n<h3 id=\"flash\"><a class=\"anchor\" href=\"#flash\">#</a> Flash</h3>\n<p>存储了 Cisco IOS（互联网操作系统），可以存储多个版本的 IOS</p>\n<p>相当于台式机硬盘</p>\n<p>断电保持</p>\n<h3 id=\"rom-只读存储器\"><a class=\"anchor\" href=\"#rom-只读存储器\">#</a> ROM 只读存储器</h3>\n<p><strong>ROM，Read-Only Memory</strong></p>\n<p>包含 POST（开机自检）</p>\n<p>引导程序（加载 Cisco IOS）</p>\n<p>作系统软件。有 IOS 的备份</p>\n<h2 id=\"接口-interface\"><a class=\"anchor\" href=\"#接口-interface\">#</a> 接口 Interface</h2>\n<p>略</p>\n<h1 id=\"路由器启动步骤\"><a class=\"anchor\" href=\"#路由器启动步骤\">#</a> 路由器启动步骤</h1>\n<h2 id=\"系统启动程序\"><a class=\"anchor\" href=\"#系统启动程序\">#</a> 系统启动程序</h2>\n<ol>\n<li>\n<p><strong>执行开机自检 POST</strong></p>\n</li>\n<li>\n<p>验证 CPU、内存和网络接口的基本操作</p>\n</li>\n<li>\n<p>软件初始化</p>\n</li>\n</ol>\n<h2 id=\"软件启动程序\"><a class=\"anchor\" href=\"#软件启动程序\">#</a> 软件启动程序</h2>\n<p>略</p>\n<p>如果 NVRAM 中<strong>没有</strong>有效的配置文件，则执行问题驱动（question-driven）的初始配置例程，该例程称为系统配置对话框，也称为<strong>设置模式 setup mode</strong></p>\n<h2 id=\"路由器初始化\"><a class=\"anchor\" href=\"#路由器初始化\">#</a> 路由器初始化</h2>\n<p>略</p>\n<h2 id=\"路由器-cli-指令\"><a class=\"anchor\" href=\"#路由器-cli-指令\">#</a> 路由器 CLI 指令</h2>\n<p><img data-src=\"/image/CN7/image%201.png\" alt=\"image.png\" /></p>\n<p><img data-src=\"/image/CN7/image%202.png\" alt=\"image.png\" /></p>\n<ul>\n<li>\n<p>检验基本的路由配置</p>\n<ul>\n<li>使用 show running-config 命令</li>\n</ul>\n</li>\n<li>\n<p>存储路由器基本配置</p>\n<ul>\n<li>\n<p>copy running-config</p>\n<ul>\n<li>startup-config</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>其他检验路由器的命令:</p>\n<ul>\n<li>\n<p>Show running-config – 显示当前随机访问存储器中的配置</p>\n</li>\n<li>\n<p>Show startup-config – 显示 NVRAM 中的配置文件</p>\n</li>\n<li>\n<p>Show IP route – 现实路由表</p>\n</li>\n<li>\n<p>Show interfaces – 显示所有接口的配置信息</p>\n</li>\n<li>\n<p>Show IP int brief - 显示接口的简要信息</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"路由和配置\"><a class=\"anchor\" href=\"#路由和配置\">#</a> 路由和配置</h1>\n<p>收敛时间 Convergence Time：</p>\n<ol>\n<li>\n<p>从刚启动到网络达到稳定的时间</p>\n</li>\n<li>\n<p>从发生变化到再次稳定的时间</p>\n</li>\n</ol>\n<h2 id=\"使用网络寻址进行路由\"><a class=\"anchor\" href=\"#使用网络寻址进行路由\">#</a> 使用网络寻址进行路由</h2>\n<ol>\n<li>\n<p>路由器通常使用两个基本功能（路径确定功能和交换功能）将数据包从一条数据链路中继（relay）到另一条数据链路。</p>\n<ol start=\"2\">\n<li>\n<p><strong>交换功能（switching function）<strong>允许路由器在一个接口上</strong>接受数据包</strong>并<strong>通过第二个接口转发。</strong></p>\n</li>\n<li>\n<p><strong>路径确定（path determination）<strong>功能使路由器能够选择</strong>最合适的接口</strong>来<strong>转发数据包</strong>。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>路由器使用地址的<strong>网络部分</strong>进行路径选择，以将数据包传递到下一个路由器</p>\n</li>\n<li>\n<p>地址的 ** 节点部分（主机部分）** 由直接连接到目标网络的路由器使用，以将数据包传递到正确的主机。</p>\n</li>\n</ol>\n<ul>\n<li>\n<p><strong>路由器如何使用网络部分和节点部分</strong></p>\n<ol>\n<li>\n<p><strong>网络部分</strong></p>\n<ul>\n<li>\n<p>路由器使用网络部分决定数据包下一跳的路径。</p>\n</li>\n<li>\n<p>例如，路由器看到目标 IP 是  <code>192.168.2.10</code> ，而根据路由表知道  <code>192.168.2.0/24</code>  应该转发到接口  <code>GigabitEthernet0/1</code> ，因此数据包被发送到该接口。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>节点部分</strong></p>\n<ul>\n<li>\n<p>当数据包到达目标网络（如  <code>192.168.2.0/24</code> ）时，目标路由器使用节点部分（如  <code>10</code> ）确定具体设备。</p>\n</li>\n<li>\n<p>这一阶段通常由 ARP 协议解析 MAC 地址，并通过交换机转发到目标主机。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"静态和动态路由\"><a class=\"anchor\" href=\"#静态和动态路由\">#</a> 静态和动态路由</h2>\n<h3 id=\"静态路由\"><a class=\"anchor\" href=\"#静态路由\">#</a> 静态路由</h3>\n<p><img data-src=\"/image/CN7/image%203.png\" alt=\"image.png\" /></p>\n<ol>\n<li>\n<p>目的地址 network：后面需要包含掩码</p>\n</li>\n<li>\n<p>下一条地址 address：确定下一跳地址</p>\n</li>\n<li>\n<p>Distance：管理距离（可选项。不写的话，默认为 1）</p>\n</li>\n</ol>\n<p>例：</p>\n<p><code>ip route 172.16.3.0 255.255.255.0 192.168.2.4</code></p>\n<p>这个命令定义了一条从当前路由器到 <strong>172.16.3.0/24</strong> 网络的静态路由，具体通过下一跳地址 <strong>192.168.2.4</strong> 转发数据包。</p>\n<p>即如果收到目的地址为 172.16.3.0/24 **** 的报文，将其转发给 192.168.2.4</p>\n<h4 id=\"管理距离\"><a class=\"anchor\" href=\"#管理距离\">#</a> 管理距离</h4>\n<p>** 管理距离（administrative distance，AD）** 是路由信息源的可信赖性的等级，表示为从 0 到 255 的数值。</p>\n<p>静态路由的管理距离通常很短（默认值为 1）</p>\n<p>数值越低，可信度越高。AD 为 1 时其优先级非常高，仅次于直连网段 AD=0</p>\n<h2 id=\"动态路由\"><a class=\"anchor\" href=\"#动态路由\">#</a> 动态路由</h2>\n<p>动态路由取决于两个基本路由器功能：</p>\n<ol>\n<li>\n<p>维护（maintance）路由表（动态维持的）</p>\n</li>\n<li>\n<p>向其他路由器分发（distribution）路由信息</p>\n</li>\n</ol>\n<h3 id=\"动态路由协议分类\"><a class=\"anchor\" href=\"#动态路由协议分类\">#</a> 动态路由协议分类</h3>\n<ol>\n<li>\n<p>大致分为以下三类：</p>\n<ol start=\"2\">\n<li>\n<p>距离矢量（DV,Distance Vector）DVP Protocol</p>\n</li>\n<li>\n<p>链路状态（LS,Link State）LSP</p>\n</li>\n<li>\n<p>混合路由（HR,Hybird Routing）</p>\n</li>\n</ol>\n</li>\n<li>\n<p>其中 Hybrid Routing 是在两种之间</p>\n</li>\n</ol>\n<h3 id=\"dvp-距离矢量协议\"><a class=\"anchor\" href=\"#dvp-距离矢量协议\">#</a> DVP 距离矢量协议</h3>\n<p>路由器不知道整个网路的具体拓扑</p>\n<p>基于距离矢量的路由算法（也称为 <strong>Bellman-Ford 算法</strong>）在路由器之间传递路由表的周期性副本。</p>\n<ol>\n<li>\n<p>大家交换 Routing Table</p>\n</li>\n<li>\n<p>只知道可达，但是不知道怎么可达（知道 where, 但是不知道 how），不知道整个网路的具体拓扑</p>\n</li>\n</ol>\n<h4 id=\"路由环路问题-routing-loops\"><a class=\"anchor\" href=\"#路由环路问题-routing-loops\">#</a> 路由环路问题 Routing Loops</h4>\n<p>路由环路会导致数据包在网络中不断循环，无法到达目的地，从而浪费网络资源和带宽，甚至引起网络崩溃。</p>\n<p>解决方法：</p>\n<ol>\n<li>\n<p><strong>定义最大值（Maximum）</strong></p>\n<p>设置最大跳数</p>\n</li>\n<li>\n<p><strong>路由中毒（Route Poisoning）</strong></p>\n<p><img data-src=\"/image/CN7/image%204.png\" alt=\"image.png\" /></p>\n<p>当网络 5 发生故障时，路由器 E 通过将网络 5 的表条目设置为<strong> 16（无穷大） 或不可访问</strong>来启动路由中毒。（而不是删除条目）</p>\n<p>当路由器 C 从路由器 E 接收到路由中毒时，它会将更新（称为毒性逆转，poison reverse）发送回路由器 E。这确保网段上的所有路由器都已接收到中毒的路由信息。</p>\n<p>最终所有的路由器都知道不可达。</p>\n<p>一句话概括：路由毒害，由信息在路由表中失效的时候，把该表项的的度量值（metric）设为无穷大 16。</p>\n</li>\n<li>\n<p><strong>水平分隔（Split Horizon）</strong></p>\n<p>从某个端口收到的报文信息，不能再从该端口发送回去</p>\n</li>\n<li>\n<p><strong>计时器（Hold-Down Timers）</strong></p>\n<p><strong>启动计时器</strong>：当目标网络被标记为 “不可达” 时，路由器会启动一个计时器。</p>\n<p><strong>等待更优路径</strong>：在计时器运行期间，如果路由器收到新的、更优的路径信息，会更新记录。</p>\n<p><strong>忽略更差路径</strong>：如果收到的路径信息不如现有记录好，则忽略。</p>\n<p><strong>超时删除记录</strong>：如果计时器倒计时结束且没有新的有效路径信息，路由器会删除该条目。</p>\n</li>\n</ol>\n<h3 id=\"阻止发送路由更新\"><a class=\"anchor\" href=\"#阻止发送路由更新\">#</a> 阻止发送路由更新</h3>\n<p>防止接口发出任何路由更新信息：</p>\n<p><code>Router（config-router）#Passive-interface f0/0</code></p>\n<p><strong>接口接受路由表的更新，但是不发送报文出去</strong></p>\n<h2 id=\"lsp-链接状态协议\"><a class=\"anchor\" href=\"#lsp-链接状态协议\">#</a> LSP 链接状态协议</h2>\n<p>基于链接状态的路由算法也称为 <strong>SPF（shortest path first，最短路径优先）算法</strong>，维护复杂的拓扑信息数据库：对树处理路由表，没有环路问题</p>\n<p><strong>LSA（Link State Advertisement，链路状态通告）</strong></p>\n<h3 id=\"链接状态网络发现\"><a class=\"anchor\" href=\"#链接状态网络发现\">#</a> 链接状态网络发现</h3>\n<ol>\n<li>\n<p>路由器之间<strong>交换 LSA</strong>，每个路由器都以直接连接的网络开头</p>\n</li>\n<li>\n<p>每个路由器与其他路由器并行<strong>构建一个拓扑数据库</strong>，该拓扑数据库包含来自网络的所有 LSA。</p>\n</li>\n<li>\n<p><strong>SPF 算法计算网络可达性</strong>：路由器将此逻辑拓扑构建为一棵树，以其自身为根，由链路状态协议互联网络中每个网络的所有可能路径组成。然后，对这些路径进行最短路径优先（SPF）排序。</p>\n</li>\n<li>\n<p><strong>路由器在路由表中列出其最佳路径以及这些目标网络的端口</strong>。它还维护拓扑元素和状态详细信息的其他数据库。</p>\n</li>\n</ol>\n<h3 id=\"链接状态更新\"><a class=\"anchor\" href=\"#链接状态更新\">#</a> 链接状态更新</h3>\n<p>如果有一个链路的状态发生变化（恢复或者被破坏），必须将修改通知给全部路由器消耗代价比较大（SPF 算法）。</p>\n<h2 id=\"比较链接状态和距离矢量\"><a class=\"anchor\" href=\"#比较链接状态和距离矢量\">#</a> 比较：链接状态和距离矢量</h2>\n<ol>\n<li>\n<p>DV：距离矢量</p>\n<ol start=\"2\">\n<li>\n<p>视野窄，代价小</p>\n</li>\n<li>\n<p>基于跳数</p>\n</li>\n<li>\n<p>定期交换路由表，收敛慢</p>\n</li>\n<li>\n<p>交换路由表</p>\n</li>\n</ol>\n</li>\n<li>\n<p>LS：链路状态</p>\n<ol start=\"7\">\n<li>\n<p>视野宽，有一定代价</p>\n</li>\n<li>\n<p>基于带宽</p>\n</li>\n<li>\n<p>初期充分交换，收敛快</p>\n</li>\n<li>\n<p>交换 Linked State 的数据库</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"混合协议\"><a class=\"anchor\" href=\"#混合协议\">#</a> 混合协议</h2>\n<p>示例：</p>\n<ol>\n<li>\n<p>OSI’s IS-IS（Intermediate System-to-Intermediate System）</p>\n</li>\n<li>\n<p>Cisco’s EIGRP（Enhanced Interior Gateway Routing Protocol）</p>\n</li>\n</ol>\n<h2 id=\"主动路由协议-routing-protocol\"><a class=\"anchor\" href=\"#主动路由协议-routing-protocol\">#</a> 主动路由协议 Routing Protocol</h2>\n<p>主动路由协议的示例包括：</p>\n<table>\n<thead>\n<tr>\n<th>英文缩写</th>\n<th>英文解释</th>\n<th>中文解释</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RIP</td>\n<td>a distance-vector routing protocol</td>\n<td>距离矢量协议</td>\n<td>DV</td>\n</tr>\n<tr>\n<td>IGRP</td>\n<td>Cisco’s distance-vector routing protocol IGRP</td>\n<td>思科的距离矢量路由协议</td>\n<td>DV，基本启用</td>\n</tr>\n<tr>\n<td>OSPF</td>\n<td>Open Shortest Path First</td>\n<td>开放式最短路径优先</td>\n<td>LSP</td>\n</tr>\n<tr>\n<td>EIGRP</td>\n<td>-</td>\n<td>平衡的混合路由协议</td>\n<td>杂合</td>\n</tr>\n</tbody>\n</table>\n<p>工作在第三层</p>\n<h2 id=\"路由协议的主要目标\"><a class=\"anchor\" href=\"#路由协议的主要目标\">#</a> 路由协议的主要目标</h2>\n<ol>\n<li>\n<p>最佳路线（<strong>Optimal Route</strong>）：选择最佳路线</p>\n</li>\n<li>\n<p>效率（<strong>Efficiency</strong>）：最少使用带宽和路由器处理器资源</p>\n</li>\n<li>\n<p>快速收敛（<strong>Rapid Convergence</strong>）：越快越好。有些比其他人收敛更快。</p>\n</li>\n<li>\n<p>灵活性（<strong>Flexibility</strong>）：可以处理各种情况，例如高使用率和失败的路由</p>\n</li>\n</ol>\n<h2 id=\"如何启用动态路由协议\"><a class=\"anchor\" href=\"#如何启用动态路由协议\">#</a> 如何启用动态路由协议</h2>\n<p><code>Router(config)#router [protocol]</code>  ， <code>[protocol</code>  填 <code>rip</code> ， <code>ospf</code>  等</p>\n<p><code>Router(config)#network [network-number]</code> ， <code>network-number</code>  填直连网络号</p>\n<h2 id=\"定义默认路由\"><a class=\"anchor\" href=\"#定义默认路由\">#</a> 定义默认路由</h2>\n<p>如果路由表中没有目标网络的条目，则将数据包发送到默认网络。</p>\n<ul>\n<li>\n<p>使用动态路由协议定义默认路由： <code>Router(config)# ip default-network [network-number]</code></p>\n</li>\n<li>\n<p>将默认路由定义为静态路由： <code>Router（config）## ip route 0.0.0.0 0.0.0.0 [next-hop-ipaddress| exit-interface]</code></p>\n</li>\n</ul>\n<p>配置默认路由后，使用 show ip route 将显示：（172.16.1.2 是默认的下一跳地址）</p>\n<ol>\n<li>\n<p>不得已的网关是到网络 0.0.0.0 的 172.16.1.2</p>\n</li>\n<li>\n<p>所有不知道转发给谁的都给 172.16.1.2</p>\n</li>\n</ol>\n<ul>\n<li>\n<p><strong>解释</strong></p>\n<p>在  <code>ip route 0.0.0.0 0.0.0.0 &lt;next-hop-ip&gt;</code>  这条配置中，<strong>默认路由</strong>是指  <code>0.0.0.0 0.0.0.0</code>  这一部分。</p>\n<ul>\n<li>\n<p><strong> <code>0.0.0.0</code> </strong> 表示网络号，匹配所有的目标地址。</p>\n</li>\n<li>\n<p><strong> <code>0.0.0.0</code> </strong> 表示子网掩码，匹配所有网络范围。</p>\n</li>\n</ul>\n<p><strong>作用</strong>：<br />\n当路由器接收到一个数据包且无法在路由表中找到更具体的匹配时，就会使用这条默认路由，并将数据包转发给  <code>&lt;next-hop-ip&gt;</code> （下一跳地址）。</p>\n<p><strong>默认路由指向的下一跳地址</strong>（ <code>&lt;next-hop-ip&gt;</code> ）通常是出口网关，比如通向互联网的上级路由器。</p>\n</li>\n</ul>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "互联网计算",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/CN6/",
            "url": "https://erinwithbmq.github.io/2025/01/11/CN6/",
            "title": "计网第六章 会话、表示、应用层",
            "date_published": "2025-01-11T10:39:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>互联网计算系列整理主要内容来自软院 2020 级学长<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=\"> EagleBear2002 的博客</span>，为博主本人阅读后提炼整理的内容。<br />\n内容不算全面，仅推荐大家复习时参考。</p>\n</div>\n<p>前两层略</p>\n<h1 id=\"第七层应用层\"><a class=\"anchor\" href=\"#第七层应用层\">#</a> 第七层：应用层</h1>\n<p><img data-src=\"/image/CN6/image.png\" alt=\"image.png\" /></p>\n<p>上图中各层的一些协议和使用：会话层对端口进行管理</p>\n<p>第七层对应了应用界面，第六层对应了各种协议</p>\n<p>Telnet 端口不是 23 吗？</p>\n<h2 id=\"超文本传输协议\"><a class=\"anchor\" href=\"#超文本传输协议\">#</a> 超文本传输协议</h2>\n<h3 id=\"统一资源定位符-url\"><a class=\"anchor\" href=\"#统一资源定位符-url\">#</a> 统一资源定位符 URL</h3>\n<p><strong>统一资源定位符 URL</strong> 是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。</p>\n<p>格式： <code>&lt;URL 的访问方式&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;</code></p>\n<ol>\n<li>\n<p>访问方式：协议 HTTPS 或者 HTTP</p>\n</li>\n<li>\n<p>主机：域名的方式</p>\n</li>\n<li>\n<p>端口对应进程</p>\n</li>\n<li>\n<p>路径对应具体的文件</p>\n</li>\n</ol>\n<h3 id=\"http\"><a class=\"anchor\" href=\"#http\">#</a> HTTP</h3>\n<p>HTTP 1.0 协议是<strong>无状态</strong>的（stateless）</p>\n<p>HTTP 协议本身也是<strong>无连接</strong>的，虽然它使用了面向连接的 TCP 向上提供的服务。</p>\n<h3 id=\"http-的请求报文结构\"><a class=\"anchor\" href=\"#http-的请求报文结构\">#</a> HTTP 的请求报文结构</h3>\n<p><img data-src=\"/image/CN6/image%201.png\" alt=\"image.png\" /></p>\n<ol>\n<li>\n<p>报文由三个部分组成，即开始行、首部行和实体主体。</p>\n</li>\n<li>\n<p>在请求报文中，开始行就是请求行。</p>\n</li>\n<li>\n<p>请求报文和应答报文的应答结构都是一样的</p>\n</li>\n<li>\n<p>应答码：</p>\n<ol start=\"5\">\n<li>\n<p>2xx：成功</p>\n</li>\n<li>\n<p>3xx：<strong>重定向</strong></p>\n</li>\n<li>\n<p>4xx：错误</p>\n</li>\n<li>\n<p>5xx：<strong>服务器内部</strong>错误，而不是客户端请求的错误</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"html\"><a class=\"anchor\" href=\"#html\">#</a> HTML</h2>\n<p><strong>HTML（HyperText Markup Language，超文本标记语言）</strong>。略。</p>\n<h2 id=\"ftp-和-tftp\"><a class=\"anchor\" href=\"#ftp-和-tftp\">#</a> FTP 和 TFTP</h2>\n<p><strong>FTP （File Transfer Protocol）文件传输协议</strong></p>\n<p><strong>TFTP （Trivial File Transfer Protocol）简单文件传输协议</strong></p>\n<ol>\n<li>\n<p>FTP 是一种可靠的，<strong>面向连接</strong>的服务，它使用 <strong>TCP</strong> 传输文件。</p>\n<ol start=\"2\">\n<li>\n<p>FTP 首先在客户端和服务器 **（端口 21）<strong>之间建立</strong>控制连接 **</p>\n</li>\n<li>\n<p>然后，建立第二个连接，这是计算机之间通过其传输数据的链接。<strong>（端口 20）</strong></p>\n</li>\n</ol>\n</li>\n<li>\n<p>TFTP 是使用 <strong>UDP</strong> 的<strong>无连接</strong>服务（简化的 FTP）</p>\n<ol start=\"5\">\n<li>\n<p>体积小，易于实施。更加方便</p>\n</li>\n<li>\n<p>例如。 TFTP 在路由器上用于传输配置文件和 Cisco IOS 映像</p>\n</li>\n<li>\n<p>不支持交互，没有目录浏览功能</p>\n</li>\n<li>\n<p>使用<strong>端口 69</strong></p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"telnet-协议\"><a class=\"anchor\" href=\"#telnet-协议\">#</a> Telnet 协议</h2>\n<p>端口 23。用于远程连接主机。但是早不用这个了啊大家不都用 ssh 了吗。</p>\n<h2 id=\"smtp-和-pop\"><a class=\"anchor\" href=\"#smtp-和-pop\">#</a> SMTP 和 POP</h2>\n<p>电子邮件服务器使用 SMTP 发送和 POP 接收邮件相互通信。</p>\n<ol>\n<li>\n<p>**SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）** 邮件发送，登录发送等操作。端口号 25（也有其他端口）</p>\n</li>\n<li>\n<p><strong>POP3（Post Office Protocol version 3，邮局协议版本 3）</strong> 邮件接收，邮件到达邮件服务端，由客户端和服务端联系接收邮件。端口 110</p>\n</li>\n</ol>\n<p>发送者先登录到服务器，通过服务器根据 SMTP 传输到对应的服务器，然后用户登录后通过 POP3 协议收邮件到本地。</p>\n<h3 id=\"mime\"><a class=\"anchor\" href=\"#mime\">#</a> MIME</h3>\n<p>**MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展）** 是一种互联网标准，用于扩展电子邮件协议，使其能够支持文本之外的多种类型的数据，包括图片、音频、视频、应用程序文件等。</p>\n<p>MIME 增加 5 个新的邮件首部：</p>\n<ul>\n<li>\n<p>MIME-Version 版本</p>\n</li>\n<li>\n<p>Content-Description 说明邮件主体是否是图像、音频或视频</p>\n</li>\n<li>\n<p>Content-Id ：唯一标识符</p>\n</li>\n<li>\n<p>Content-Transfer-Encoding 主体编码方式</p>\n</li>\n<li>\n<p>Content-Type 主体的数据类型和子类型</p>\n</li>\n</ul>\n<h4 id=\"与smtp的关系\"><a class=\"anchor\" href=\"#与smtp的关系\">#</a> 与 SMTP 的关系</h4>\n<ol>\n<li>\n<p>SMTP 是传输协议，MIME 是数据格式标准。</p>\n<p>SMTP 定义了邮件<strong>如何传输</strong>。</p>\n<p>MIME 定义了邮件<strong>传输什么内容</strong>以及<strong>内容的格式</strong>。</p>\n</li>\n<li>\n<p>MIME 解决了 SMTP 的局限性，很多的文件（附件）并不是 ASCII 码的，我们需要用 MIME 将对应的文件进行转换。（因为 SMTP 只支持 7 位 ASCII 文本数据）</p>\n</li>\n</ol>\n<h2 id=\"snmp-简单网络管理协议\"><a class=\"anchor\" href=\"#snmp-简单网络管理协议\">#</a> SNMP 简单网络管理协议</h2>\n<p>端口 161/162</p>\n<p><strong>161</strong>：用于管理端向代理端发送请求</p>\n<p><strong>162</strong>：用于代理端向管理端发送告警（Trap）</p>\n<p>**SNMP（Simple Network Management Protocol，简单网络管理协议）** 是一种应用程序层协议，可简化网络设备之间的管理信息交换。</p>\n<p>SNMP 的通信基于 UDP 协议 通过广播进行实现</p>\n<h2 id=\"dns-域名系统\"><a class=\"anchor\" href=\"#dns-域名系统\">#</a> DNS 域名系统</h2>\n<p>** 域名系统（Domain Name System，DNS）** 是网络上的服务，该服务管理域名并响应客户端将域名转换为关联 IP 地址的请求。</p>\n<p>端口 53</p>\n<h3 id=\"结合域名服务器查找-ip-地址\"><a class=\"anchor\" href=\"#结合域名服务器查找-ip-地址\">#</a> 结合域名服务器查找 IP 地址</h3>\n<p>DNS 系统以层次（hierarchy）结构设置，该层次结构创建不同级别的 DNS 服务器。</p>\n<p>此级别的 DNS 服务器判断其自身是否能够将域名转换为关联的 IP 地址：</p>\n<ol>\n<li>\n<p>如果可以，则将结果返回给客户端</p>\n</li>\n<li>\n<p>如果没有，它将请求发送到更高级别。（向上级请求）</p>\n</li>\n</ol>\n<p><img data-src=\"/image/CN6/image-20230716093300053.png\" alt=\"https://eaglebear2002.github.io/61317/image-20230716093300053.png\" /></p>\n<h2 id=\"应用层沟通的方式\"><a class=\"anchor\" href=\"#应用层沟通的方式\">#</a> 应用层：沟通的方式</h2>\n<ol>\n<li>\n<p>无上下文，请求后就断开：如打开浏览器，连接到默认页面，并且该页面的文件将传输到客户端。处理完成后，连接断开。</p>\n</li>\n<li>\n<p>有上下文：如 Telnet，FTP，建立与服务器的连接并保持该连接，直到执行所有处理</p>\n</li>\n</ol>\n<h2 id=\"动态主机配置协议-dhcp\"><a class=\"anchor\" href=\"#动态主机配置协议-dhcp\">#</a> 动态主机配置协议 DHCP</h2>\n<p><strong>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）</strong></p>\n<p>是一种网络管理协议，用于自动分配 IP 地址和其他网络参数（如子网掩码、默认网关、DNS 服务器）给网络中的设备。</p>\n<h3 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h3>\n<p>接到因特网的计算机的协议软件需要配置的项目包括：</p>\n<ol>\n<li>\n<p>IP 地址</p>\n</li>\n<li>\n<p>子网掩码</p>\n</li>\n<li>\n<p>默认路由器的 IP 地址</p>\n</li>\n<li>\n<p>域名服务器的 IP 地址</p>\n</li>\n</ol>\n<p>DHCP 可以高效地分配 IP 地址。是局域网的网络协议，使用 <strong>UDP</strong> 来实现。</p>\n<p>目前一般都是自动获取 IP 地址，而不需要手动去获取 IP 地址等信息。</p>\n<p>服务器端口：67</p>\n<p>客户端端口：68</p>\n<h3 id=\"过程\"><a class=\"anchor\" href=\"#过程\">#</a> 过程</h3>\n<h4 id=\"发现\"><a class=\"anchor\" href=\"#发现\">#</a> 发现</h4>\n<p><img data-src=\"/image/CN6/image%202.png\" alt=\"image.png\" /></p>\n<p>广播</p>\n<h4 id=\"响应\"><a class=\"anchor\" href=\"#响应\">#</a> 响应</h4>\n<p><img data-src=\"/image/CN6/image%203.png\" alt=\"image.png\" /></p>\n<h4 id=\"选择\"><a class=\"anchor\" href=\"#选择\">#</a> 选择</h4>\n<p><img data-src=\"/image/CN6/image%204.png\" alt=\"image.png\" /></p>\n<p>DHCP Client 选择一个 DHCP Offer 报文（一般选择最先收到的 DHCP Offer 报文），向网络发送一个 DHCP Request <strong>广播</strong>数据包，<strong>所有的 Server 进行同步</strong></p>\n<h4 id=\"租约确认\"><a class=\"anchor\" href=\"#租约确认\">#</a> 租约确认</h4>\n<p><img data-src=\"/image/CN6/image%205.png\" alt=\"image.png\" /></p>\n<p>广播</p>\n<h4 id=\"租期续约\"><a class=\"anchor\" href=\"#租期续约\">#</a> 租期续约</h4>\n<p>在租期中，DHCP Client 直接向为其提供 IP 地址的 DHCP Server 发送 DHCP Request 消息，收到回应的 DHCP ACK 消息后，DHCP Client 根据所提供的新的租期以及其它更新的 TCP/IP 参数更新自己的配置，IP 租用更新完成</p>\n<h4 id=\"租期释放\"><a class=\"anchor\" href=\"#租期释放\">#</a> 租期释放</h4>\n<ul>\n<li>\n<p>当 DHCP Client 不再需要使用分配 IP 地址时，就会主动向 DHCP Server 发送 Release 报文，告知不再需要分配 IP 地址，DHCP Server 会释放被绑定的租约</p>\n</li>\n<li>\n<p>到时间后，Server 会主动询问，如果没有应答会自动释放</p>\n</li>\n</ul>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "互联网计算",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/CN5/",
            "url": "https://erinwithbmq.github.io/2025/01/11/CN5/",
            "title": "计网第五章 传输层",
            "date_published": "2025-01-11T10:35:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>互联网计算系列整理主要内容来自软院 2020 级学长<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=\"> EagleBear2002 的博客</span>，为博主本人阅读后提炼整理的内容。<br />\n内容不算全面，仅推荐大家复习时参考。</p>\n</div>\n<h1 id=\"第四层综述\"><a class=\"anchor\" href=\"#第四层综述\">#</a> 第四层综述</h1>\n<ol>\n<li>\n<p>分割上层应用程序数据。<strong>第四层只会在终端设备上有，在中间设备没有</strong></p>\n</li>\n<li>\n<p>建立端到端（end to end）的运营</p>\n</li>\n<li>\n<p>完成可靠性检验与流量控制</p>\n</li>\n</ol>\n<p>两个协议：</p>\n<ol>\n<li>\n<p><strong>传输控制协议（TCP，Transmission Control Protocol）</strong>，是可靠传输</p>\n<ul>\n<li>\n<p>** 面向连接，** 使用确认机制，提供流量控制</p>\n</li>\n<li>\n<p>重新发送丢失或错误的任何内容</p>\n</li>\n</ul>\n</li>\n<li>\n<p>** 用户数据报协议（UDP，User Datagram Protocol）** 将传出邮件分成多个部分，在目标站重新组合消息</p>\n<ul>\n<li>\n<p>无连接，<strong>不使用确认</strong>，不进行流量控制</p>\n</li>\n<li>\n<p>直接丢弃错误的报文，而不进行其他操作</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"服务模型\"><a class=\"anchor\" href=\"#服务模型\">#</a> 服务模型</h2>\n<p>TCP 和 UDP 都使用<strong>端口</strong>来跟踪（track）同时穿越网络的<strong>不同会话（即不同进程）</strong></p>\n<h4 id=\"端口分配规范\"><a class=\"anchor\" href=\"#端口分配规范\">#</a> 端口分配规范</h4>\n<p><img data-src=\"/image/CN5/4ae4e030e249781079e524d5ae98dbcd.png\" alt=\"4ae4e030e249781079e524d5ae98dbcd.png\" /></p>\n<p>0~65535 端口</p>\n<ol>\n<li>\n<p>** 低于 255 的端口号（0-255）** 保留给 TCP 和 UDP 公共应用程序使用（端口号 0-255 是 public 的，不可以随意分给其他的进程，如果分发则不符合规范）</p>\n</li>\n<li>\n<p><strong>0-1023</strong> 是熟知端口，有分发的规范，不应当被随意使用</p>\n</li>\n<li>\n<p><strong>1024-49151</strong> 的端口号进行登记使用，有的是应用程序已经的使用端口号，避免冲突</p>\n</li>\n<li>\n<p><strong>49152-65535</strong> 即为短暂端口号，用于和远端通信</p>\n</li>\n<li>\n<p>基于端口号的不同，进行不同的包的分发</p>\n</li>\n</ol>\n<ul>\n<li><strong>常见端口</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>端口号</th>\n<th>服务名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td><strong>Reserved</strong></td>\n<td>保留端口，未指定服务</td>\n</tr>\n<tr>\n<td>20</td>\n<td><strong>FTP Data</strong></td>\n<td>FTP 数据传输端口</td>\n</tr>\n<tr>\n<td>21</td>\n<td><strong>FTP Control</strong></td>\n<td>FTP 控制端口</td>\n</tr>\n<tr>\n<td>22</td>\n<td><strong>SSH</strong></td>\n<td>安全 Shell，远程登录协议</td>\n</tr>\n<tr>\n<td>23</td>\n<td><strong>Telnet</strong></td>\n<td>Telnet，远程登录协议</td>\n</tr>\n<tr>\n<td>25</td>\n<td><strong>SMTP</strong></td>\n<td>简单邮件传输协议（邮件发送）</td>\n</tr>\n<tr>\n<td>53</td>\n<td><strong>DNS</strong></td>\n<td>域名系统（DNS）</td>\n</tr>\n<tr>\n<td>67</td>\n<td><strong>DHCP Server</strong></td>\n<td>动态主机配置协议（DHCP）服务器端口</td>\n</tr>\n<tr>\n<td>68</td>\n<td><strong>DHCP Client</strong></td>\n<td>DHCP 客户端端口</td>\n</tr>\n<tr>\n<td>69</td>\n<td><strong>TFTP</strong></td>\n<td>简单文件传输协议（Trivial FTP）</td>\n</tr>\n<tr>\n<td>80</td>\n<td><strong>HTTP</strong></td>\n<td>超文本传输协议（Web 服务）</td>\n</tr>\n<tr>\n<td>110</td>\n<td><strong>POP3</strong></td>\n<td>邮局协议版本 3（邮件接收）</td>\n</tr>\n<tr>\n<td>119</td>\n<td><strong>NNTP</strong></td>\n<td>网络新闻传输协议（网络新闻）</td>\n</tr>\n<tr>\n<td>123</td>\n<td><strong>NTP</strong></td>\n<td>网络时间协议（时间同步）</td>\n</tr>\n<tr>\n<td>143</td>\n<td><strong>IMAP</strong></td>\n<td>Internet 邮件访问协议（邮件接收）</td>\n</tr>\n<tr>\n<td>161</td>\n<td><strong>SNMP</strong></td>\n<td>简单网络管理协议（设备管理）</td>\n</tr>\n<tr>\n<td>194</td>\n<td><strong>IRC</strong></td>\n<td>Internet Relay Chat（聊天协议）</td>\n</tr>\n<tr>\n<td>443</td>\n<td><strong>HTTPS</strong></td>\n<td>安全的 HTTP（加密的 Web 服务）</td>\n</tr>\n<tr>\n<td>445</td>\n<td><strong>Microsoft-DS</strong></td>\n<td>微软目录服务（Windows 文件共享）</td>\n</tr>\n<tr>\n<td>514</td>\n<td><strong>Syslog</strong></td>\n<td>系统日志协议</td>\n</tr>\n<tr>\n<td>520</td>\n<td colspan=\"2\"><strong>RIP</strong></td>\n</tr>\n<tr>\n<td>587</td>\n<td><strong>SMTP (Secure)</strong></td>\n<td>加密的 SMTP（邮件发送）</td>\n</tr>\n<tr>\n<td>631</td>\n<td><strong>CUPS</strong></td>\n<td>公共打印系统（打印服务）</td>\n</tr>\n<tr>\n<td>993</td>\n<td><strong>IMAPS</strong></td>\n<td>加密的 IMAP（邮件接收）</td>\n</tr>\n<tr>\n<td>995</td>\n<td><strong>POP3S</strong></td>\n<td>加密的 POP3（邮件接收）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"socket-套接字\"><a class=\"anchor\" href=\"#socket-套接字\">#</a> Socket 套接字</h2>\n<p>**Socket（套接字）** 是网络通信的一个抽象概念，它是应用层和传输层之间的接口，用于实现网络数据通信。</p>\n<ol>\n<li>\n<p>套接字表示为 **（IP 地址，端口）**</p>\n</li>\n<li>\n<p>每个连接都表示为（<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><msub><mi>t</mi><mrow><mi>s</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>c</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">socket_{source}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">u</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal mtight\">c</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>e</mi><msub><mi>t</mi><mrow><mi>d</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">socket_{destination}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ），点对点全双工通道</p>\n</li>\n<li>\n<p>通讯被认为<strong>是以一个 socket 和另一个 socket 之间的连接</strong>（Socket API 是一套规范，根据上下文有不同的含义）</p>\n</li>\n<li>\n<p><strong>TCP 不支持多播和广播</strong></p>\n</li>\n</ol>\n<h1 id=\"传输控制协议-tcp\"><a class=\"anchor\" href=\"#传输控制协议-tcp\">#</a> 传输控制协议 TCP</h1>\n<p><strong>传输控制协议（TCP，Transmission Control Protocol）</strong></p>\n<ol>\n<li>\n<p>可靠传输</p>\n</li>\n<li>\n<p>流传输</p>\n<ol start=\"3\">\n<li>\n<p>流量控制：滑动窗口（窗口进行通信，一次数据传输是有上限发的，缓存问题，拥塞问题）</p>\n</li>\n<li>\n<p>避免拥塞</p>\n</li>\n</ol>\n</li>\n<li>\n<p>连接控制</p>\n<ol start=\"6\">\n<li>\n<p>建立连接：三次握手</p>\n</li>\n<li>\n<p>断开连接：四次握手</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"tcp-数据段格式\"><a class=\"anchor\" href=\"#tcp-数据段格式\">#</a> TCP 数据段格式</h2>\n<p><img data-src=\"/image/CN5/image.png\" alt=\"image.png\" /></p>\n<p>首部一行共计 4 字节，段首在前，固定首部长度为 20 字节</p>\n<h3 id=\"源端口和目的端口\"><a class=\"anchor\" href=\"#源端口和目的端口\">#</a> 源端口和目的端口</h3>\n<p>每个端口占用两字节（16bit, 0~2^16-1 端口）</p>\n<h3 id=\"序号-seq\"><a class=\"anchor\" href=\"#序号-seq\">#</a> 序号 seq</h3>\n<p>序号字段的值指本报文段<strong>所发送的数据的第一个字节的序号</strong></p>\n<h3 id=\"确认号-ack\"><a class=\"anchor\" href=\"#确认号-ack\">#</a> 确认号 ack</h3>\n<p>确认号字段：占 4 字节，是<strong>期望收到对方的下一个报文段的数据的第一个字节的序号</strong></p>\n<h3 id=\"urg\"><a class=\"anchor\" href=\"#urg\">#</a> URG</h3>\n<p>紧急 URG = 1 时，表明紧急指针字段有效。</p>\n<ol>\n<li>\n<p>告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）</p>\n</li>\n<li>\n<p>优先放紧急数据，URG = 0 的时候则为不紧急（Ctrl + Z）</p>\n</li>\n</ol>\n<h3 id=\"ack\"><a class=\"anchor\" href=\"#ack\">#</a> ACK</h3>\n<p>ACK = 1 时确认号字段有效；ACK = 0 时确认号字段无效</p>\n<h3 id=\"pshpush\"><a class=\"anchor\" href=\"#pshpush\">#</a> PSH（PuSH）</h3>\n<ol>\n<li>\n<p>接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付，此时将<strong>缓存所有部分</strong>都传输，而并不是只将这个报文段的信息进行传输。</p>\n</li>\n<li>\n<p>TCP 在正常条件下并不是立马传输的，首先要缓存满了才发送，其次还有就是要保证网络可信的时候才发送</p>\n</li>\n</ol>\n<h3 id=\"rst\"><a class=\"anchor\" href=\"#rst\">#</a> RST</h3>\n<ol>\n<li>\n<p>ReSeT = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接</p>\n</li>\n<li>\n<p>就是重新来过，如果请求方发送的请求，如果应答方不想连接则将 ReSet 置为 1</p>\n</li>\n</ol>\n<h3 id=\"syn\"><a class=\"anchor\" href=\"#syn\">#</a> SYN</h3>\n<p>同步 SYN = 1：表示这是一个连接请求或连接接受报文（<strong>初始的时候才出现）</strong></p>\n<h3 id=\"finfinish\"><a class=\"anchor\" href=\"#finfinish\">#</a> FIN（FINish）</h3>\n<p>用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。（发送方没有传输数据了）</p>\n<p>断开连接有四次握手。</p>\n<h2 id=\"tcp协议\"><a class=\"anchor\" href=\"#tcp协议\">#</a> TCP 协议</h2>\n<h3 id=\"建立可靠连接三次握手\"><a class=\"anchor\" href=\"#建立可靠连接三次握手\">#</a> 建立可靠连接（三次握手）</h3>\n<p><img data-src=\"/image/CN5/image%201.png\" alt=\"image.png\" /></p>\n<p><strong>图要记住，包括客户端和服务端的状态，传递的参数</strong></p>\n<p>图上的 x，y 都是随机数</p>\n<h3 id=\"释放连接四次挥手\"><a class=\"anchor\" href=\"#释放连接四次挥手\">#</a> 释放连接（四次挥手）</h3>\n<p><img data-src=\"/image/CN5/image%202.png\" alt=\"image.png\" /></p>\n<p><strong>图要记住，包括客户端和服务端的状态，传递的参数</strong></p>\n<p>图上的 u, v, w 都是随机数</p>\n<p><strong>在完全释放连接前，TIME-WAIT 等待 2 MSL</strong>（Maximum Segment Lifetime）<strong>，记住！</strong></p>\n<h4 id=\"为什么必须等待-2-msl\"><a class=\"anchor\" href=\"#为什么必须等待-2-msl\">#</a> 为什么必须等待 2 MSL</h4>\n<ol>\n<li>\n<p>为了确保 A 发送的最后一个 ACK 可以到达 B</p>\n</li>\n<li>\n<p>防止出现任何无效的连接请求段：等待 2 MSL 之后，我们可以确保连接上的所有段均已消失</p>\n</li>\n</ol>\n<h1 id=\"用户数据报协议-udp\"><a class=\"anchor\" href=\"#用户数据报协议-udp\">#</a> 用户数据报协议 UDP</h1>\n<p><strong>用户数据报协议（UDP，User Datagram Protocol）</strong></p>\n<ol>\n<li>\n<p><strong>没有建立连接</strong>（避免延时）</p>\n</li>\n<li>\n<p>简单：发送方，接收方无连接状态</p>\n</li>\n<li>\n<p>小段标题</p>\n</li>\n<li>\n<p><strong>没有拥塞控制</strong>：UDP 可以按照期望的速度传输</p>\n</li>\n<li>\n<p>UDP 用于：</p>\n<ol start=\"6\">\n<li>\n<p>RIP：定期发送路由信息（periodically）</p>\n</li>\n<li>\n<p>DNS：避免延迟建立 TCP 连接（DNS 需要快速找到）</p>\n</li>\n<li>\n<p>SNMP：拥塞时（congestion），SNMP 必须仍然可运行。在没有拥塞和可靠性控制机制的情况下，UDP 在这种情况下的性能要优于 TCP。（主播和多播，大量信息传输）</p>\n</li>\n<li>\n<p>其他协议包括 TFTP，DHCP</p>\n</li>\n</ol>\n</li>\n<li>\n<p>常用于 ** 流媒体（Stream）多媒体（multimedia）** 应用</p>\n<ol start=\"11\">\n<li>\n<p>容忍损失：无非就是降低帧率</p>\n</li>\n<li>\n<p>这类应用是<strong>速率敏感</strong>的应用，而不一定是质量敏感的应用。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"udp-数据帧格式\"><a class=\"anchor\" href=\"#udp-数据帧格式\">#</a> UDP 数据帧格式</h2>\n<p><img data-src=\"/image/CN5/image%203.png\" alt=\"image.png\" /></p>\n<ol>\n<li>\n<p>UDP 只有 8 个字节的首部，所以 UDP 报文最少是 8 个字节</p>\n</li>\n<li>\n<p>分别是 ** 源端口、目的端口、长度（包括 header 长度）、校验（data）、Data。** 前面的各占 16 位</p>\n</li>\n<li>\n<p>校验也要对 data 一并校验，如果出现错误，<strong>直接丢弃</strong>（TCP 会重新发送）</p>\n</li>\n<li>\n<p>UDP 直接发送应用层给的报文，不会再自己分片</p>\n</li>\n</ol>\n<h2 id=\"tcp-和-udp-的区别\"><a class=\"anchor\" href=\"#tcp-和-udp-的区别\">#</a> TCP 和 UDP 的区别</h2>\n<h3 id=\"tcp\"><a class=\"anchor\" href=\"#tcp\">#</a> TCP</h3>\n<ol>\n<li>\n<p>不是立即交给上层校验，而是需要先和对方沟通</p>\n</li>\n<li>\n<p>缓存满了才统一交付。</p>\n</li>\n</ol>\n<h3 id=\"udp\"><a class=\"anchor\" href=\"#udp\">#</a> UDP</h3>\n<ol>\n<li>\n<p><strong>直接转发报文</strong>，保留报文边界</p>\n</li>\n<li>\n<p>IP 进行划分</p>\n</li>\n<li>\n<p>应用程序会发送比较合适的 UDP 报文大小进行发送</p>\n</li>\n</ol>\n<h3 id=\"共同点\"><a class=\"anchor\" href=\"#共同点\">#</a> 共同点</h3>\n<ol>\n<li>校验是相同的。</li>\n</ol>\n<h1 id=\"应用nat与pat\"><a class=\"anchor\" href=\"#应用nat与pat\">#</a> 应用：NAT 与 PAT</h1>\n<p><strong>NAT（Network Address Translation）网络地址转换</strong></p>\n<p>NAT（Network Address Translation），是在 IP 数据包头中将一个地址交换为另一个地址的过程，是网络地址即将用完的解决方案之一</p>\n<p>通过路由器上的 NAT Table 双向转换。</p>\n<h2 id=\"nat的类型\"><a class=\"anchor\" href=\"#nat的类型\">#</a> NAT 的类型</h2>\n<ol>\n<li>\n<p>静态 NAT：固定的内部地址（internal address）到注册地址（registered address）的映射（一开始就写死）</p>\n</li>\n<li>\n<p>动态 NAT：映射以先到先得的方式动态进行（不是写死，配一个地址池，通过更新）</p>\n</li>\n<li>\n<p><strong>PAT（端口地址转换，Port address translation）</strong>：端口地址转换用于允许许多内部用户共享一个 “内部全局” 地址（基于 Socket 映射，而不是 IP 地址，多个内网主机映射到一个公网地址）</p>\n</li>\n</ol>\n<h2 id=\"nat-地址类型\"><a class=\"anchor\" href=\"#nat-地址类型\">#</a> NAT 地址类型</h2>\n<ol>\n<li>\n<p>Inside Local address（内部本地地址）：内网 IP 地址</p>\n</li>\n<li>\n<p>Inside Global address（内部全局地址）： 注册 IP 地址，对外部展示的内部地址</p>\n</li>\n<li>\n<p>Outside Global address（外部全局地址）：外部机器的地址</p>\n</li>\n</ol>\n<p><img data-src=\"/image/CN5/image%204.png\" alt=\"image.png\" /></p>\n<p>内部主机发送报文给网关，网关根据 NAT Table 进行翻译，转换成内部全局地址，然后进行转发</p>\n<p>静态 NAT：直接写好谁变成谁</p>\n<p>动态 NAT：</p>\n<p>比如分配一个公网地址池为： <code>203.0.113.1 - 203.0.113.5</code> 。内部设备（如 <strong>192.168.1.10</strong>）尝试与公网设备通信时，NAT 会检查其内部本地地址，从地址池中动态分配一个可用的公网地址（比如  <code>203.0.113.2</code> ），并建立一个临时映射。当通信会话结束或超时，NAT 会释放分配的公网 IP 地址（<strong>203.0.113.2</strong>），返回到地址池中供其他设备使用。</p>\n<h2 id=\"pat\"><a class=\"anchor\" href=\"#pat\">#</a> PAT</h2>\n<p>**PAT（端口地址转换，Port address translation），** 也称为 NAT Overload</p>\n<p>包含端口号的映射，动态分配</p>\n<p><img data-src=\"/image/CN5/image%205.png\" alt=\"image.png\" /></p>\n<p>如 <code>10.1.1.3:1723</code>  映射到 <code>198.168.2.2:1492</code> .</p>\n<h3 id=\"pat-与其他-nat-类型的对比\"><a class=\"anchor\" href=\"#pat-与其他-nat-类型的对比\">#</a> <strong>PAT 与其他 NAT 类型的对比</strong></h3>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>静态 NAT</strong></th>\n<th><strong>动态 NAT</strong></th>\n<th><strong>PAT（端口地址转换）</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>地址分配方式</strong></td>\n<td>固定的 1:1 映射</td>\n<td>动态从公网地址池分配</td>\n<td>共享公网地址，动态分配端口</td>\n</tr>\n<tr>\n<td><strong>公网 IP 使用效率</strong></td>\n<td>低</td>\n<td>较高</td>\n<td>最高</td>\n</tr>\n<tr>\n<td><strong>端口映射</strong></td>\n<td>无</td>\n<td>无</td>\n<td>利用端口号区分流量</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>需要固定公网 IP 的设备（如服务器）。</td>\n<td>内部设备访问公网，公网 IP 数量充足时。</td>\n<td>大量设备访问公网，公网 IP 地址稀缺时。</td>\n</tr>\n</tbody>\n</table>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "互联网计算",
                "复习资料"
            ]
        },
        {
            "id": "https://erinwithbmq.github.io/2025/01/11/CN4/",
            "url": "https://erinwithbmq.github.io/2025/01/11/CN4/",
            "title": "计网第四章 网络层",
            "date_published": "2025-01-11T09:59:00.000Z",
            "content_html": "<div class=\"note info\">\n<p>互联网计算系列整理主要内容来自软院 2020 级学长<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=\"> EagleBear2002 的博客</span>，为博主阅读后提炼整理的内容。<br />\n内容不算全面，仅推荐大家复习时参考。</p>\n</div>\n<h1 id=\"网络层概述\"><a class=\"anchor\" href=\"#网络层概述\">#</a> 网络层概述</h1>\n<p>MAC 地址不能跨网段，IP 地址可以跨网段</p>\n<p>第三层只能<strong>避免拥塞</strong>，但是要到第四层（运输层）才能完成流量控制 **（第三层不能完成流量控制）**</p>\n<p>第三层的基本传输单位是<strong> Packet 报文</strong></p>\n<h2 id=\"第三层职责\"><a class=\"anchor\" href=\"#第三层职责\">#</a> 第三层职责</h2>\n<ol>\n<li>\n<p>划分广播域</p>\n</li>\n<li>\n<p>分层寻址</p>\n</li>\n<li>\n<p>细分网络并控制流量（？</p>\n</li>\n<li>\n<p>减少交通拥堵</p>\n</li>\n<li>\n<p>与其他网络交谈</p>\n</li>\n<li>\n<p>跨介质的逻辑理解和接通</p>\n</li>\n<li>\n<p>只负责连通和传达，不保证数据可靠性</p>\n</li>\n</ol>\n<h2 id=\"设备\"><a class=\"anchor\" href=\"#设备\">#</a> 设备</h2>\n<h3 id=\"路由器\"><a class=\"anchor\" href=\"#路由器\">#</a> 路由器</h3>\n<ol>\n<li>\n<p>互连网段或网络（<strong>不同网段的分割</strong>）</p>\n</li>\n<li>\n<p>根据 IP 地址做出合理的决定</p>\n</li>\n<li>\n<p>根据路由表确定最佳路径</p>\n</li>\n<li>\n<p>将数据包从入站端口切换到出站端口</p>\n</li>\n<li>\n<p>当源网段与目标网段不同时路由器会进行转发，反之则不会</p>\n</li>\n</ol>\n<h1 id=\"ip-地址和子网划分\"><a class=\"anchor\" href=\"#ip-地址和子网划分\">#</a> IP 地址和子网划分</h1>\n<h2 id=\"ipv4-报文主要结构\"><a class=\"anchor\" href=\"#ipv4-报文主要结构\">#</a> IPv4 报文主要结构</h2>\n<p><img data-src=\"/image/CN4/image-20220625193653967.png\" alt=\"image-20220625193653967.png\" /></p>\n<h3 id=\"首部部分\"><a class=\"anchor\" href=\"#首部部分\">#</a> 首部部分</h3>\n<p>上面蓝框部分的整体是首部部分</p>\n<h3 id=\"首部长度\"><a class=\"anchor\" href=\"#首部长度\">#</a> 首部长度</h3>\n<p>占 4 bit，可表示的最大数值是 <strong>15 个单位（一个单位为 4 字节）</strong> 因此 IP 的<strong>首部长度的最大值是 60 字节</strong>。</p>\n<ol>\n<li>\n<p>因为首部长度是不确定的，所以我们需要进行标识。（用来方便读取）</p>\n</li>\n<li>\n<p>首部长度的 <strong>32bit 为一行</strong>，也就是 <strong>4 个字节为一个单位</strong></p>\n</li>\n<li>\n<p>所以 IP 报文<strong>首部字段长度最大为 15 行</strong></p>\n</li>\n</ol>\n<h3 id=\"总长度\"><a class=\"anchor\" href=\"#总长度\">#</a> 总长度</h3>\n<p>占 16 bit，指<strong>首部和数据</strong>之和的长度，单位为字节，因此<strong>数据报的最大长度为 65535 字节</strong>（由于放到帧里面，所以大多数不比 1500 字节长）</p>\n<p>好像不会考 IPv4 报文结构，后面略</p>\n<h2 id=\"网络层地址\"><a class=\"anchor\" href=\"#网络层地址\">#</a> 网络层地址</h2>\n<p>IPv4 地址为 <strong>32 位长</strong>，它们以点分十进制格式表示为四个八位字节</p>\n<p>两个组成部分：</p>\n<ol>\n<li>\n<p>网络 ID Network：标识网段</p>\n</li>\n<li>\n<p>主机 ID Host：设别该网段上的特定设备</p>\n</li>\n</ol>\n<h2 id=\"ip-地址\"><a class=\"anchor\" href=\"#ip-地址\">#</a> IP 地址</h2>\n<h3 id=\"分类\"><a class=\"anchor\" href=\"#分类\">#</a> 分类</h3>\n<p><img data-src=\"/image/CN4/image.png\" alt=\"image.png\" /></p>\n<p>主要通过<strong>第一个字节</strong>进行划分</p>\n<ol>\n<li>\n<p><strong>0-127</strong>（0xxxxxxx）A 类地址</p>\n</li>\n<li>\n<p><strong>128-191</strong>（10xxxxxx）B 类地址</p>\n</li>\n<li>\n<p><strong>192-223</strong>（110xxxxx）C 类地址</p>\n</li>\n<li>\n<p>224-239（1110xxxx）D 类地址：多播（multicast）：视频点播的原理也是组播（多播）</p>\n</li>\n<li>\n<p>240-255（1111xxxx）E 类地址：研究（Research）</p>\n</li>\n<li>\n<p>host 不能全取 0，也不能全取 1。<strong>全取 0 时用来标识网段地址；全取 1 时用来标识网段的广播地址</strong></p>\n</li>\n</ol>\n<h3 id=\"主机的数量\"><a class=\"anchor\" href=\"#主机的数量\">#</a> 主机的数量</h3>\n<p>每个类别的最大主机数量各不相同。（不包含网络号）</p>\n<ol>\n<li>\n<p>A 类拥有 16,777,214 个可用主机（224 - 2）</p>\n</li>\n<li>\n<p>B 类具有 65,534 个可用主机（216 - 2）</p>\n</li>\n<li>\n<p>C 类具有 254 个可用主机（28 -2）</p>\n</li>\n</ol>\n<p>减 2 是因为去掉网络地址和广播地址</p>\n<h3 id=\"保留reserved地址\"><a class=\"anchor\" href=\"#保留reserved地址\">#</a> 保留（Reserved）地址</h3>\n<ol>\n<li>\n<p>网络地址：在地址的<strong>主机部分中以二进制 0 结尾的 IP 地址</strong></p>\n<ol start=\"2\">\n<li>\n<p>A 类网络地址示例：113.0.0.0</p>\n</li>\n<li>\n<p>网络上的主机只有具有相同网络 ID 的其他主机才能直接通信。（用来确定是不是在一个网段里面）</p>\n</li>\n</ol>\n</li>\n<li>\n<p>广播地址：用于<strong>将数据发送到网络上的所有设备</strong>。（一般是<strong>一个网段之间</strong>的）</p>\n<ol start=\"5\">\n<li>\n<p>广播 IP 地址在地址的<strong>主机部分中以二进制 1 结尾</strong>。</p>\n</li>\n<li>\n<p>B 类地址的广播地址的示例：176.10.255.255（decimal 255 = binary 11111111）</p>\n</li>\n</ol>\n</li>\n<li>\n<p>私有地址（Private IP Address）是用于局域网内部的地址，不能在公网上直接路由。私有地址的范围如下：即 10, 192.168, 172.16~172.31</p>\n<ul>\n<li>\n<p><strong>10.0.0.0 到 10.255.255.255</strong>（10.0.0.0/8）</p>\n</li>\n<li>\n<p><strong>172.16.0.0 到 172.31.255.255</strong>（172.16.0.0/12）</p>\n</li>\n<li>\n<p><strong>192.168.0.0 到 192.168.255.255</strong>（192.168.0.0/16）</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"子网划分\"><a class=\"anchor\" href=\"#子网划分\">#</a> 子网划分</h2>\n<p>从 Host 中借位进行子网划分</p>\n<p><img data-src=\"/image/CN4/image%201.png\" alt=\"image.png\" /></p>\n<h3 id=\"基本概念\"><a class=\"anchor\" href=\"#基本概念\">#</a> 基本概念</h3>\n<p>子网减小了广播域，提供寻址灵活性</p>\n<blockquote>\n<p>第五版书和 6f 已经不知道用了多少年的 ppt：子网最少借用位数为 2，因为全 0 和全 1 不可用。当然现在用 CIDR 无所谓这个了。</p>\n</blockquote>\n<p>可以借用的最大位数可以是保留至少 2 位主机号的任何数字（给 Host 至少保留 2 位，因为 1 位的话，要么一个是 NET 无法使用，要么一个是广播地址）</p>\n<h3 id=\"子网划分的副产品地址浪费\"><a class=\"anchor\" href=\"#子网划分的副产品地址浪费\">#</a> 子网划分的副产品：地址浪费</h3>\n<p>我们必须在所需的子网数，每个子网可接受的主机以及地址的浪费之间取得平衡（strike a balance）。</p>\n<ol>\n<li>\n<p>hostID 里面的全 0 和全 1 不能使用</p>\n</li>\n<li>\n<p>subnet 不可以使用全 0 和全 1</p>\n</li>\n<li>\n<p><strong>借用 4 位</strong>是最高效率的，提升了划分灵活性，影响了效率</p>\n</li>\n</ol>\n<h3 id=\"子网掩码\"><a class=\"anchor\" href=\"#子网掩码\">#</a> 子网掩码</h3>\n<p>把网络位全赋值为 1，host 位全部赋值为 0，这样我们就明白哪些位上面是 net，哪些位上面是 host</p>\n<h3 id=\"计算子网\"><a class=\"anchor\" href=\"#计算子网\">#</a> 计算子网</h3>\n<p>首先确定：全 0 / 全 1 的子网和主机都不可用。</p>\n<p>如果你要划分 13 个子网，13+2=15，你需要借 4 位。</p>\n<p>借用后看主机个数是否满足要求。如果不满足要求可能还要划分多个子网给它</p>\n<p>子网的网络地址：将借用位改成对应的子网编号，后面主机位全 0.</p>\n<p>举例：将 C 类地址 192.168.1.0 划分出两个子网。</p>\n<p>借用 2 位，分别为 01/10</p>\n<p>00000000 → 01000000</p>\n<p>00000000 → 10000000</p>\n<p>所以两个子网地址为 192.168.1.64  1992.168.1.128</p>\n<h1 id=\"第三层设备\"><a class=\"anchor\" href=\"#第三层设备\">#</a> 第三层设备</h1>\n<h2 id=\"路由器发送过程\"><a class=\"anchor\" href=\"#路由器发送过程\">#</a> 路由器发送过程</h2>\n<p>从 A 网段发送到 B 网段，帧和报文发送到路由器，路由器理解报文后检查路由表，找到目的地对应端口，进行转发，形成了新的帧，其 mac 地址变成了 B 网段目标机器的 mac 地址。</p>\n<h2 id=\"路由器端口示例\"><a class=\"anchor\" href=\"#路由器端口示例\">#</a> 路由器端口示例</h2>\n<p>路由器端口记录了网段的 IP 地址（和连接的地方是相同的）</p>\n<ol>\n<li>\n<p>接口是路由器连接到网络的附件，在 IP 路由中也可以称为<strong>端口。</strong></p>\n</li>\n<li>\n<p>这个 IP 地址往往被作为这个<strong>网络的网关</strong></p>\n</li>\n<li>\n<p>每个接口必须具有一个<strong>单独的唯一网络地址</strong>。</p>\n<ol start=\"4\">\n<li>\n<p>比如上图中 S1 和 S2 不能是相同的 IP 地址</p>\n</li>\n<li>\n<p>路由器的<strong>连接的网段一定要是不同的</strong></p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"ip-地址分配\"><a class=\"anchor\" href=\"#ip-地址分配\">#</a> IP 地址分配</h2>\n<ul>\n<li>\n<p>静态地址分配</p>\n</li>\n<li>\n<p>动态地址分配</p>\n</li>\n</ul>\n<h1 id=\"arp-协议\"><a class=\"anchor\" href=\"#arp-协议\">#</a> ARP 协议</h1>\n<p><strong>Address Resolution Protocol 地址解析协议</strong></p>\n<p>ARP 使计算机能够查找与 IP 地址关联的计算机的 MAC 地址。</p>\n<p>将<strong>目的方 IP 地址 -&gt; 目的方 MAC 地址</strong></p>\n<h2 id=\"arp-的操作\"><a class=\"anchor\" href=\"#arp-的操作\">#</a> ARP 的操作</h2>\n<h3 id=\"arp-request\"><a class=\"anchor\" href=\"#arp-request\">#</a> ARP Request</h3>\n<p>源设备使用广播的方式发送一个 ARP 请求</p>\n<ol>\n<li>\n<p><strong>向目的方请求 MAC 地址</strong>，即 ARP 请求</p>\n</li>\n<li>\n<p>命令如图：就是找谁是这个主机，你的 MAC 地址是啥</p>\n</li>\n<li>\n<p>将 MAC 地址设置为全 1，作为<strong>广播发送</strong></p>\n</li>\n</ol>\n<h3 id=\"arp-checking\"><a class=\"anchor\" href=\"#arp-checking\">#</a> ARP Checking</h3>\n<p>接收到广播请求后：</p>\n<ol>\n<li>\n<p>若不是自己的 ip 地址，解析结束，但会记录下发送方的 MAC 地址</p>\n</li>\n<li>\n<p>若是自己的 ip 地址，则进行 ARP Reply，同时也会记下发送方的 MAC 地址</p>\n</li>\n</ol>\n<h3 id=\"arp-reply\"><a class=\"anchor\" href=\"#arp-reply\">#</a> ARP Reply</h3>\n<p>单播，给发送方返回自己的 MAC 地址</p>\n<h3 id=\"arp-caching\"><a class=\"anchor\" href=\"#arp-caching\">#</a> ARP Caching</h3>\n<p>发送方将对应条目写入 ARP Table 中</p>\n<p>然后再次形成一个数据帧发送出去即可</p>\n<p>ARP 请求是本网段形成的，是一个广播就可以。如果目的主机不在本网段中，<strong>那么不能跨网段进行广播</strong></p>\n<h2 id=\"网络交流\"><a class=\"anchor\" href=\"#网络交流\">#</a> 网络交流</h2>\n<p>如何与不在同一物理网段上的设备通信？</p>\n<ol>\n<li>\n<p>Default gateway 默认网关</p>\n</li>\n<li>\n<p>Proxy ARP 代理 ARP</p>\n</li>\n</ol>\n<h3 id=\"默认网关\"><a class=\"anchor\" href=\"#默认网关\">#</a> 默认网关</h3>\n<p><strong>默认网关是路由器上连接到源主机所在网段的接口的 IP 地址。</strong></p>\n<p>为了使设备将数据发送到另一个网段上的设备的地址，源设备将数据发送到<strong>默认网关</strong>。</p>\n<p>发送报文到另一个网段，需要路由器把<strong>对应端口的网关的 MAC</strong> 告诉你，然后通过网关进行转发</p>\n<h3 id=\"代理-arp\"><a class=\"anchor\" href=\"#代理-arp\">#</a> 代理 ARP</h3>\n<p>如果源主机未配置默认网关，发送 ARP 请求，然后路由器给你一个 ARP 的 reply，告诉你 MAC 地址（<strong>一般为路由器端口本网段的 IP 地址</strong>）</p>\n<h1 id=\"网络层服务\"><a class=\"anchor\" href=\"#网络层服务\">#</a> 网络层服务</h1>\n<p>IP 是<strong>无连接系统</strong>。 <strong>IP 就是提供无连接的网络服务 Connetionless network</strong></p>\n<p>使用<strong>报文交换（Packet Switched）</strong></p>\n<ol>\n<li>\n<p><strong>将原始数据分为很多的子报文（单位），每个子报文（单位）自己选择路径进行发送。</strong></p>\n</li>\n<li>\n<p><strong>大部分的 Connetionless network 都是基于 packet switched 进行实现，控制网络拥塞。</strong></p>\n</li>\n<li>\n<p>出现问题时候，我们只需要重传对应部分的报文就可以（不用重传全部数据）</p>\n</li>\n</ol>\n<h1 id=\"网络协议操作\"><a class=\"anchor\" href=\"#网络协议操作\">#</a> 网络协议操作</h1>\n<h2 id=\"路由协议的分类\"><a class=\"anchor\" href=\"#路由协议的分类\">#</a> 路由协议的分类</h2>\n<ol>\n<li>\n<p>静态路由：网络管理员在路由器中手动输入路由信息。</p>\n</li>\n<li>\n<p>动态路由</p>\n<ol start=\"3\">\n<li>\n<p>路由器可以在运行过程中互相学习信息。</p>\n</li>\n<li>\n<p>使用路由协议更新路由信息。</p>\n</li>\n<li>\n<p>RIP, IGRP, EIGRP, OSPF …</p>\n</li>\n<li>\n<p>人工维护的代价比较大</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"静态路由和动态路由的区别\"><a class=\"anchor\" href=\"#静态路由和动态路由的区别\">#</a> 静态路由和动态路由的区别</h3>\n<ol>\n<li>\n<p>静态路由</p>\n<ol start=\"2\">\n<li>\n<p>用于<strong>隐藏</strong>部分网络。安全（不必进行路由表的交换）</p>\n</li>\n<li>\n<p>测试网络中的特定链接。</p>\n</li>\n<li>\n<p>用于仅在到达目标网络的路径时维护路由表。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>动态路由</p>\n<ol start=\"6\">\n<li>\n<p>维护路由表。</p>\n</li>\n<li>\n<p>以路由更新的形式及时分发信息。</p>\n</li>\n<li>\n<p>依靠路由协议共享知识。</p>\n</li>\n<li>\n<p>路由器可以调整以适应不断变化的网络状况。</p>\n</li>\n<li>\n<p>打开后会启动<strong>进程</strong>，按照不同的协议，和网上的不同设备学习信息，然后根据<strong>算法</strong>生成路由表</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"动态路由协议的分类\"><a class=\"anchor\" href=\"#动态路由协议的分类\">#</a> 动态路由协议的分类</h2>\n<p><strong>内部网关协议和外部网关协议</strong></p>\n<ul>\n<li>\n<p><strong>内部网关协议 IGP（Interior Gateway Protocols</strong>，RIP，IGRP，EIGRP，OSPF）</p>\n</li>\n<li>\n<p><strong>外部网关协议 EGP（Exterior Gateway Protocols</strong>，EGP，BGP）</p>\n</li>\n</ul>\n<h3 id=\"内部网关协议的分类dvp-and-lsp\"><a class=\"anchor\" href=\"#内部网关协议的分类dvp-and-lsp\">#</a> 内部网关协议的分类：DVP and LSP</h3>\n<ul>\n<li>\n<p><strong>距离矢量协议 DVP（Distance-Vector Protocols</strong>，RIP, IGRP）</p>\n<ul>\n<li>\n<p>从<strong>邻居</strong>的角度查看网络拓扑</p>\n</li>\n<li>\n<p>经常定期（periodic）更新</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>链路状态协议 LSP（Link State Protocols</strong>, OSPF）</p>\n<ul>\n<li>\n<p>获取整个网络拓扑的通用视图</p>\n</li>\n<li>\n<p><strong>事件</strong>触发的更新。如果没有事件发生那么就不会更新</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"距离矢量协议dvp\"><a class=\"anchor\" href=\"#距离矢量协议dvp\">#</a> 距离矢量协议（DVP）</h3>\n<h4 id=\"riprouting-information-protocol路由信息协议\"><a class=\"anchor\" href=\"#riprouting-information-protocol路由信息协议\">#</a> <strong>RIP（Routing Information Protocol）路由信息协议</strong></h4>\n<ol>\n<li>\n<p>基于距离矢量的内部网关协议。</p>\n</li>\n<li>\n<p>唯一的指标是跳数。</p>\n</li>\n<li>\n<p>最大跳数为 15。（评判依据简单，是一个短板）</p>\n</li>\n<li>\n<p><strong>每 30 秒更新一次（广播），可以修改。</strong></p>\n</li>\n<li>\n<p>并非总是选择最快的路径（而是走跳数最短的路径）。</p>\n</li>\n</ol>\n<h3 id=\"链路状态协议lsp\"><a class=\"anchor\" href=\"#链路状态协议lsp\">#</a> 链路状态协议（LSP）</h3>\n<h4 id=\"ospfopen-shortest-path-first最短路径优先协议\"><a class=\"anchor\" href=\"#ospfopen-shortest-path-first最短路径优先协议\">#</a> OSPF（Open Shortest Path First）最短路径优先协议</h4>\n<ol>\n<li>\n<p>指标由<strong>带宽</strong>，速度，流量，可靠性和安全性组成，<strong>本科阶段只考虑带宽的。</strong></p>\n</li>\n<li>\n<p><strong>事件触发时更新。</strong></p>\n</li>\n</ol>\n<h4 id=\"igrpinterior-gateway-routing-protocol-and-eigrpenhanced-igrp\"><a class=\"anchor\" href=\"#igrpinterior-gateway-routing-protocol-and-eigrpenhanced-igrp\">#</a> IGRP（Interior Gateway Routing Protocol） and EIGRP（Enhanced IGRP）</h4>\n<p>略</p>\n<h1 id=\"可变长度子网掩码-vlsm\"><a class=\"anchor\" href=\"#可变长度子网掩码-vlsm\">#</a> 可变长度子网掩码 VLSM</h1>\n<p><strong>可变长度子网掩码（Variable Length Subnet Mask，VLSM）</strong></p>\n<ol>\n<li>\n<p>VLSM 只是一项功能，它允许<strong>单个自治系统的网络具有不同的子网掩码。</strong></p>\n</li>\n<li>\n<p>有效的解决网络号浪费的问题</p>\n</li>\n<li>\n<p>使用 VLSM，网络管理员可以在主机少的网络上使用长掩码，而在主机多的子网上使用短掩码。（提供了很高的灵活性）</p>\n</li>\n</ol>\n<p>子网全 0 可以使用。全 1 不行</p>\n<h2 id=\"支持-vlsm-的路由协议\"><a class=\"anchor\" href=\"#支持-vlsm-的路由协议\">#</a> 支持 VLSM 的路由协议</h2>\n<ol>\n<li>\n<p>开放式最短路径优先（OSPF）</p>\n</li>\n<li>\n<p>Integrated Intermediate System to Intermediate System（Integrated IS-IS） 集成中间系统到中间系统（集成 IS-IS）</p>\n</li>\n<li>\n<p>增强型内部网关路由协议（EIGRP）</p>\n</li>\n<li>\n<p>RIP v2</p>\n</li>\n<li>\n<p>静态路由</p>\n</li>\n</ol>\n<h2 id=\"vlsm-的表示法\"><a class=\"anchor\" href=\"#vlsm-的表示法\">#</a> VLSM 的表示法</h2>\n<p><img data-src=\"/image/CN4/image%202.png\" alt=\"image.png\" /></p>\n<ol>\n<li>\n<p><strong>斜杠的含义是指前面多少位保留给网络位</strong></p>\n</li>\n<li>\n<p><strong>此时也就是 / 30 就可以满足路由器之间的网络连通所需（减少浪费），剩下的网络地址可以在以后网络进行扩展</strong></p>\n</li>\n</ol>\n<h2 id=\"vlsm-的例子\"><a class=\"anchor\" href=\"#vlsm-的例子\">#</a> VLSM 的例子</h2>\n<h3 id=\"例子总结\"><a class=\"anchor\" href=\"#例子总结\">#</a> 例子总结</h3>\n<ol>\n<li>\n<p>重要的是要记住，只有<strong>未使用的子网</strong>才能进一步划分子网。</p>\n</li>\n<li>\n<p>如果使用了子网中的任何地址，则该子网不能再进行子网划分。</p>\n</li>\n<li>\n<p>一般是从<strong>主机多到主机少</strong>（路由间网络）进行划分</p>\n</li>\n</ol>\n<h3 id=\"划分背景\"><a class=\"anchor\" href=\"#划分背景\">#</a> 划分背景</h3>\n<ol>\n<li>\n<p>已分配 192.168.10.0/24 的 C 类地址。</p>\n<ol start=\"2\">\n<li>\n<p>珀斯需要 60 个主机</p>\n</li>\n<li>\n<p>KL 需要 28 个主机</p>\n</li>\n<li>\n<p>悉尼和新加坡分别需要 12 位主机。</p>\n</li>\n<li>\n<p>珀斯，悉尼和新加坡与吉隆坡建立 WAN 连接。（各需要 2 个网络号 / 主机）</p>\n</li>\n</ol>\n</li>\n<li>\n<p>先划分成大的子网，然后进一步进行划分，然后在慢慢进行细化</p>\n</li>\n<li>\n<p>为了计算 VLSM 子网，各个主机首先从地址范围分配最大的需求。需求级别应从最大到最小列出。</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>划分过程</p>\n<h4 id=\"第一步满足珀斯的主机需求\"><a class=\"anchor\" href=\"#第一步满足珀斯的主机需求\">#</a> 第一步：满足珀斯的主机需求</h4>\n<ol>\n<li>\n<p>在此示例中，珀斯需要 60 个主机号。</p>\n</li>\n<li>\n<p>使用 6 位，因为 26 - 2 = 62 个可用主机地址。因此，将从第四个八位位组开始使用 2 位来表示 / 26 的扩展网络前缀，其余 6 位将用于主机地址。</p>\n</li>\n<li>\n<p>在地址 192.168.10.0/24 上应用 VLSM 可得到：</p>\n<ol start=\"4\">\n<li>\n<p>192.168.10.00 hh hhhh /26</p>\n</li>\n<li>\n<p>255.255.255.192（1100 0000）</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"/image/CN4/53.png\" alt=\"https://eaglebear2002.github.io/18756/53.png\" /></p>\n<ol>\n<li>第一个给 Perth 使用，剩下的用作保留未使用的</li>\n</ol>\n<h4 id=\"第二步为吉隆坡划分子网\"><a class=\"anchor\" href=\"#第二步为吉隆坡划分子网\">#</a> 第二步：为吉隆坡划分子网</h4>\n<ol>\n<li>\n<p>吉隆坡需要 28 台主机号。192.168.10.63/26 之后的下一个可用地址是 192.168.10.64/26。</p>\n</li>\n<li>\n<p>由于需要 28 个主机，因此主机地址需要 5 位，即 32-2 = 30 个可用主机地址。</p>\n</li>\n<li>\n<p>因此，将需要 5 位来表示主机，而将使用 3 位来表示扩展网络前缀 / 27</p>\n</li>\n<li>\n<p>在地址 192.168.10.64/26 上应用 VLSM 可得到：</p>\n<ol start=\"5\">\n<li>\n<p>192.168.10.010 hhhhh /27</p>\n</li>\n<li>\n<p>255.255.255.224（1110 0000）</p>\n</li>\n<li>\n<p>三个子网再借用一位</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"/image/CN4/54.png\" alt=\"https://eaglebear2002.github.io/18756/54.png\" /></p>\n<h4 id=\"第三步为悉尼和新加坡进行分配地址\"><a class=\"anchor\" href=\"#第三步为悉尼和新加坡进行分配地址\">#</a> 第三步：为悉尼和新加坡进行分配地址</h4>\n<ol>\n<li>\n<p>现在，悉尼和新加坡分别需要 12 位主机号。 下一个可用地址从 192.168.10.96/27 开始。</p>\n</li>\n<li>\n<p>由于需要 12 个主机，因此主机地址需要 4 位，即 24 = 16、16 - 2 = 14 个可用地址。</p>\n</li>\n<li>\n<p>因此，需要 4 位来表示主机，对于 / 28 的扩展网络前缀需要 4 位。</p>\n</li>\n<li>\n<p>在地址 192.168.10.96/27 上应用 VLSM 可得到：</p>\n<ol start=\"5\">\n<li>\n<p>192.168.10.0110 hhhh /28</p>\n</li>\n<li>\n<p>255.255.255.240（1111 0000）</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"/image/CN4/55.png\" alt=\"https://eaglebear2002.github.io/18756/55.png\" /></p>\n<h4 id=\"第四步为之间的路由地址进行划分\"><a class=\"anchor\" href=\"#第四步为之间的路由地址进行划分\">#</a> 第四步：为之间的路由地址进行划分</h4>\n<ol>\n<li>\n<p>现在为 WAN 连接分配地址。请记住，每个 WAN 连接都需要两个 IP 地址。下一个可用的子网是 192.168.10.128/28。</p>\n</li>\n<li>\n<p>由于每个 WAN 链路需要 2 个网络地址，因此主机地址需要 2 位，即 22 -2 = 2 个可用地址。</p>\n</li>\n<li>\n<p>因此，需要 2 位来表示链接，并需要 6 位来表示扩展网络前缀 / 30。</p>\n</li>\n<li>\n<p>在 192.168.10.128/28 上应用 VLSM 可得到：</p>\n<ol start=\"5\">\n<li>\n<p>192.168.10.011000 hh /30</p>\n</li>\n<li>\n<p>255.255.255.252（1111 1100）</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img data-src=\"/image/CN4/56.png\" alt=\"https://eaglebear2002.github.io/18756/56.png\" /></p>\n<p><img data-src=\"/image/CN4/image-20220625101016298.png\" alt=\"https://eaglebear2002.github.io/18756/image-20220625101016298.png\" /></p>\n<ol>\n<li>通过上述方法，从主机需求量大的部分入手，到主机需求量小的部分是很好的方法。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"路由聚集route-aggregation\"><a class=\"anchor\" href=\"#路由聚集route-aggregation\">#</a> 路由聚集（Route Aggregation）</h2>\n<p><strong>无类域间路由（CIDR，Classless InterDomain Routing）</strong></p>\n<ol>\n<li>\n<p>使用无类域间路由（CIDR，Classless InterDomain Routing）和 VLSM 不仅可以防止地址浪费，而且还可以促进路由聚合或汇总。</p>\n</li>\n<li>\n<p>多个路由条目汇聚成小的路由条目</p>\n</li>\n<li>\n<p>比如如下图就是讲 3 个 / 24 的子网合并成一个 / 16 的网络高速远端</p>\n</li>\n</ol>\n<p><img data-src=\"/image/CN4/image%203.png\" alt=\"image.png\" /></p>\n<h3 id=\"如何进行路由聚集\"><a class=\"anchor\" href=\"#如何进行路由聚集\">#</a> 如何进行路由聚集</h3>\n<p><img data-src=\"/image/CN4/image-20230721111736898.png\" alt=\"https://eaglebear2002.github.io/18756/image-20230721111736898.png\" /></p>\n<p>如何进行计算：将尽可能多的位进行聚集，将之后的不通过的位置，作为 Host 位，就得到了上图的结果</p>\n<p>就是把前面<strong>相同的部分</strong>合并作为网络号，后面是主机号。</p>\n<ol>\n<li>\n<p>全 0 子网会在题目中说是否可用</p>\n</li>\n<li>\n<p>全 1 子网尽量不要使用</p>\n</li>\n</ol>\n<h1 id=\"因特网控制报文协议-icmp\"><a class=\"anchor\" href=\"#因特网控制报文协议-icmp\">#</a> 因特网控制报文协议 ICMP</h1>\n<p><strong>ICMP（Internet Control Message Protocol）因特网控制报文协议</strong></p>\n<ol>\n<li>\n<p>ICMP（Internet Control Message Protocol）：为了提高 IP 数据报交付成功的机会（消息管理和协商）</p>\n</li>\n<li>\n<p>ICMP 允许主机或路由器<strong>报告</strong>差错情况和提供有关异常情况的报告</p>\n</li>\n<li>\n<p>ICMP <strong>只是 IP 层的协议</strong></p>\n</li>\n<li>\n<p>ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去</p>\n</li>\n<li>\n<p>一般路由器在丢弃报文的时候（处理之前已经提到的情况），都会返回一个<strong> ICMP 差错报文</strong>。</p>\n</li>\n</ol>\n<p>两种 ICMP 报文：</p>\n<ol>\n<li>\n<p>查询报文：一般这种情况不是很多</p>\n</li>\n<li>\n<p>差错报告报文：一般这种类型会多一些</p>\n</li>\n</ol>\n<h3 id=\"pingpacket-internet-groper\"><a class=\"anchor\" href=\"#pingpacket-internet-groper\">#</a> <strong>PING（Packet InterNet Groper）</strong></h3>\n<ol>\n<li>\n<p>PING 是用 ICMP 的 &quot;Echo request “和” Echo reply&quot; 消息来实现的</p>\n</li>\n<li>\n<p>PING 用来测试两个主机之间的连通性，一般是用来检查局域网的连通性：PING 不通，不仅仅是发送不过去，有可能是应答不回来。</p>\n</li>\n<li>\n<p>PING 使用了 ICMP 回送请求与回送回答报文</p>\n</li>\n<li>\n<p>PING 是应用层<strong>直接使用</strong>网络层 ICMP 的例子，它没有通过运输层的 TCP 或 UDP</p>\n</li>\n</ol>\n<h1 id=\"附冲突域和广播域\"><a class=\"anchor\" href=\"#附冲突域和广播域\">#</a> 附：冲突域和广播域</h1>\n<p><strong>冲突域（Collision Domain）</strong> 和 <strong>广播域（Broadcast Domain）</strong> 是网络中的两个重要概念，它们分别描述了网络中设备之间如何通过物理或逻辑结构进行通信、发生冲突或广播的范围。</p>\n<h3 id=\"1-冲突域collision-domain\"><a class=\"anchor\" href=\"#1-冲突域collision-domain\">#</a> 1. <strong>冲突域（Collision Domain）</strong></h3>\n<p><strong>冲突域</strong> 是指在同一个网络环境中，多个设备在同一时间发送数据时，可能会发生 <strong>数据冲突</strong>（Collision）的区域。简单来说，冲突域是指如果两个或多个设备在同一时刻同时发送数据，它们的信号可能会相互干扰，导致数据无法正确接收并需要重新发送。</p>\n<h4 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点：</h4>\n<ul>\n<li>\n<p><strong>冲突的发生</strong>：冲突发生时，数据会丢失，设备必须重新发送。这个问题发生在共享媒介（如集线器或无线网络）中。</p>\n</li>\n<li>\n<p><strong>影响范围</strong>：冲突域的范围通常是 <strong>共享介质</strong>（如集线器、同轴电缆）的连接部分。</p>\n</li>\n<li>\n<p><strong>减少冲突</strong>：通过使用 <strong>交换机（Switch）</strong> 或 <strong>路由器（Router）</strong>，可以减少冲突，因为它们可以在物理层或数据链路层隔离不同的冲突域。</p>\n</li>\n</ul>\n<h4 id=\"示例\"><a class=\"anchor\" href=\"#示例\">#</a> 示例：</h4>\n<ul>\n<li>\n<p>在一个使用 <strong>集线器（Hub）</strong> 的网络中，所有通过集线器连接的设备都在同一个冲突域内。如果两台设备同时发送数据，它们会发生冲突。</p>\n</li>\n<li>\n<p>在一个使用 <strong>交换机（Switch）</strong> 的网络中，每个端口代表一个独立的冲突域，不同端口之间的数据传输不会发生冲突。</p>\n</li>\n</ul>\n<h4 id=\"冲突域与设备\"><a class=\"anchor\" href=\"#冲突域与设备\">#</a> 冲突域与设备：</h4>\n<ul>\n<li>\n<p><strong>集线器（Hub）</strong>：将所有连接到它的设备置于同一冲突域。</p>\n</li>\n<li>\n<p><strong>网桥 （Bridge）</strong>：每个端口形成一个独立的冲突域。</p>\n</li>\n<li>\n<p><strong>交换机（Switch）</strong>：每个端口形成一个独立的冲突域。</p>\n</li>\n<li>\n<p><strong>路由器（Router）</strong>：不会导致冲突域的形成，它们位于不同的网络之间，隔离了不同的冲突域。</p>\n</li>\n</ul>\n<h3 id=\"2-广播域broadcast-domain\"><a class=\"anchor\" href=\"#2-广播域broadcast-domain\">#</a> 2. <strong>广播域（Broadcast Domain）</strong></h3>\n<p><strong>广播域</strong> 是指在一个局域网内，通过 <strong>广播</strong>（Broadcast）方式发送的数据包可以被所有设备接收到的区域。广播数据包会被网络中所有设备接收，除非该数据包遇到一个 <strong>路由器</strong> 或 <strong>VLAN（虚拟局域网）</strong> 等设备将其隔离。</p>\n<h4 id=\"特点-2\"><a class=\"anchor\" href=\"#特点-2\">#</a> 特点：</h4>\n<ul>\n<li>\n<p><strong>广播的范围</strong>：广播域的范围通常是由 <strong>路由器</strong> 或 <strong>VLAN</strong> 划分的，所有在同一个广播域中的设备都可以接收到广播数据包。</p>\n</li>\n<li>\n<p><strong>广播风暴</strong>：如果广播域过大，可能会发生 <strong>广播风暴</strong>，即大量的广播包占用网络带宽，影响正常的通信。</p>\n</li>\n<li>\n<p><strong>隔离广播域</strong>：通过使用 <strong>路由器（Router）</strong> 或 <strong>VLAN（虚拟局域网）</strong>，可以将一个广播域划分为多个子广播域，减少广播带来的负担。</p>\n</li>\n</ul>\n<h4 id=\"示例-2\"><a class=\"anchor\" href=\"#示例-2\">#</a> 示例：</h4>\n<ul>\n<li>\n<p>在一个 <strong>交换机（Switch）</strong> 网络中，如果没有使用 VLAN，所有通过交换机连接的设备都在同一个广播域内。一个设备发送的广播数据包会被同一广播域内的所有设备接收到。</p>\n</li>\n<li>\n<p>如果通过 <strong>路由器（Router）</strong> 或 <strong>VLAN</strong> 进行隔离，不同的广播域之间的设备无法接收到彼此的广播。</p>\n</li>\n</ul>\n<h4 id=\"广播域与设备\"><a class=\"anchor\" href=\"#广播域与设备\">#</a> 广播域与设备：</h4>\n<ul>\n<li>\n<p><strong>路由器（Router）</strong>：用于将不同的广播域隔离开。广播数据包不能通过路由器转发，因此路由器可以有效地隔离不同的广播域。</p>\n</li>\n<li>\n<p><strong>VLAN</strong>：通过 VLAN 配置，可以将一个交换机划分为多个逻辑上的广播域。不同的 VLAN 之间的广播包不会相互传递。</p>\n</li>\n</ul>\n<h3 id=\"3-冲突域与广播域的区别\"><a class=\"anchor\" href=\"#3-冲突域与广播域的区别\">#</a> 3. <strong>冲突域与广播域的区别</strong></h3>\n<ul>\n<li>\n<p><strong>冲突域</strong>：指设备之间通过共享介质通信时可能会发生冲突的范围，发生冲突时，数据丢失需要重发。冲突域一般由物理设备（如集线器、交换机端口等）划分。</p>\n</li>\n<li>\n<p><strong>广播域</strong>：指广播数据包传播的范围，广播包会被同一广播域内的所有设备接收。广播域通常由路由器、VLAN 等设备划分。</p>\n</li>\n</ul>\n<h3 id=\"4-如何减少冲突域和广播域的范围\"><a class=\"anchor\" href=\"#4-如何减少冲突域和广播域的范围\">#</a> 4. <strong>如何减少冲突域和广播域的范围</strong></h3>\n<ul>\n<li>\n<p><strong>减少冲突域</strong>：</p>\n<ul>\n<li>\n<p>使用 <strong>交换机（Switch）</strong>：交换机会将每个端口划分为独立的冲突域，避免多个设备在同一时刻发生冲突。</p>\n</li>\n<li>\n<p>使用 <strong>全双工</strong>（Full Duplex）技术：在现代以太网中，大多数网络设备支持全双工通信，这样就可以避免冲突，因为数据可以在两个方向同时传输。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>减少广播域</strong>：</p>\n<ul>\n<li>\n<p>使用 <strong>路由器（Router）</strong>：路由器会将不同的广播域隔开，使得广播包无法跨越路由器进行传播。</p>\n</li>\n<li>\n<p>使用 <strong>VLAN</strong>：VLAN 可以将一个物理交换机划分为多个逻辑广播域，从而有效减少广播的范围。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-冲突域与广播域的实际应用\"><a class=\"anchor\" href=\"#5-冲突域与广播域的实际应用\">#</a> 5. <strong>冲突域与广播域的实际应用</strong></h3>\n<ul>\n<li>在大型网络中，合理划分冲突域和广播域有助于提升网络性能和效率。例如，在企业网络中，通常使用 <strong>交换机</strong> 来减少冲突域，使用 <strong>路由器</strong> 或 <strong>VLAN</strong> 来划分广播域，从而有效减少广播风暴和冲突的发生。</li>\n</ul>\n<p>总结来说：</p>\n<ul>\n<li>\n<p><strong>冲突域</strong> 是指设备之间可能发生数据冲突的区域，冲突通常发生在共享媒介中。</p>\n</li>\n<li>\n<p><strong>广播域</strong> 是指广播数据包可以传播的区域，广播域通常由路由器或 VLAN 进行隔离。</p>\n</li>\n</ul>\n<p><img data-src=\"/image/CN4/image%204.png\" alt=\"image.png\" /></p>\n",
            "tags": [
                "南京大学软件工程专业课程",
                "大二上",
                "互联网计算",
                "复习资料"
            ]
        }
    ]
}