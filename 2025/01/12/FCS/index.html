<!-- build time:Sun Jan 12 2025 17:12:35 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="北沐清的博客" href="https://erinwithbmq.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="北沐清的博客" href="https://erinwithbmq.github.io/atom.xml"><link rel="alternate" type="application/json" title="北沐清的博客" href="https://erinwithbmq.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="复习资料"><link rel="canonical" href="https://erinwithbmq.github.io/2025/01/12/FCS/"><title>计算系统基础知识点复习整理 - 计算系统基础 - 大一上 - 南京大学软件工程专业课程 | ErinwithBMQ's Blog = 北沐清的博客 = Welcome to My Wonderland</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">计算系统基础知识点复习整理</h1><div class="meta"><span class="item" title="创建时间：2025-01-12 15:53:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2025-01-12T15:53:00+08:00">2025-01-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>11k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>10 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">ErinwithBMQ's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/image/FCS/image1.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" itemprop="item" rel="index" title="分类于 南京大学软件工程专业课程"><span itemprop="name">南京大学软件工程专业课程</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%B8%80%E4%B8%8A/" itemprop="item" rel="index" title="分类于 大一上"><span itemprop="name">大一上</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%B8%80%E4%B8%8A/%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" itemprop="item" rel="index" title="分类于 计算系统基础"><span itemprop="name">计算系统基础</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://erinwithbmq.github.io/2025/01/12/FCS/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="北沐清"><meta itemprop="description" content="Welcome to My Wonderland, Per Aspera, Ad Astra."></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="北沐清的博客"></span><div class="body md" itemprop="articleBody"><p>计算系统基础知识点复习整理</p><p>整理者：ErinwithBMQ</p><h1 id="第六章"><a class="anchor" href="#第六章">#</a> 第六章</h1><ol><li><p><strong>原码反码补码计算</strong>：正数的三个码都一样；负数的反码补码才和原码不一样，反码直接取反，补码取反加 1</p></li><li><p>负数二进制位数扩展是<strong>在前面加 1</strong></p></li><li><p><strong>32 位 IEEE 标准浮点数</strong>：第 31 位为符号， <code>23~30</code> 位（共 8 位）为指数（转化为无符号整数，然后减 127，即为 2 的多少次方）， <code>0~22</code> 位（共 23 位）为尾数，即 1.…… 后面的省略号部分。如果想正常表示一个数，符号位既不能最大（为 255，所有位都是 1），也不能最小（0）。</p></li><li><p><strong>非规格化浮点数（指数位全为 0）</strong>：2 的次方：1 - 127 =-126；隐藏位为 0，即为 0.……。用这个方式可以表示<strong>小于 2^-126 的数字</strong>。</p></li><li><p><strong>64 位 IEEE 标准浮点数</strong>：第 63 位为符号， <code>52~62</code> 位（共 11 位）为指数（减 1023）； <code>0~51</code> （共 52 位）为尾数。</p></li><li><p><strong>将十进制小数转换为 IEEE 标准浮点数</strong>：</p></li></ol><p>（1）先将小数写成<strong>普通二进制</strong>（如果是负数，写其<strong>绝对值</strong>，在后面转化为浮点数时将最高位设成 1 即可）。</p><p>（2）将普通二进制转化为规格化二进制，如 00101101.1101 -&gt; 1.011011101 * 2^5</p><p>（3）将规格化二进制转化为 32 位 IEEE 标准浮点数。</p><ol><li>1.11111111111111111111111（二进制）约等于 2</li></ol><h1 id="第七章"><a class="anchor" href="#第七章">#</a> 第七章</h1><ol><li><p>与运算 A・B，或运算 A+B （・可省去）</p></li><li><p><strong>德摩根定律及其他定律</strong></p></li></ol><p><img data-src="/image/FCS/image1.png" alt="image1.png"></p><p>分配律，吸收律，德摩根定律，其他恒等式重要。其实除了德摩根，其他三个都能通过上面基本的推出来</p><ol><li><p><strong>按位取反：<strong>与 11111111 作</strong>按位异或运算</strong></p></li><li><p><strong>C 语言中的位运算符</strong>：&amp; 与运算，| 或运算，~ 非运算，^ 异或运算，&lt;&lt;左移，&gt;&gt; 右移</p></li><li><p>算数 / 逻辑左移、逻辑右移都是用 0 填充；<strong>算数右移</strong>，正数用 0 填充，负数用 1 填充</p></li><li><p><strong>运算符优先级</strong>：~<strong> 非运算 &gt;&gt;&gt;/&lt;&lt;左移右移&gt;&amp; 与 &gt;^ 异或 &gt;| 或</strong></p></li><li><p>NMOS 晶体管<strong>漏极接正极</strong> VDD，<strong>源极接负极</strong> VSS；PMOS 与其相反。NMOS<strong> 接入正电压</strong>导通，PMOS<strong> 接入负电压</strong>导通。PMOS 管的<strong>栅极会加个圆</strong></p></li><li><p>一般都是<strong>栅极输入</strong>，<strong>漏极输出</strong>，源极接电源正极或接地</p></li></ol><p><strong>非门</strong>：上下 PMOS 与 NMOS 管相连</p><p><strong>或非门：<strong>顶部两个 PMOS 管</strong>串联</strong>，下面两个 NMOS 管<strong>并联</strong></p><p><strong>或门</strong>：在或非门输出前再加一个非门</p><p><strong>与非门：<strong>顶部两个 PMOS 管</strong>并联</strong>，下面两个 NMOS 管<strong>串联</strong></p><p><strong>与门</strong>：在与非门输出前再加一个非门</p><p><strong>符号表示：</strong></p><p><img data-src="/image/FCS/image2.jpeg" alt="image2.jpeg"></p><ol><li><p><strong>译码器</strong>：输入少，输出多。<strong>n 个输入，2^n 个输出</strong>。如 2-4 线译码器，3-8 线译码器，<strong>只有一个输出有效</strong></p></li><li><p><strong>多路选择器</strong>：n 条选择线， <code>2^n</code> 个输入。由选择信号 S 决定哪个输入连接到输出。上面 <code>2^n</code> 个与门，下面一个或门。与门前非门情况不同（主要区分在这）</p></li><li><p><strong>加法器</strong>：（1）<strong>半加器</strong>：两个输入，两个输出（S 表示和，C 表示进位），分别是一个异或门和一个与门。符号是求和号加 CO</p></li></ol><p>（2）<strong>全加器</strong>：三个输入，两个输出（S 表示和，C 表示进位）。上面两个异或门，AB 异或完的结果与 C 再异或；下面两个与非门，AB 与非，AB 异或结果与 C 与非，二者再与非一次。符号是求和号加 CO 加 CI</p><ol><li><strong>数值比较器：</strong></li></ol><p><img data-src="/image/FCS/image3.png" alt="image3.png"></p><p>左边两个是非门</p><ol><li>用与或非表示异或与与或：</li></ol><p><img data-src="/image/FCS/image4.jpeg" alt="image4.jpeg"></p><ol><li><strong>R-S 锁存器</strong>：由两个与非门（或者或非门）组成。工作原理是设置 R、S 来控制电路状态。</li></ol><p>R：复位引脚 S：置位引脚。有两个输出 a、b（重点看 a）</p><p><img data-src="/image/FCS/image5.png" alt="image5.png"></p><p>S：1 R：1 ：保持状态（保持现有 a 的值）</p><p>S：1 R：0 ：“复位 / 置 0” 状态（将 a 变为 0）</p><p>S：0 R：1 ：“置位 / 置 1” 状态（将 a 变为 1）</p><p>S：0 R：0 ：错误</p><p><strong>如果是两个或非门：SR 都为 0 时保存 a，都为 1 时错误。其他相同。</strong></p><ol><li><strong>门控 D 锁存器</strong>：输入控制门电路（两个与非门）+ R-S 锁存器。</li></ol><p>两个输入：WE 与 D</p><p><strong>WE = 1 时，输出（a） = D</strong>;<strong>WE = 0，S = R = 1，输出状态不变</strong>（保持 a 的值）</p><p><img data-src="/image/FCS/image6.png" alt="image6.png"></p><ol><li><p><strong>主从 D 触发器</strong>：由两个门锁 D 锁存器构成</p></li><li><p><strong>时序逻辑电路：找有几个状态，以及到各个状态的条件</strong></p></li></ol><h1 id="第八章-冯洛依曼模型"><a class="anchor" href="#第八章-冯洛依曼模型">#</a> 第八章 冯・洛依曼模型</h1><ol><li><p>冯・洛依曼模型</p></li><li><p><strong>组成部分</strong></p></li></ol><p><img data-src="/image/FCS/image7.png" alt="image7.png"></p><p><strong>处理单元与控制单元是 CPU 的主要组成部分</strong></p><ol><li><strong>存储器（RAM）</strong>：包括基本存储原件、寄存器与主存储器，其中寄存器读取速度最快。</li></ol><p><strong>寻址能力</strong>：存储在每一个单元中信息的位数。</p><p><code>2^32×8</code> 位：一共有 <code>2^32</code> 个存储单元（<strong>地址空间，唯一可识别的单元总数</strong>），每个存储单元可以存 8 位（<strong>寻址能力，8 位为字节可寻址</strong>）。总量 4GB</p><p><strong>SRAM</strong>：静态随机访问存储器，供电状态下能一直保存；<strong>DRAM</strong>：动态随机访问存储器，需要不断刷新，而且关机会丢失数据。</p><p>・访问其存储器的一个单元需要 n 位 / 使用 n 位地址：<strong>地址空间为 2^n</strong></p><p><strong>・8 位为 1 字节；4 字节为 1 字长（DLX 指令集）</strong></p><ol><li><strong>4×2 位存储器实例</strong></li></ol><p><img data-src="/image/FCS/image8.jpeg" alt="image8.jpeg"></p><p>（1）4×2 位：存储空间为 4（4 个单元），寻址能力为 2 位（一个单元里有 2 位数据）</p><p>（2）注意谁是地址线，谁是字线</p><p>（3）有一个译码器和两个多路选择器</p><p>（4）</p><p>A：地址，选择存入 / 输出哪个地址的内容</p><p>WE：1 为存储数据，0 为读取数据</p><p>D：输入 Q：输出</p><ol><li><p><strong>处理单元</strong></p></li><li><p><strong>算术与逻辑处理单元 ALU</strong>：ALU 一次正常处理的信息量大小通常被称为计算机的<strong>字长</strong>，每一次被处理的元素被称为一个<strong>字</strong>。每一个指令集结构都有自己的字长。<strong>DLX 是 32 位（4 个字节）</strong></p></li><li><p><strong>寄存器堆 / 文件 Reg</strong>：功能是临时存取数据，因为其读取速度很快；<strong>每个寄存器都包含一个字。</strong></p></li><li><p><strong>控制单元 PC</strong></p></li><li><p><strong>功能：指挥信息的处理；跟踪指令的执行</strong></p></li><li><p><strong>PC：程序计数器 / 指令指针。控制单元中容纳下一条指令所在地址的寄存器。功能是跟踪要处理的下一条指令。</strong></p></li><li><p><strong>输入 / 输出设备：外围设备</strong></p></li><li><p><strong>DLX 示例</strong></p></li><li><p><strong>总线结构，多时钟周期</strong></p></li><li><p><strong>寄存器（32 位）：寄存器堆 / 文件，程序计数器 PC，指令寄存器 IR</strong></p></li><li><p><strong>多路选择器：有 DRMUX，AMUX，BMUX</strong></p></li><li><p><strong>总线：由 32 根线和相关电子元件组成。允许传输 32 位信息，一次只可传输一个值</strong></p></li><li><p><strong>存储器：MAR，主存地址寄存器，保存目的位置或数据来源位置的地址；MDR，主存数据寄存器，保存被写入地址或地址单元读入的数据（都是 32 位，一个字长）。</strong></p></li><li><p><strong>存储器是 2^32 个存储单元，字节可寻址。</strong></p></li></ol><p><strong>简单来说就是，MAR 存地址，MDR 存地址中对应的数据（要么是以其地址开头连续四个单元的数据，要么是 8 位扩展成 32 位）。如果要写入数据，那就是将 MDR 中的数据写入 MAR 存的地址对应的存储单元里</strong></p><ol><li><p><strong>处理单元： ALU 与寄存器堆。有 32 个整数寄存器，32 个浮点寄存器（DLX 子集没有这个）</strong></p></li><li><p><strong>控制单元：①有限状态机，一个输入是 CLK，说明每个时钟周期持续的时间。②指令寄存器 IR，保存正在处理的指令，同时也是有限状态机的一个输入。③程序计数器 PC，记录下一条要被执行的指令所在的地址</strong></p></li><li><p><strong>实心箭头：数据元素；空心箭头：控制信号</strong></p></li><li><p><strong>输入 / 输出设备：键盘：数据寄存器 KBDR，状态寄存器 KBSR；显示器：显示寄存器 DDR，状态寄存器 DSR。详见第十二章</strong></p></li></ol><h1 id="第九章-指令集结构"><a class="anchor" href="#第九章-指令集结构">#</a> 第九章 指令集结构</h1><ol><li><p>指令集结构</p></li><li><p><strong>指令集结构 ISA：操作码＋操作数。</strong></p></li></ol><p>操作码：让计算机执行的操作。DLX 中分为算数 / 逻辑运算指令，数据传送指令，控制指令，浮点指令四种（按功能分）。</p><p>操作数：数据类型；DLX 中的<strong>寻址方式 —— 基址＋偏移量</strong></p><ol><li><p><strong>DLX 指令操作类型</strong>：共 64 种指令类型，由 [31:26] 位定义（6 位），其中又分为 R 类型、I 类型、J 类型，总共有 91 条指令。</p></li><li><p><strong>R 类型指令：[31:26] 位为 000000，[5:0] 位定义了函数，共 64 中可能的函数</strong></p></li><li><p><strong>算数 / 逻辑运算指令</strong>：对整数进行处理；共有 37 个算术逻辑运算指令；除 LHI 加载高位立即数指令外，其他都是进行的二元运算，即两个源操作数和一个目标操作数</p></li></ol><p><strong>第一个源操作数</strong>：来自 32 个整数寄存器，[25:21] 位对应寄存器，SR1。如 R1 即为 00001，R5 即为 00011。</p><p><strong>第二个源操作数</strong>：I 类型（立即数类型）：[15:0] 位直接读取立即数（补码）；R 类型：[20:16] 位对应寄存器，SR2。</p><p><strong>目标操作数</strong>：I 类型：[20:16] 对应寄存器，DR；R 类型：[15:11] 位对应寄存器，DR。（SR1、SR2、DR 可以相同）</p><p><strong>ADDI：使用立即数的相加指令。将 SR1 内数值与立即数相加存入 DR 中</strong></p><p><strong>SUBI：使用立即数的相减指令。将 SR1 内数值与立即数相减存入 DR 中</strong></p><p><strong>ANDI：使用立即数的与运算指令。将 SR1 内数值与立即数进行与运算存入 DR 中</strong></p><p><strong>ORI：或运算</strong></p><p><strong>XORI：异或运算</strong></p><p><strong>SLEI：设置是否小于等于操作。若 SR1 中数值小于等于立即数，则 DR 设为 1，否则为 0</strong></p><p><strong>SLTI：设置是否小于操作。若 SR1 中数值小于立即数，则 DR 设为 1，否则为 0</strong></p><p><strong>SEQI：设置是否相等条件操作</strong></p><p><strong>SRAI：算术右移立即数操作。将 SR1 中数值立即右移立即数对应的位数存入 DR。注意负数是补 1。可用来表示一些除法如除 2 除 4 等</strong></p><p><strong>SRLI：逻辑右移立即数，道理同上，不过负数补 0</strong></p><p><strong>SLLI：左移立即数。用来表示乘法</strong></p><p><strong>LHI：加载高位立即数指令。没有 SR1（全为 0），只有 DR。将立即数左移 16 位后加载至 DR 中。如立即数原来为 x1234（本来就只有 16 位），左移 16 位变为 x12340000 加载至 DR 中。（DR 是 32 位的）</strong></p><ol><li><strong>R 类型操作指令：将上面的立即数全部变为 SR2 内存的数值，去掉 I（如 ADD、SUB）</strong></li></ol><p><strong>除 LHI 指令，其他运算指令均有 I 类型和 R 类型</strong></p><ol><li><strong>数据传送指令：基址寄存器 + 偏移量</strong></li></ol><p><strong>LW：字加载指令。将 SR1 内数值加上立即数得到一个地址，将以该地址为起始地址的连续四个单元内的数值（一个字）加载至 DR 中。</strong></p><p><strong>LB：字节加载指令。将 SR1 内数值加上立即数得到一个地址，将以该地址内的数值（一个字节）加载至 DR 中。前面不足的位数补全（负数应该还是用 1 补吧？）</strong></p><p><strong>SW：字存储指令。将 SR1 内数值加上立即数得到一个地址，将 DR 中的数值（一个字）存储到以该地址为起始地址的连续四个单元中。</strong></p><p><strong>SB：字节存储指令。将 SR1 内数值加上立即数得到一个地址，将 DR 中的最低八位（一个字节）存储到以该地址对应的单元中。</strong></p><ol><li><p><strong>R0：绝对地址。里面的数值只能全是 0，不可以改变</strong></p></li><li><p><strong>边界对齐：LW、SW 指令里基址＋偏移量的地址必须是 4 的倍数（因为加载存储的是字）</strong></p></li></ol><p><strong>另外，地址用十六进制表示，立即数是二进制，加的时候注意一下</strong></p><ol><li><p><strong>运算指令与数据传送指令每次使 PC＋4. 因为一条指令占用 4 个存储单元（一个存储单元 8 位，一条指令 32 位）</strong></p></li><li><p><strong>控制指令：改变被执行的指令的顺序</strong></p></li></ol><p><strong>①条件分支：仅使用 SR1。分为 BEQZ（等于 0 时分支）和 BNEZ（不等于 0 时分支）</strong></p><p><strong>取指令阶段：PC+4（这时 PC 已经是下一条指令的地址了）</strong></p><p><strong>译码 / 取寄存器：接着计算 PC（已经加过 4）+ 立即数，得出目标指令地址</strong></p><p><strong>完成分支阶段：BEQZ：若 SR1 为 0，则将上一步得到地址加载至 PC；若 SR1 不为 0，PC 不变，正常进入下一条指令。（BNEZ 与其相反）</strong></p><p><strong>②无条件跳转指令：JR 指令与 J 指令</strong></p><p><strong>JR：DR、立即数全为 0，仅使用 SR1。将 SR1 内的数值加载到 PC</strong></p><p><strong>J：[25:0] 的数值＋4＋PC-&gt; PC</strong></p><p><strong>③TRAP 指令：改变 PC，是它指向属于操作系统的某部分的存储地址，作用是让操作系统执行一些任务 —— 调用服务例程。（见后面章节）</strong></p><ol><li><strong>DLX 指令处理</strong></li></ol><p><img data-src="/image/FCS/image9.png" alt="image9.png"></p><p><strong>存储器</strong>：地址空间 2^32（即 4G）个单元。地址标识符是 32 位二进制，或 8 位十六进制。寻址能力是 8 位。访问字只需访问其<strong>起始地址</strong>，但需要是 4 的倍数，即<strong>边界对齐</strong>。</p><ol><li><p><strong>高位优先</strong>，字的高位字节放在内存的低地址端。</p></li><li><p><strong>寄存器</strong>：每一个寄存器中的存储位数是 32 位的字。有 32 个通用寄存器，5 位编码识别。其中，R0 内必须是 0. 还有 32 个浮点寄存器，标记为 F0、F1…… 单精度浮点数一个寄存器，双精度浮点数两个寄存器。</p></li><li><p>指令处理：多时钟周期</p></li><li><p>DLX 指令执行阶段：①取指令 ②译码 / 取寄存器 ③执行 / 有效地址 / 完成分支 ④访问内存 ⑤存储结果。每条指令需要进行其中的 3-5 个阶段</p></li><li><p>DLX 的有限状态机：每一步都是由控制单元的有限状态机控制，一个周期接一个周期地控制整个程序执行。以时钟周期为单位持续运行指令，停止时钟（运行锁清 0），则停止指令的运行。</p></li><li><p><strong>DLX 运行示例</strong></p></li><li><p><strong>取指令阶段</strong>：①PC -&gt; MAR；ALU 中进行 PC+4 的计算 ②PC+4 -&gt; PC；M [MAR] -&gt; MDR ③MDR -&gt; IR</p></li><li><p><strong>译码 / 取寄存器阶段：<strong>①使用指令的操作码，进行译码，控制指令执行 ②根据指令取寄存器，获得源操作数传给</strong> ALU 的寄存器 A 和寄存器 B</strong>③在 ALU 中计算 PC＋IR [15:0] 符号扩展的和，将结果存储在 ALUOut 寄存器中（可能该结果没有用，但是还会进行）</p></li><li><p><strong>执行 / 有效地址 / 完成分支</strong>：三种选择（选择其一）：①执行算数 / 逻辑运算，结果存储在 ALUOut 中 ②计算有效地址，结果存储在 ALUOut 中 ③完成分支跳转</p></li><li><p><strong>访问内存：</strong>（如果要访问内存的话）ALUOut -&gt; MAR；M [MAR]（该地址开头四个单元的数据） -&gt; MDR</p></li><li><p><strong>存储结果</strong>：将结果写到目标（应该是 DR）中</p></li></ol><h1 id="第十章-机器程序语言设计"><a class="anchor" href="#第十章-机器程序语言设计">#</a> 第十章 机器程序语言设计</h1><ol><li><p>机器程序语言设计</p></li><li><p>I 类型指令和 R 类型指令分别的特点：I 类型可以访问内存，但速度较慢；R 类型是寄存器之间的操作，不能访问内存，速度较快</p></li><li><p>三种基本结构：顺序、选择、循环</p></li></ol><p>・选择中 J 指令的立即数：子任务 1 的指令数目乘 4</p><p>・循环中 J 指令是返回生成条件指令</p><h1 id="第十一章-汇编语言"><a class="anchor" href="#第十一章-汇编语言">#</a> 第十一章 汇编语言</h1><ol><li><p>汇编语言</p></li><li><p><strong>汇编语言四个部分</strong>：标记 操作码 操作数；注释。其中，标记与注释可选。不区分大小写。注释前要加；</p></li><li><p><strong>标记：<strong>以字母、下划线或 $ 开头，中间可包含下划线、字母或数字，<strong>以冒号结尾</strong>；操作码作为保留字，不能用做标记。标记用作立即数代表的是</strong>这条指令的地址</strong></p></li><li><p><strong>操作码</strong>：如 ADD，ADDI…… 指令操作码的符号名</p></li><li><p><strong>操作数</strong>：寄存器则写 R0、R1…… 立即数前面加 #表示十进制，x 表示十六进制，b 表示二进制，如 #10，x16 等。<strong>与机器语言不同，汇编指令中 DR 在前面，SR1 在后面</strong></p></li><li><p><strong>运算指令</strong></p></li></ol><p><strong>I 类型汇编指令格式：OPCODE DR, SR1, Imm16 立即数也可以是标记</strong></p><p><strong>R 类型汇编指令格式：OPCODE DR, SR1, SR2</strong></p><ol><li><p><strong>LHI：LHI DR, Imm16</strong> 立即数可以是标记，<strong>此时是将标记对应地址的高 16 位值赋给 DR，如地址是 x30001A00，则赋值 x30000000</strong></p></li><li><p><strong>数据传送指令：</strong></p></li></ol><p><strong>LW/LB DR, Imm16(SR1)</strong></p><p><strong>SW/SB Imm16(SR1), DR</strong></p><p><strong>立即数可以使用标记</strong></p><ol><li><strong>控制指令：</strong></li></ol><p><strong>BEQZ/BNEZ：OPCODE SR1, LABEL 最后是标记，即目标地址。此时不需要再计算 PC+4 + 立即数。而是符合要求就直接跳转到标记地址</strong></p><p><strong>J：J LABEL 直接跳转到标记地址</strong></p><p><strong>JR：JR SR1</strong></p><p><strong>TRAP：TRAP Imm</strong></p><ol><li><strong>伪操作：以。作为第一个字符</strong></li></ol><p><strong>数据区：</strong></p><p><strong>①.dataaddress</strong> : 将下面的数据放在数据区的某一个地方（address 为其起始地址）</p><p><strong>注意，该地址必须是 4 的倍数。</strong></p><p><strong>如果不是 4 的倍数：.alignn : 将下面的数据加载到以 n 个 0 结尾的地址里</strong></p><p><strong>②.wordword1, word2, ... : 将字 1，字 2，…… 存储在连续的存储单元中</strong></p><p><strong>③.bytebyte1, byte2, ... : 将字节 1，字节 2，…… 存储在连续的存储单元中</strong></p><p><strong>④.ascii “string1”,“string2”, ... : 将字符串 1，字符串 2，…… 存储在存储器中。.asciiz 与其相似，不同是 .asciiz 会在字符串结尾再存储一个 0.（相当于 C 语言中的 \0）</strong></p><p><strong>⑤.spacesize: 预留空间，留出 size 个字节</strong></p><p><strong>代码区：</strong></p><p><strong>① .textaddress : 将指令放在存储器的某个地方。不是 4 的倍数时也要用.align</strong></p><p><strong>②.globallabel : 全局标记，让该标记在其他文件中也可以使用</strong></p><ol><li><p><strong>汇编过程：</strong>“两趟” 扫描：第一趟，标识出符号（标记）对应的二进制地址，建立<strong>符号表</strong>；第二趟，把汇编指令翻译成机器指令。此时使用<strong>地址计数器 LC（它与程序计数器 PC 的不同：LC 是当前地址，PC 是下一条指令的地址）</strong></p></li><li><p><strong>立即数是标记</strong>的 ADDI 指令，<strong>如果地址无法用 16 位的立即数表示</strong>，解决方法：翻译成两条指令。</p></li></ol><p>如，addi R1, R0, numbers，numbers 为 x3000000C，将其拆分成两条语句翻译：</p><p>LHI R1, x3000</p><p>ADDI R1, R0, x000C</p><p>注意接下来是 LC+8 而不是 + 4。</p><p><strong>立即数是标记的 SW 指令</strong>：如 SW sum (R0), R3 ，sum 是 x30000034</p><p>翻译成两条指令：LHI R5 x3000 SW x0034 (R5), R3 （<strong>使用临时寄存器 R5</strong>）</p><p>LC+8 -&gt; LC</p><p>翻译成多条指令后，符号表也需要调整</p><ol><li>寄存器分配规则</li></ol><p><img data-src="/image/FCS/image10.png" alt="image10.png"></p><p>变量多于寄存器数目时，就要使用存储器。—— 第十四章，栈的存储结构</p><h1 id="第十二章-输入输出"><a class="anchor" href="#第十二章-输入输出">#</a> 第十二章 输入输出</h1><ol><li><p>输入和输出</p></li><li><p>** 键盘和显示器：** 面向流的设备，一个字符一个字符地按顺序读写</p></li><li><p><strong>键盘设备寄存器：<strong>32 位。KBDR 键盘数据寄存器：只有</strong> [7:0] 用来存放数据（一个字节）</strong>，其他都是 0；KBSR 键盘状态寄存器：[0] 位，就绪位</p></li><li><p>** 显示器设备寄存器：**32 位。DDR 键盘数据寄存器：只有 [7:0] 用来存放数据（一个字节），其他都是 0；DSR 键盘状态寄存器：[0] 位，就绪位</p></li><li><p>** 内存映射的 I/O：** 采用内存映射的方式表示 I/O 设备。比如，xFFFF0000——xFFFF0003，不再是存储器里的某个数据的地址，而是代表 KBSR 的地址</p></li><li><p>R.W=0：加载信号；R.W=1：存储信号（？）</p></li><li><p><strong>异步的处理与同步机制</strong>：需要状态寄存器。KBSR [0] 为 1 时，键盘不能用；当读取完上一个输入的字符时，KBSR [0] 清 0，允许读入下一个字符。KBSR [0] 为 0 时，代表没有新的字符输入，不进行后面的读取操作。</p></li></ol><p>每当显示器完成了一个字符的显示，就将 DSR [0] 设为 1，允许进行下一个字符的显示；每当处理器正在向显示器写字符时，将 DSR [0] 设为 0，不进行新的显示字符的操作。</p><ol><li><strong>轮询机制</strong>：周期性检查状态位。缺点是浪费时间。—— 中断机制的出现</li></ol><h1 id="第十三章-自陷例程和中断"><a class="anchor" href="#第十三章-自陷例程和中断">#</a> 第十三章 自陷例程和中断</h1><ol><li><p>自陷例程和中断</p></li><li><p>自陷 (TRAP) 指令 —— 系统调用，通过调用操作系统来完成任务</p></li></ol><p><img data-src="/image/FCS/image11.png" alt="image11.png"></p><ol><li><strong>TRAP 机制 1—— 服务例程</strong>：操作系统的一部分，代表用户执行的一组程序。DLX 有 256 个服务例程。</li></ol><p><img data-src="/image/FCS/image12.png" alt="image12.png"></p><p>几个常见的：</p><ol><li>**TRAP 机制 2——TRAP 向量表：<strong>包括了 256 个</strong>服务例程的起始地址（实际是代码区的起始地址）** 的表，每个起始地址占用四个存储单元（32 位）。这张表被存储在存储单元的 x0000 0000 到 x0000 03FF 中。</li></ol><p>・数据区与代码区：数据区的起始地址在代码区起始地址<strong>之前的 x100 个单元</strong></p><ol><li><strong>TRAP 机制 3——TRAP 指令：<strong>调用操作系统代表用户程序执行某一服务例程，完成后把控制权还给用户程序。根据 TRAP 向量，<strong>相应服务例程首地址 -&gt; PC</strong>，并且要记得</strong>提供返回路径。</strong></li></ol><p><strong>TRAP 指令处理：①取指令：<strong>PC + 4 -&gt; PC。②译码</strong>③计算有效地址：<strong>TRAP 向量（26 位）扩展成 32 位，再</strong>左移 2 位（乘以 4）④TRAP 向量（计算后） -&gt; MAR，M [MAR] -&gt; MDR。</strong></p><p><strong>⑤写回：PC -&gt; R31（提供返回路径），MDR -&gt; PC（开始服务例程）</strong></p><p>在 TRAP 服务例程中，最后一条指令是 <strong>JR R31</strong>，使得控制返回用户程序的正确位置</p><ol><li>寄存器的保存与恢复：<strong>①被调用者保存：在服务例程内部的一开始进行保存</strong> <strong>②调用者保存：在调用服务例程前进行保存</strong>，一般出现在服务例程内部调用另一个服务例程之前，而且保护的一般是 R31（调用服务例程时会将 R31 改掉）</li></ol><p><strong>原则是</strong>哪个程序知道哪些寄存器被接下来的操作所破坏，处理问题的就应该是哪一个程序。</p><ol><li><p><strong>停机服务例程</strong>（TRAP x00）：MCR [0]：机器控制寄存器，有内存映射地址。要将其清 0</p></li><li><p><strong>中断驱动的 I/O</strong>：I/O 设备能够强制程序中止，让处理器执行 I/O 设备的请求；请求完成后让停止的程序继续进行。</p></li><li><p><strong>中断信号（INT）的产生</strong>：满足两个条件：<strong>①KBSR,DSR 的就绪位为 1</strong>，表示需要服务</p></li></ol><p><strong>②中断允许位（IE）</strong>，大多数设备中是设备状态寄存器的一部分。设为 1 或 0，取决于是否给其权利去请求服务。</p><p><strong>中断请求信号（IRQ）<strong>是</strong>就绪位与 IE 的逻辑与；<strong>各个设备发出的 IRQ 经过</strong>或门</strong>，产生 INT 信号</p><ol><li><p><strong>原因寄存器（CAUSE）</strong>：如果某个设备发出 IRQ 信号，就会将原因寄存器的相应位设为 1。作用是记录哪些设备发出 IRQ 信号。CAUSE [15:8] 是中断未决位。</p></li><li><p><strong>状态寄存器（SR）：<strong>SR [0] 表示中断允许位（IE），如果 SR [0] 为 0，那么所有 I/O 设备都不能中断处理器</strong>（所有设备的 IE 位都能被 SR [0] 同时改写）</strong>，在这种情况下只能采用轮询访问 I/O 设备；如果 SR [0] 为 1，那么允许所有 I/O 设备中断处理器。CAUSE 和 SR 都是 DLX 的特殊寄存器，只能在<strong>特权模式</strong>下（操作系统）访问。</p></li><li><p><strong>测试 INT 信号：<strong>将指令执行的最后一步改为：写回，并检测 INT 信号。如果 INT 信号为 0，则正常进行下一条指令；若为 1，则</strong>保存并改变程序状态</strong>，之后将 PC 加载为 x80001000，进行<strong>中断服务例程。</strong></p></li></ol><p><strong>・EPC：用于保存中断发生时 PC 中的值</strong></p><p><strong>・SR [0]：进入中断服务例程时，为避免来自其他设备的中断信号的干扰，需要将其清 0。所以 SR [0] 也需要保存起来</strong></p><p><strong>・SR [1]：表示正在运行的程序处于特权（设为 0）还是非特权（设为 1）模式。当进入中断服务例程时，SR [1] 改为 0. 所以 SR [1] 也需要保存</strong></p><p><strong>・中断发生时，SR [2] 保存 SR [0] 的值，SR [3] 保存 SR [1] 的值。</strong></p><ol><li><strong>中断优先级</strong>：有 6 个硬件优先级，PL0,PL1,...PL5，数字越高，优先级越高；速度越高的 I/O 设备，优先级越高。最低的优先级下允许所有中断，最高的优先级下屏蔽所有中断。</li></ol><p>・DLX 的中断优先级采用 SR [15:8]（中断掩码位）表示，与 CAUSE [15:8] 一一对应，从左至右优先级依次降低。CAUSE 中的未决中断要等到相应的屏蔽位为 1 时，才能引起处理器的处理。</p><ol><li>中断服务例程：</li></ol><p><strong>①第一项任务：<strong>将 CAUSE [15:8] 与 SR [15:8] 进行</strong>逻辑与</strong>运算，看发生了哪些允许的中断。如果多于一个，则选择优先级高的</p><p>②服务该中断</p><p><strong>③从中断返回：<strong>首先</strong>清空 CAUSE 寄存器</strong>；接着<strong>使用 RFE 指令</strong>，将 PC 恢复为 EPC 内的值，SR [0] 恢复为 SR [2] 内的值，SR [1] 恢复为 SR [3] 内的值。</p><ol><li><strong>中断嵌套：</strong></li></ol><p>例如，在中断服务例程中进行键盘处理例程时，如果<strong>允许被比键盘优先级高的设备所中断</strong>，那么在读取 KBDR 之前，要先执行：</p><p>①保存 SR,EPC 的值</p><p>②将 SR [15:12] 设为 1，SR [11:8] 设为 0，即屏蔽比当前设备优先级低的中断（键盘优先级为 1），允许优先级高的设备的中断。</p><p>③将 SR [0] 改为 1，即允许中断</p><p>因为改变了 SR [15:8] 和 SR [0] 的值，所以在结束键盘服务例程之前，要<strong>先将 SR [0] 设为 0</strong>，再将<strong> SR 与 EPC 还原</strong>。（使用栈结构存储程序状态）</p><ol><li><strong>C 语言中的 I/O</strong>：scanf: “% d”，“% lf”，从标准输入流的第一个非空白字符（抛弃掉之前的空白，无论这个找到的非空白是否为数字）开始，找到多位数字（至少一位），以 “非数字” 结束（不抛弃，仍然留在输入流中）。</li></ol><h1 id="第十四章-子例程"><a class="anchor" href="#第十四章-子例程">#</a> 第十四章 子例程</h1><ol><li><p>子例程</p></li><li><p>** 调用 / 返回机制：** 计算子例程的起始地址，加载到 PC，并保存返回地址。结束后，使用返回地址加载 PC。与 TRAP 指令相似，R31 被加载返回地址，最后一条指令是 JR R31.</p></li><li><p>** 与 TRAP 指令的区别：**TRAP 指令服务例程包括操作系统资源，由系统程序员编写；子例程由相同程序员或其他人编写</p></li><li><p><strong>JAL 与 JALR 指令（调用子例程指令）：</strong></p></li></ol><p><strong>①JAL：<strong>与</strong> J 指令相同</strong>，不过多了一步<strong>返回地址 -&gt; R31</strong></p><p><strong>汇编格式： JAL LABEL</strong></p><p><strong>②JALR：与 JR 指令相同，<strong>不过多了一步</strong>返回地址 -&gt; R31</strong></p><p><strong>汇编格式： JALR SR1</strong></p><ol><li><p><strong>同样要有寄存器的保存与恢复，与服务例程类似。通常使用被调用者保存。注意 R31 的保存</strong></p></li><li><p>** 使用子例程，必须知道：** 地址、功能（不需要知道具体实现）、传给子例程的值。返回值。（类似 C 语言函数）</p></li><li><p><strong>.extern 伪操作：</strong>.extern SQRT 告诉编译器标记 SQRT 是由其他程序片段（即模块）提供的。要求 SQRT 标记在库例程中被标记为.global SQRT，即可以被其他程序片段所使用。</p></li><li><p><strong>栈</strong>：一种抽象数据类型，<strong>后进先出。PUSH：压栈，POP：出栈</strong></p></li><li><p><strong>在存储器中实现栈：由一组存储单元和 “栈指针”（寄存器 R29）组成</strong>。栈指针即为栈的栈顶，最后压入的元素的存储单元地址。</p></li></ol><p>・每次压栈，栈指针减 4；每次出栈，栈指针加 4</p><p><img data-src="/image/FCS/image13.png" alt="image13.png"></p><p><img data-src="/image/FCS/image14.png" alt="image14.png"></p><p>・返回值不需要压栈；临时寄存器不需要压栈。具体看计算阶乘的例子</p><ol><li><p><strong>为变量分配存储空间</strong>：当寄存器数量不足时，最常用的保存在寄存器里，不常用的放到存储器里。</p></li><li><p>存储器组织：</p></li></ol><p><img data-src="/image/FCS/image15.png" alt="image15.png"></p><p><strong>全局数据区</strong>：全局变量</p><p><strong>帧指针：<strong>R30，栈的基址，理解为当前栈的栈底。也可称作</strong>框架指针，动态链接</strong></p><h1 id="第十五章-函数"><a class="anchor" href="#第十五章-函数">#</a> 第十五章 函数</h1><ol><li><p>函数</p></li><li><p>C 语言中，任何调用者的局部变量对于被调用函数都是不可见的。</p></li><li><p>C 语言的编译过程：预处理、编译、链接</p></li></ol><p><strong>・预处理</strong>：寻找以 “#” 开头的预处理指令。与 DLX 的伪操作相似</p><p><strong>・编译</strong>：产生机器代码</p><p><strong>・链接</strong>：将目标文件与库的目标文件等等链接，生成可执行映像</p><p><img data-src="/image/FCS/image16.png" alt="image16.png"></p><ol><li><strong>寄存器分配约定：</strong></li></ol><p><img data-src="/image/FCS/image17.png" alt="image17.png"></p><ol><li><p><strong>是否允许递归：<strong>即函数是否允许调用它本身。C 语言允许。编译器为每一次函数调用分配一个</strong>活动记录</strong>。每一次函数调用都会在存储器中为其局部数值获得它自己的空间，返回时活动记录将被回收。通过 “** 运行时栈”** 实现活动记录的分配。</p></li><li><p><strong>函数调用机制：</strong></p></li></ol><p><strong>①调用函数</strong>使用参数寄存器保存变元（应该就是传给被调用函数的值）。如果大于 4 个，将其分配到运行时栈。（在函数调用前完成）</p><p><strong>②被调用函数</strong>完成活动记录的分配：将一些寄存器的值保存到运行时栈中 —— 寄存器的保存；如果局部变量寄存器不足，将局部变量压入运行时栈。</p><p><strong>③被调用函数</strong>执行任务</p><p><strong>④被调用函数</strong>完成工作时，活动记录从栈中弹出，并且控制返回到调用函数</p><p><strong>⑤调用函数</strong>的控制返回后，执行代码取回被调用函数的<strong>返回值</strong></p><ol><li><p><strong>函数调用结束时的出栈：要按顺序，后进先出：<strong>弹出变元（如果函数内部还调用了其他函数），弹出局部变量，恢复</strong>保存的寄存器</strong>，恢复<strong>动态链接（R30）</strong>，恢复<strong>返回地址（R31），最后 JR R31。<strong>控制返回后，再取得</strong>返回值</strong></p></li><li><p><strong>如无必要，可以不保存 R31，可以不使用 R30</strong></p></li></ol><h1 id="第十六章-指针和数组"><a class="anchor" href="#第十六章-指针和数组">#</a> 第十六章 指针和数组</h1><ol><li><p>指针和数组</p></li><li><p><strong>数组：<strong>在存储器中连续存储。在 [] 中提供下标，即偏移量。同样是</strong>基址 + 偏移量</strong>的表示方式。<strong>数组的名字</strong>即为数组的基址，但数组名不能被重新赋值。</p></li></ol><p>・注意数组越界</p><ol><li><strong>二维数组</strong>：一行一行地存储。a [n] 代表着第 n 行的首地址</li></ol><p>int p [4][4]：p 类型为 *<em>int (<em>p)[4] ，指向一维数组的指针，或者也可以说是指向指针的指针</em></em></p><p>p+i: 第 i 行地址，但实际与下面那个意思不一样</p><p>*<strong>(p+i) &lt;=&gt; p[i]</strong>，第 i 行首地址（第一个数据的地址）</p><p>*<strong>((p+i)+j) &lt;=&gt; p[i][j]</strong></p><p><strong>・DLX 通路：</strong></p><p><img data-src="/image/FCS/image18.png" alt="image18.png"></p><div class="tags"><a href="/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" rel="tag"><i class="ic i-tag"></i> 复习资料</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-01-12 16:16:01" itemprop="dateModified" datetime="2025-01-12T16:16:01+08:00">2025-01-12</time> </span><span id="2025/01/12/FCS/" class="item leancloud_visitors" data-flag-title="计算系统基础知识点复习整理" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.jpg" alt="北沐清 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.jpg" alt="北沐清 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>北沐清 <i class="ic i-at"><em>@</em></i>北沐清的博客</li><li class="link"><strong>本文链接：</strong> <a href="https://erinwithbmq.github.io/2025/01/12/FCS/" title="计算系统基础知识点复习整理">https://erinwithbmq.github.io/2025/01/12/FCS/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2025/01/12/CPL/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;dlink.host&#x2F;wx2.sinaimg.cn&#x2F;large&#x2F;006w2xCxly8hxh5mxmz8aj311n0rsgqm.jpg" title="C语言部分知识点整理"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> CPL</span><h3>C语言部分知识点整理</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">第六章</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0"><span class="toc-number">2.</span> <span class="toc-text">第七章</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%86%AF%E6%B4%9B%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">第八章 冯・洛依曼模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">第九章 指令集结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%9C%BA%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">第十章 机器程序语言设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-number">6.</span> <span class="toc-text">第十一章 汇编语言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">7.</span> <span class="toc-text">第十二章 输入输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E8%87%AA%E9%99%B7%E4%BE%8B%E7%A8%8B%E5%92%8C%E4%B8%AD%E6%96%AD"><span class="toc-number">8.</span> <span class="toc-text">第十三章 自陷例程和中断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%AD%90%E4%BE%8B%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">第十四章 子例程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">第十五章 函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">11.</span> <span class="toc-text">第十六章 指针和数组</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2025/01/12/FCS/" rel="bookmark" title="计算系统基础知识点复习整理">计算系统基础知识点复习整理</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="北沐清" data-src="/images/avatar.jpg"><p class="name" itemprop="name">北沐清</p><div class="description" itemprop="description">Per Aspera, Ad Astra.</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">29</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">9</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">5</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VyaW53aXRoQk1R" title="https:&#x2F;&#x2F;github.com&#x2F;ErinwithBMQ"><i class="ic i-github"></i></span> <a href="/erinwithbmq@gmail.com" title="erinwithbmq@gmail.com" class="item email"><i class="ic i-envelope"></i></a> <span class="exturl item youtube" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMzg3ODczMTM=" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;38787313"><i class="ic i-youtube"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" title="分类于 南京大学软件工程专业课程">南京大学软件工程专业课程</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" title="分类于 大二上">大二上</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" title="分类于 互联网计算">互联网计算</a></div><span><a href="/2025/01/11/CN2/" title="计网第二章 物理层">计网第二章 物理层</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" title="分类于 南京大学软件工程专业课程">南京大学软件工程专业课程</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" title="分类于 大二上">大二上</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" title="分类于 互联网计算">互联网计算</a></div><span><a href="/2025/01/11/CN4/" title="计网第四章 网络层">计网第四章 网络层</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" title="分类于 南京大学软件工程专业课程">南京大学软件工程专业课程</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%B8%80%E4%B8%8A/" title="分类于 大一上">大一上</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%B8%80%E4%B8%8A/%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" title="分类于 计算系统基础">计算系统基础</a></div><span><a href="/2025/01/12/FCS/" title="计算系统基础知识点复习整理">计算系统基础知识点复习整理</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/01/11/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" title="分类于 南京大学软件工程专业课程">南京大学软件工程专业课程</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" title="分类于 大二上">大二上</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" title="分类于 互联网计算">互联网计算</a></div><span><a href="/2025/01/11/CN6/" title="计网第六章 会话、表示、应用层">计网第六章 会话、表示、应用层</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" title="分类于 南京大学软件工程专业课程">南京大学软件工程专业课程</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" title="分类于 大二上">大二上</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" title="分类于 互联网计算">互联网计算</a></div><span><a href="/2025/01/11/CN7/" title="计网第七章 路由与路由器">计网第七章 路由与路由器</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" title="分类于 南京大学软件工程专业课程">南京大学软件工程专业课程</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" title="分类于 大二上">大二上</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/" title="分类于 计算机组织结构">计算机组织结构</a></div><span><a href="/2025/01/11/COA11/" title="计组期末复习第十一讲 虚拟存储器">计组期末复习第十一讲 虚拟存储器</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" title="分类于 南京大学软件工程专业课程">南京大学软件工程专业课程</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" title="分类于 大二上">大二上</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" title="分类于 互联网计算">互联网计算</a></div><span><a href="/2025/01/11/CN11/" title="计网第十一章 网络安全">计网第十一章 网络安全</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" title="分类于 南京大学软件工程专业课程">南京大学软件工程专业课程</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" title="分类于 大二上">大二上</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" title="分类于 互联网计算">互联网计算</a></div><span><a href="/2025/01/11/CN10/" title="计网第十章 广域网">计网第十章 广域网</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%87%86%E5%A5%8E/" title="分类于 准奎">准奎</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%87%86%E5%A5%8E/%E5%90%8C%E4%BA%BA%E6%96%87/" title="分类于 同人文">同人文</a></div><span><a href="/2025/01/11/HappyDreamWonderland/" title="Happy Dream Wonderland">Happy Dream Wonderland</a></span></li></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">北沐清 @ ErinwithBMQ's Blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">131k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:59</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2025/01/12/FCS/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->