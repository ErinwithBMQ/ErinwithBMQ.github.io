<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>北沐清的博客</title>
        <subtitle>Welcome to My Wonderland</subtitle>
        <icon>https://erinwithbmq.github.io/images/favicon.ico</icon>
        <link>https://erinwithbmq.github.io</link>
        <author>
          <name>北沐清</name>
        </author>
        <description>Per Aspera, Ad Astra.</description>
        <language>zh-CN</language>
        <pubDate>Sun, 12 Jan 2025 15:53:00 +0800</pubDate>
        <lastBuildDate>Sun, 12 Jan 2025 15:53:00 +0800</lastBuildDate>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/12/FCS/</guid>
            <title>计算系统基础知识点复习整理</title>
            <link>https://erinwithbmq.github.io/2025/01/12/FCS/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大一上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%B8%80%E4%B8%8A/" />
            <category term="计算系统基础" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%B8%80%E4%B8%8A/%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sun, 12 Jan 2025 15:53:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;计算系统基础知识点复习整理&lt;/p&gt;
&lt;p&gt;整理者：ErinwithBMQ&lt;/p&gt;
&lt;h1 id=&#34;第六章&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第六章&#34;&gt;#&lt;/a&gt; 第六章&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原码反码补码计算&lt;/strong&gt;：正数的三个码都一样；负数的反码补码才和原码不一样，反码直接取反，补码取反加 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;负数二进制位数扩展是&lt;strong&gt;在前面加 1&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;32 位 IEEE 标准浮点数&lt;/strong&gt;：第 31 位为符号， &lt;code&gt;23~30&lt;/code&gt;  位（共 8 位）为指数（转化为无符号整数，然后减 127，即为 2 的多少次方）， &lt;code&gt;0~22&lt;/code&gt;  位（共 23 位）为尾数，即 1.…… 后面的省略号部分。如果想正常表示一个数，符号位既不能最大（为 255，所有位都是 1），也不能最小（0）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;非规格化浮点数（指数位全为 0）&lt;/strong&gt;：2 的次方：1 - 127 =-126；隐藏位为 0，即为 0.……。用这个方式可以表示&lt;strong&gt;小于 2^-126 的数字&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;64 位 IEEE 标准浮点数&lt;/strong&gt;：第 63 位为符号， &lt;code&gt;52~62&lt;/code&gt;  位（共 11 位）为指数（减 1023）； &lt;code&gt;0~51&lt;/code&gt; （共 52 位）为尾数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;将十进制小数转换为 IEEE 标准浮点数&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）先将小数写成&lt;strong&gt;普通二进制&lt;/strong&gt;（如果是负数，写其&lt;strong&gt;绝对值&lt;/strong&gt;，在后面转化为浮点数时将最高位设成 1 即可）。&lt;/p&gt;
&lt;p&gt;（2）将普通二进制转化为规格化二进制，如 00101101.1101 -&amp;gt; 1.011011101 * 2^5&lt;/p&gt;
&lt;p&gt;（3）将规格化二进制转化为 32 位 IEEE 标准浮点数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1.11111111111111111111111（二进制）约等于 2&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;第七章&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第七章&#34;&gt;#&lt;/a&gt; 第七章&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;与运算 A・B，或运算 A+B （・可省去）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;德摩根定律及其他定律&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image1.png&#34; alt=&#34;image1.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;分配律，吸收律，德摩根定律，其他恒等式重要。其实除了德摩根，其他三个都能通过上面基本的推出来&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;按位取反：&lt;strong&gt;与 11111111 作&lt;/strong&gt;按位异或运算&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;C 语言中的位运算符&lt;/strong&gt;：&amp;amp; 与运算，| 或运算，~ 非运算，^ 异或运算，&amp;lt;&amp;lt;左移，&amp;gt;&amp;gt; 右移&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算数 / 逻辑左移、逻辑右移都是用 0 填充；&lt;strong&gt;算数右移&lt;/strong&gt;，正数用 0 填充，负数用 1 填充&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运算符优先级&lt;/strong&gt;：~&lt;strong&gt; 非运算 &amp;gt;&amp;gt;&amp;gt;/&amp;lt;&amp;lt;左移右移&amp;gt;&amp;amp; 与 &amp;gt;^ 异或 &amp;gt;| 或&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NMOS 晶体管&lt;strong&gt;漏极接正极&lt;/strong&gt; VDD，&lt;strong&gt;源极接负极&lt;/strong&gt; VSS；PMOS 与其相反。NMOS&lt;strong&gt; 接入正电压&lt;/strong&gt;导通，PMOS&lt;strong&gt; 接入负电压&lt;/strong&gt;导通。PMOS 管的&lt;strong&gt;栅极会加个圆&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般都是&lt;strong&gt;栅极输入&lt;/strong&gt;，&lt;strong&gt;漏极输出&lt;/strong&gt;，源极接电源正极或接地&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;非门&lt;/strong&gt;：上下 PMOS 与 NMOS 管相连&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;或非门：&lt;strong&gt;顶部两个 PMOS 管&lt;/strong&gt;串联&lt;/strong&gt;，下面两个 NMOS 管&lt;strong&gt;并联&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;或门&lt;/strong&gt;：在或非门输出前再加一个非门&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与非门：&lt;strong&gt;顶部两个 PMOS 管&lt;/strong&gt;并联&lt;/strong&gt;，下面两个 NMOS 管&lt;strong&gt;串联&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与门&lt;/strong&gt;：在与非门输出前再加一个非门&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;符号表示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image2.jpeg&#34; alt=&#34;image2.jpeg&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;译码器&lt;/strong&gt;：输入少，输出多。&lt;strong&gt;n 个输入，2^n 个输出&lt;/strong&gt;。如 2-4 线译码器，3-8 线译码器，&lt;strong&gt;只有一个输出有效&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多路选择器&lt;/strong&gt;：n 条选择线， &lt;code&gt;2^n&lt;/code&gt;  个输入。由选择信号 S 决定哪个输入连接到输出。上面 &lt;code&gt;2^n&lt;/code&gt;  个与门，下面一个或门。与门前非门情况不同（主要区分在这）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;加法器&lt;/strong&gt;：（1）&lt;strong&gt;半加器&lt;/strong&gt;：两个输入，两个输出（S 表示和，C 表示进位），分别是一个异或门和一个与门。符号是求和号加 CO&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（2）&lt;strong&gt;全加器&lt;/strong&gt;：三个输入，两个输出（S 表示和，C 表示进位）。上面两个异或门，AB 异或完的结果与 C 再异或；下面两个与非门，AB 与非，AB 异或结果与 C 与非，二者再与非一次。符号是求和号加 CO 加 CI&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数值比较器：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image3.png&#34; alt=&#34;image3.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;左边两个是非门&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用与或非表示异或与与或：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image4.jpeg&#34; alt=&#34;image4.jpeg&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;R-S 锁存器&lt;/strong&gt;：由两个与非门（或者或非门）组成。工作原理是设置 R、S 来控制电路状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;R：复位引脚   S：置位引脚。有两个输出 a、b（重点看 a）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image5.png&#34; alt=&#34;image5.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;S：1  R：1 ：保持状态（保持现有 a 的值）&lt;/p&gt;
&lt;p&gt;S：1  R：0 ：“复位 / 置 0” 状态（将 a 变为 0）&lt;/p&gt;
&lt;p&gt;S：0  R：1 ：“置位 / 置 1” 状态（将 a 变为 1）&lt;/p&gt;
&lt;p&gt;S：0  R：0 ：错误&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果是两个或非门：SR 都为 0 时保存 a，都为 1 时错误。其他相同。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;门控 D 锁存器&lt;/strong&gt;：输入控制门电路（两个与非门）+ R-S 锁存器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两个输入：WE 与 D&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WE = 1 时，输出（a） = D&lt;/strong&gt;;&lt;strong&gt;WE = 0，S = R = 1，输出状态不变&lt;/strong&gt;（保持 a 的值）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image6.png&#34; alt=&#34;image6.png&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主从 D 触发器&lt;/strong&gt;：由两个门锁 D 锁存器构成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;时序逻辑电路：找有几个状态，以及到各个状态的条件&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;第八章-冯洛依曼模型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第八章-冯洛依曼模型&#34;&gt;#&lt;/a&gt; 第八章 冯・洛依曼模型&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;冯・洛依曼模型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;组成部分&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image7.png&#34; alt=&#34;image7.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理单元与控制单元是 CPU 的主要组成部分&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;存储器（RAM）&lt;/strong&gt;：包括基本存储原件、寄存器与主存储器，其中寄存器读取速度最快。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;寻址能力&lt;/strong&gt;：存储在每一个单元中信息的位数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2^32×8&lt;/code&gt;  位：一共有 &lt;code&gt;2^32&lt;/code&gt;  个存储单元（&lt;strong&gt;地址空间，唯一可识别的单元总数&lt;/strong&gt;），每个存储单元可以存 8 位（&lt;strong&gt;寻址能力，8 位为字节可寻址&lt;/strong&gt;）。总量 4GB&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SRAM&lt;/strong&gt;：静态随机访问存储器，供电状态下能一直保存；&lt;strong&gt;DRAM&lt;/strong&gt;：动态随机访问存储器，需要不断刷新，而且关机会丢失数据。&lt;/p&gt;
&lt;p&gt;・访问其存储器的一个单元需要 n 位 / 使用 n 位地址：&lt;strong&gt;地址空间为 2^n&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;・8 位为 1 字节；4 字节为 1 字长（DLX 指令集）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;4×2 位存储器实例&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image8.jpeg&#34; alt=&#34;image8.jpeg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;（1）4×2 位：存储空间为 4（4 个单元），寻址能力为 2 位（一个单元里有 2 位数据）&lt;/p&gt;
&lt;p&gt;（2）注意谁是地址线，谁是字线&lt;/p&gt;
&lt;p&gt;（3）有一个译码器和两个多路选择器&lt;/p&gt;
&lt;p&gt;（4）&lt;/p&gt;
&lt;p&gt;A：地址，选择存入 / 输出哪个地址的内容&lt;/p&gt;
&lt;p&gt;WE：1 为存储数据，0 为读取数据&lt;/p&gt;
&lt;p&gt;D：输入   Q：输出&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理单元&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;算术与逻辑处理单元 ALU&lt;/strong&gt;：ALU 一次正常处理的信息量大小通常被称为计算机的&lt;strong&gt;字长&lt;/strong&gt;，每一次被处理的元素被称为一个&lt;strong&gt;字&lt;/strong&gt;。每一个指令集结构都有自己的字长。&lt;strong&gt;DLX 是 32 位（4 个字节）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;寄存器堆 / 文件 Reg&lt;/strong&gt;：功能是临时存取数据，因为其读取速度很快；&lt;strong&gt;每个寄存器都包含一个字。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;控制单元 PC&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;功能：指挥信息的处理；跟踪指令的执行&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PC：程序计数器 / 指令指针。控制单元中容纳下一条指令所在地址的寄存器。功能是跟踪要处理的下一条指令。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;输入 / 输出设备：外围设备&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DLX 示例&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;总线结构，多时钟周期&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;寄存器（32 位）：寄存器堆 / 文件，程序计数器 PC，指令寄存器 IR&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多路选择器：有 DRMUX，AMUX，BMUX&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;总线：由 32 根线和相关电子元件组成。允许传输 32 位信息，一次只可传输一个值&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;存储器：MAR，主存地址寄存器，保存目的位置或数据来源位置的地址；MDR，主存数据寄存器，保存被写入地址或地址单元读入的数据（都是 32 位，一个字长）。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;存储器是 2^32 个存储单元，字节可寻址。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;简单来说就是，MAR 存地址，MDR 存地址中对应的数据（要么是以其地址开头连续四个单元的数据，要么是 8 位扩展成 32 位）。如果要写入数据，那就是将 MDR 中的数据写入 MAR 存的地址对应的存储单元里&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理单元： ALU 与寄存器堆。有 32 个整数寄存器，32 个浮点寄存器（DLX 子集没有这个）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;控制单元：①有限状态机，一个输入是 CLK，说明每个时钟周期持续的时间。②指令寄存器 IR，保存正在处理的指令，同时也是有限状态机的一个输入。③程序计数器 PC，记录下一条要被执行的指令所在的地址&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实心箭头：数据元素；空心箭头：控制信号&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;输入 / 输出设备：键盘：数据寄存器 KBDR，状态寄存器 KBSR；显示器：显示寄存器 DDR，状态寄存器 DSR。详见第十二章&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;第九章-指令集结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第九章-指令集结构&#34;&gt;#&lt;/a&gt; 第九章 指令集结构&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;指令集结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;指令集结构 ISA：操作码＋操作数。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;操作码：让计算机执行的操作。DLX 中分为算数 / 逻辑运算指令，数据传送指令，控制指令，浮点指令四种（按功能分）。&lt;/p&gt;
&lt;p&gt;操作数：数据类型；DLX 中的&lt;strong&gt;寻址方式 —— 基址＋偏移量&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DLX 指令操作类型&lt;/strong&gt;：共 64 种指令类型，由 [31:26] 位定义（6 位），其中又分为 R 类型、I 类型、J 类型，总共有 91 条指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;R 类型指令：[31:26] 位为 000000，[5:0] 位定义了函数，共 64 中可能的函数&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;算数 / 逻辑运算指令&lt;/strong&gt;：对整数进行处理；共有 37 个算术逻辑运算指令；除 LHI 加载高位立即数指令外，其他都是进行的二元运算，即两个源操作数和一个目标操作数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;第一个源操作数&lt;/strong&gt;：来自 32 个整数寄存器，[25:21] 位对应寄存器，SR1。如 R1 即为 00001，R5 即为 00011。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个源操作数&lt;/strong&gt;：I 类型（立即数类型）：[15:0] 位直接读取立即数（补码）；R 类型：[20:16] 位对应寄存器，SR2。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标操作数&lt;/strong&gt;：I 类型：[20:16] 对应寄存器，DR；R 类型：[15:11] 位对应寄存器，DR。（SR1、SR2、DR 可以相同）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ADDI：使用立即数的相加指令。将 SR1 内数值与立即数相加存入 DR 中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SUBI：使用立即数的相减指令。将 SR1 内数值与立即数相减存入 DR 中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ANDI：使用立即数的与运算指令。将 SR1 内数值与立即数进行与运算存入 DR 中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ORI：或运算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XORI：异或运算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SLEI：设置是否小于等于操作。若 SR1 中数值小于等于立即数，则 DR 设为 1，否则为 0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SLTI：设置是否小于操作。若 SR1 中数值小于立即数，则 DR 设为 1，否则为 0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SEQI：设置是否相等条件操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SRAI：算术右移立即数操作。将 SR1 中数值立即右移立即数对应的位数存入 DR。注意负数是补 1。可用来表示一些除法如除 2 除 4 等&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SRLI：逻辑右移立即数，道理同上，不过负数补 0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SLLI：左移立即数。用来表示乘法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LHI：加载高位立即数指令。没有 SR1（全为 0），只有 DR。将立即数左移 16 位后加载至 DR 中。如立即数原来为 x1234（本来就只有 16 位），左移 16 位变为 x12340000 加载至 DR 中。（DR 是 32 位的）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;R 类型操作指令：将上面的立即数全部变为 SR2 内存的数值，去掉 I（如 ADD、SUB）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;除 LHI 指令，其他运算指令均有 I 类型和 R 类型&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据传送指令：基址寄存器 + 偏移量&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;LW：字加载指令。将 SR1 内数值加上立即数得到一个地址，将以该地址为起始地址的连续四个单元内的数值（一个字）加载至 DR 中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LB：字节加载指令。将 SR1 内数值加上立即数得到一个地址，将以该地址内的数值（一个字节）加载至 DR 中。前面不足的位数补全（负数应该还是用 1 补吧？）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SW：字存储指令。将 SR1 内数值加上立即数得到一个地址，将 DR 中的数值（一个字）存储到以该地址为起始地址的连续四个单元中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SB：字节存储指令。将 SR1 内数值加上立即数得到一个地址，将 DR 中的最低八位（一个字节）存储到以该地址对应的单元中。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;R0：绝对地址。里面的数值只能全是 0，不可以改变&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;边界对齐：LW、SW 指令里基址＋偏移量的地址必须是 4 的倍数（因为加载存储的是字）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;另外，地址用十六进制表示，立即数是二进制，加的时候注意一下&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运算指令与数据传送指令每次使 PC＋4. 因为一条指令占用 4 个存储单元（一个存储单元 8 位，一条指令 32 位）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;控制指令：改变被执行的指令的顺序&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;①条件分支：仅使用 SR1。分为 BEQZ（等于 0 时分支）和 BNEZ（不等于 0 时分支）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;取指令阶段：PC+4（这时 PC 已经是下一条指令的地址了）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译码 / 取寄存器：接着计算 PC（已经加过 4）+ 立即数，得出目标指令地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完成分支阶段：BEQZ：若 SR1 为 0，则将上一步得到地址加载至 PC；若 SR1 不为 0，PC 不变，正常进入下一条指令。（BNEZ 与其相反）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②无条件跳转指令：JR 指令与 J 指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JR：DR、立即数全为 0，仅使用 SR1。将 SR1 内的数值加载到 PC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;J：[25:0] 的数值＋4＋PC-&amp;gt; PC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③TRAP 指令：改变 PC，是它指向属于操作系统的某部分的存储地址，作用是让操作系统执行一些任务 —— 调用服务例程。（见后面章节）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;DLX 指令处理&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image9.png&#34; alt=&#34;image9.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存储器&lt;/strong&gt;：地址空间 2^32（即 4G）个单元。地址标识符是 32 位二进制，或 8 位十六进制。寻址能力是 8 位。访问字只需访问其&lt;strong&gt;起始地址&lt;/strong&gt;，但需要是 4 的倍数，即&lt;strong&gt;边界对齐&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;高位优先&lt;/strong&gt;，字的高位字节放在内存的低地址端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;寄存器&lt;/strong&gt;：每一个寄存器中的存储位数是 32 位的字。有 32 个通用寄存器，5 位编码识别。其中，R0 内必须是 0. 还有 32 个浮点寄存器，标记为 F0、F1…… 单精度浮点数一个寄存器，双精度浮点数两个寄存器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指令处理：多时钟周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DLX 指令执行阶段：①取指令 ②译码 / 取寄存器 ③执行 / 有效地址 / 完成分支 ④访问内存 ⑤存储结果。每条指令需要进行其中的 3-5 个阶段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DLX 的有限状态机：每一步都是由控制单元的有限状态机控制，一个周期接一个周期地控制整个程序执行。以时钟周期为单位持续运行指令，停止时钟（运行锁清 0），则停止指令的运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DLX 运行示例&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;取指令阶段&lt;/strong&gt;：①PC -&amp;gt; MAR；ALU 中进行 PC+4 的计算  ②PC+4 -&amp;gt; PC；M [MAR] -&amp;gt; MDR  ③MDR -&amp;gt; IR&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;译码 / 取寄存器阶段：&lt;strong&gt;①使用指令的操作码，进行译码，控制指令执行 ②根据指令取寄存器，获得源操作数传给&lt;/strong&gt; ALU 的寄存器 A 和寄存器 B&lt;/strong&gt;③在 ALU 中计算 PC＋IR [15:0] 符号扩展的和，将结果存储在 ALUOut 寄存器中（可能该结果没有用，但是还会进行）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行 / 有效地址 / 完成分支&lt;/strong&gt;：三种选择（选择其一）：①执行算数 / 逻辑运算，结果存储在 ALUOut 中 ②计算有效地址，结果存储在 ALUOut 中 ③完成分支跳转&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问内存：&lt;/strong&gt;（如果要访问内存的话）ALUOut -&amp;gt; MAR；M [MAR]（该地址开头四个单元的数据） -&amp;gt; MDR&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;存储结果&lt;/strong&gt;：将结果写到目标（应该是 DR）中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;第十章-机器程序语言设计&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第十章-机器程序语言设计&#34;&gt;#&lt;/a&gt; 第十章 机器程序语言设计&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;机器程序语言设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I 类型指令和 R 类型指令分别的特点：I 类型可以访问内存，但速度较慢；R 类型是寄存器之间的操作，不能访问内存，速度较快&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三种基本结构：顺序、选择、循环&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;・选择中 J 指令的立即数：子任务 1 的指令数目乘 4&lt;/p&gt;
&lt;p&gt;・循环中 J 指令是返回生成条件指令&lt;/p&gt;
&lt;h1 id=&#34;第十一章-汇编语言&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第十一章-汇编语言&#34;&gt;#&lt;/a&gt; 第十一章 汇编语言&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;汇编语言&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;汇编语言四个部分&lt;/strong&gt;：标记 操作码 操作数；注释。其中，标记与注释可选。不区分大小写。注释前要加；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标记：&lt;strong&gt;以字母、下划线或 $ 开头，中间可包含下划线、字母或数字，&lt;strong&gt;以冒号结尾&lt;/strong&gt;；操作码作为保留字，不能用做标记。标记用作立即数代表的是&lt;/strong&gt;这条指令的地址&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;操作码&lt;/strong&gt;：如 ADD，ADDI…… 指令操作码的符号名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;操作数&lt;/strong&gt;：寄存器则写 R0、R1…… 立即数前面加 #表示十进制，x 表示十六进制，b 表示二进制，如 #10，x16 等。&lt;strong&gt;与机器语言不同，汇编指令中 DR 在前面，SR1 在后面&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运算指令&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;I 类型汇编指令格式：OPCODE  DR, SR1, Imm16   立即数也可以是标记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;R 类型汇编指令格式：OPCODE  DR, SR1, SR2&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LHI：LHI  DR, Imm16&lt;/strong&gt; 立即数可以是标记，&lt;strong&gt;此时是将标记对应地址的高 16 位值赋给 DR，如地址是 x30001A00，则赋值 x30000000&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据传送指令：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;LW/LB  DR, Imm16(SR1)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SW/SB  Imm16(SR1), DR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;立即数可以使用标记&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;控制指令：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;BEQZ/BNEZ：OPCODE  SR1, LABEL   最后是标记，即目标地址。此时不需要再计算 PC+4 + 立即数。而是符合要求就直接跳转到标记地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;J：J  LABEL   直接跳转到标记地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JR：JR  SR1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TRAP：TRAP  Imm&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;伪操作：以。作为第一个字符&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;数据区：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;①.dataaddress&lt;/strong&gt; : 将下面的数据放在数据区的某一个地方（address 为其起始地址）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，该地址必须是 4 的倍数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果不是 4 的倍数：.alignn : 将下面的数据加载到以 n 个 0 结尾的地址里&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②.wordword1, word2, ... : 将字 1，字 2，…… 存储在连续的存储单元中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③.bytebyte1, byte2, ... : 将字节 1，字节 2，…… 存储在连续的存储单元中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;④.ascii “string1”,“string2”, ... : 将字符串 1，字符串 2，…… 存储在存储器中。.asciiz 与其相似，不同是 .asciiz 会在字符串结尾再存储一个 0.（相当于 C 语言中的 \0）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⑤.spacesize: 预留空间，留出 size 个字节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码区：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① .textaddress : 将指令放在存储器的某个地方。不是 4 的倍数时也要用.align&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②.globallabel : 全局标记，让该标记在其他文件中也可以使用&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;汇编过程：&lt;/strong&gt;“两趟” 扫描：第一趟，标识出符号（标记）对应的二进制地址，建立&lt;strong&gt;符号表&lt;/strong&gt;；第二趟，把汇编指令翻译成机器指令。此时使用&lt;strong&gt;地址计数器 LC（它与程序计数器 PC 的不同：LC 是当前地址，PC 是下一条指令的地址）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;立即数是标记&lt;/strong&gt;的 ADDI 指令，&lt;strong&gt;如果地址无法用 16 位的立即数表示&lt;/strong&gt;，解决方法：翻译成两条指令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如，addi R1, R0, numbers，numbers 为 x3000000C，将其拆分成两条语句翻译：&lt;/p&gt;
&lt;p&gt;LHI   R1, x3000&lt;/p&gt;
&lt;p&gt;ADDI  R1, R0, x000C&lt;/p&gt;
&lt;p&gt;注意接下来是 LC+8 而不是 + 4。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;立即数是标记的 SW 指令&lt;/strong&gt;：如  SW sum (R0), R3 ，sum 是 x30000034&lt;/p&gt;
&lt;p&gt;翻译成两条指令：LHI R5 x3000    SW x0034 (R5), R3  （&lt;strong&gt;使用临时寄存器 R5&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;LC+8 -&amp;gt; LC&lt;/p&gt;
&lt;p&gt;翻译成多条指令后，符号表也需要调整&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;寄存器分配规则&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image10.png&#34; alt=&#34;image10.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;变量多于寄存器数目时，就要使用存储器。—— 第十四章，栈的存储结构&lt;/p&gt;
&lt;h1 id=&#34;第十二章-输入输出&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第十二章-输入输出&#34;&gt;#&lt;/a&gt; 第十二章 输入输出&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入和输出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;** 键盘和显示器：** 面向流的设备，一个字符一个字符地按顺序读写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;键盘设备寄存器：&lt;strong&gt;32 位。KBDR 键盘数据寄存器：只有&lt;/strong&gt; [7:0] 用来存放数据（一个字节）&lt;/strong&gt;，其他都是 0；KBSR 键盘状态寄存器：[0] 位，就绪位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;** 显示器设备寄存器：**32 位。DDR 键盘数据寄存器：只有 [7:0] 用来存放数据（一个字节），其他都是 0；DSR 键盘状态寄存器：[0] 位，就绪位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;** 内存映射的 I/O：** 采用内存映射的方式表示 I/O 设备。比如，xFFFF0000——xFFFF0003，不再是存储器里的某个数据的地址，而是代表 KBSR 的地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;R.W=0：加载信号；R.W=1：存储信号（？）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;异步的处理与同步机制&lt;/strong&gt;：需要状态寄存器。KBSR [0] 为 1 时，键盘不能用；当读取完上一个输入的字符时，KBSR [0] 清 0，允许读入下一个字符。KBSR [0] 为 0 时，代表没有新的字符输入，不进行后面的读取操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每当显示器完成了一个字符的显示，就将 DSR [0] 设为 1，允许进行下一个字符的显示；每当处理器正在向显示器写字符时，将 DSR [0] 设为 0，不进行新的显示字符的操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;轮询机制&lt;/strong&gt;：周期性检查状态位。缺点是浪费时间。—— 中断机制的出现&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;第十三章-自陷例程和中断&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第十三章-自陷例程和中断&#34;&gt;#&lt;/a&gt; 第十三章 自陷例程和中断&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;自陷例程和中断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自陷 (TRAP) 指令 —— 系统调用，通过调用操作系统来完成任务&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image11.png&#34; alt=&#34;image11.png&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;TRAP 机制 1—— 服务例程&lt;/strong&gt;：操作系统的一部分，代表用户执行的一组程序。DLX 有 256 个服务例程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image12.png&#34; alt=&#34;image12.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;几个常见的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;**TRAP 机制 2——TRAP 向量表：&lt;strong&gt;包括了 256 个&lt;/strong&gt;服务例程的起始地址（实际是代码区的起始地址）** 的表，每个起始地址占用四个存储单元（32 位）。这张表被存储在存储单元的 x0000 0000 到 x0000 03FF 中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;・数据区与代码区：数据区的起始地址在代码区起始地址&lt;strong&gt;之前的 x100 个单元&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;TRAP 机制 3——TRAP 指令：&lt;strong&gt;调用操作系统代表用户程序执行某一服务例程，完成后把控制权还给用户程序。根据 TRAP 向量，&lt;strong&gt;相应服务例程首地址 -&amp;gt; PC&lt;/strong&gt;，并且要记得&lt;/strong&gt;提供返回路径。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;TRAP 指令处理：①取指令：&lt;strong&gt;PC + 4 -&amp;gt; PC。②译码&lt;/strong&gt;③计算有效地址：&lt;strong&gt;TRAP 向量（26 位）扩展成 32 位，再&lt;/strong&gt;左移 2 位（乘以 4）④TRAP 向量（计算后） -&amp;gt; MAR，M [MAR] -&amp;gt; MDR。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⑤写回：PC -&amp;gt; R31（提供返回路径），MDR -&amp;gt; PC（开始服务例程）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 TRAP 服务例程中，最后一条指令是 &lt;strong&gt;JR R31&lt;/strong&gt;，使得控制返回用户程序的正确位置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;寄存器的保存与恢复：&lt;strong&gt;①被调用者保存：在服务例程内部的一开始进行保存&lt;/strong&gt; &lt;strong&gt;②调用者保存：在调用服务例程前进行保存&lt;/strong&gt;，一般出现在服务例程内部调用另一个服务例程之前，而且保护的一般是 R31（调用服务例程时会将 R31 改掉）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;原则是&lt;/strong&gt;哪个程序知道哪些寄存器被接下来的操作所破坏，处理问题的就应该是哪一个程序。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;停机服务例程&lt;/strong&gt;（TRAP x00）：MCR [0]：机器控制寄存器，有内存映射地址。要将其清 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中断驱动的 I/O&lt;/strong&gt;：I/O 设备能够强制程序中止，让处理器执行 I/O 设备的请求；请求完成后让停止的程序继续进行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中断信号（INT）的产生&lt;/strong&gt;：满足两个条件：&lt;strong&gt;①KBSR,DSR 的就绪位为 1&lt;/strong&gt;，表示需要服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;②中断允许位（IE）&lt;/strong&gt;，大多数设备中是设备状态寄存器的一部分。设为 1 或 0，取决于是否给其权利去请求服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中断请求信号（IRQ）&lt;strong&gt;是&lt;/strong&gt;就绪位与 IE 的逻辑与；&lt;strong&gt;各个设备发出的 IRQ 经过&lt;/strong&gt;或门&lt;/strong&gt;，产生 INT 信号&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原因寄存器（CAUSE）&lt;/strong&gt;：如果某个设备发出 IRQ 信号，就会将原因寄存器的相应位设为 1。作用是记录哪些设备发出 IRQ 信号。CAUSE [15:8] 是中断未决位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态寄存器（SR）：&lt;strong&gt;SR [0] 表示中断允许位（IE），如果 SR [0] 为 0，那么所有 I/O 设备都不能中断处理器&lt;/strong&gt;（所有设备的 IE 位都能被 SR [0] 同时改写）&lt;/strong&gt;，在这种情况下只能采用轮询访问 I/O 设备；如果 SR [0] 为 1，那么允许所有 I/O 设备中断处理器。CAUSE 和 SR 都是 DLX 的特殊寄存器，只能在&lt;strong&gt;特权模式&lt;/strong&gt;下（操作系统）访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;测试 INT 信号：&lt;strong&gt;将指令执行的最后一步改为：写回，并检测 INT 信号。如果 INT 信号为 0，则正常进行下一条指令；若为 1，则&lt;/strong&gt;保存并改变程序状态&lt;/strong&gt;，之后将 PC 加载为 x80001000，进行&lt;strong&gt;中断服务例程。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;・EPC：用于保存中断发生时 PC 中的值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;・SR [0]：进入中断服务例程时，为避免来自其他设备的中断信号的干扰，需要将其清 0。所以 SR [0] 也需要保存起来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;・SR [1]：表示正在运行的程序处于特权（设为 0）还是非特权（设为 1）模式。当进入中断服务例程时，SR [1] 改为 0. 所以 SR [1] 也需要保存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;・中断发生时，SR [2] 保存 SR [0] 的值，SR [3] 保存 SR [1] 的值。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;中断优先级&lt;/strong&gt;：有 6 个硬件优先级，PL0,PL1,...PL5，数字越高，优先级越高；速度越高的 I/O 设备，优先级越高。最低的优先级下允许所有中断，最高的优先级下屏蔽所有中断。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;・DLX 的中断优先级采用 SR [15:8]（中断掩码位）表示，与 CAUSE [15:8] 一一对应，从左至右优先级依次降低。CAUSE 中的未决中断要等到相应的屏蔽位为 1 时，才能引起处理器的处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中断服务例程：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;①第一项任务：&lt;strong&gt;将 CAUSE [15:8] 与 SR [15:8] 进行&lt;/strong&gt;逻辑与&lt;/strong&gt;运算，看发生了哪些允许的中断。如果多于一个，则选择优先级高的&lt;/p&gt;
&lt;p&gt;②服务该中断&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③从中断返回：&lt;strong&gt;首先&lt;/strong&gt;清空 CAUSE 寄存器&lt;/strong&gt;；接着&lt;strong&gt;使用 RFE 指令&lt;/strong&gt;，将 PC 恢复为 EPC 内的值，SR [0] 恢复为 SR [2] 内的值，SR [1] 恢复为 SR [3] 内的值。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;中断嵌套：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如，在中断服务例程中进行键盘处理例程时，如果&lt;strong&gt;允许被比键盘优先级高的设备所中断&lt;/strong&gt;，那么在读取 KBDR 之前，要先执行：&lt;/p&gt;
&lt;p&gt;①保存 SR,EPC 的值&lt;/p&gt;
&lt;p&gt;②将 SR [15:12] 设为 1，SR [11:8] 设为 0，即屏蔽比当前设备优先级低的中断（键盘优先级为 1），允许优先级高的设备的中断。&lt;/p&gt;
&lt;p&gt;③将 SR [0] 改为 1，即允许中断&lt;/p&gt;
&lt;p&gt;因为改变了 SR [15:8] 和 SR [0] 的值，所以在结束键盘服务例程之前，要&lt;strong&gt;先将 SR [0] 设为 0&lt;/strong&gt;，再将&lt;strong&gt; SR 与 EPC 还原&lt;/strong&gt;。（使用栈结构存储程序状态）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;C 语言中的 I/O&lt;/strong&gt;：scanf: “% d”，“% lf”，从标准输入流的第一个非空白字符（抛弃掉之前的空白，无论这个找到的非空白是否为数字）开始，找到多位数字（至少一位），以 “非数字” 结束（不抛弃，仍然留在输入流中）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;第十四章-子例程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第十四章-子例程&#34;&gt;#&lt;/a&gt; 第十四章 子例程&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;子例程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;** 调用 / 返回机制：** 计算子例程的起始地址，加载到 PC，并保存返回地址。结束后，使用返回地址加载 PC。与 TRAP 指令相似，R31 被加载返回地址，最后一条指令是 JR R31.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;** 与 TRAP 指令的区别：**TRAP 指令服务例程包括操作系统资源，由系统程序员编写；子例程由相同程序员或其他人编写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;JAL 与 JALR 指令（调用子例程指令）：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;①JAL：&lt;strong&gt;与&lt;/strong&gt; J 指令相同&lt;/strong&gt;，不过多了一步&lt;strong&gt;返回地址 -&amp;gt; R31&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;汇编格式： JAL  LABEL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②JALR：与 JR 指令相同，&lt;strong&gt;不过多了一步&lt;/strong&gt;返回地址 -&amp;gt; R31&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;汇编格式： JALR  SR1&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同样要有寄存器的保存与恢复，与服务例程类似。通常使用被调用者保存。注意 R31 的保存&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;** 使用子例程，必须知道：** 地址、功能（不需要知道具体实现）、传给子例程的值。返回值。（类似 C 语言函数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;.extern 伪操作：&lt;/strong&gt;.extern SQRT 告诉编译器标记 SQRT 是由其他程序片段（即模块）提供的。要求 SQRT 标记在库例程中被标记为.global SQRT，即可以被其他程序片段所使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;：一种抽象数据类型，&lt;strong&gt;后进先出。PUSH：压栈，POP：出栈&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;在存储器中实现栈：由一组存储单元和 “栈指针”（寄存器 R29）组成&lt;/strong&gt;。栈指针即为栈的栈顶，最后压入的元素的存储单元地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;・每次压栈，栈指针减 4；每次出栈，栈指针加 4&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image13.png&#34; alt=&#34;image13.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image14.png&#34; alt=&#34;image14.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;・返回值不需要压栈；临时寄存器不需要压栈。具体看计算阶乘的例子&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为变量分配存储空间&lt;/strong&gt;：当寄存器数量不足时，最常用的保存在寄存器里，不常用的放到存储器里。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储器组织：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image15.png&#34; alt=&#34;image15.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局数据区&lt;/strong&gt;：全局变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;帧指针：&lt;strong&gt;R30，栈的基址，理解为当前栈的栈底。也可称作&lt;/strong&gt;框架指针，动态链接&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;第十五章-函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第十五章-函数&#34;&gt;#&lt;/a&gt; 第十五章 函数&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C 语言中，任何调用者的局部变量对于被调用函数都是不可见的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C 语言的编译过程：预处理、编译、链接&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;・预处理&lt;/strong&gt;：寻找以 “#” 开头的预处理指令。与 DLX 的伪操作相似&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;・编译&lt;/strong&gt;：产生机器代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;・链接&lt;/strong&gt;：将目标文件与库的目标文件等等链接，生成可执行映像&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image16.png&#34; alt=&#34;image16.png&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;寄存器分配约定：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image17.png&#34; alt=&#34;image17.png&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;是否允许递归：&lt;strong&gt;即函数是否允许调用它本身。C 语言允许。编译器为每一次函数调用分配一个&lt;/strong&gt;活动记录&lt;/strong&gt;。每一次函数调用都会在存储器中为其局部数值获得它自己的空间，返回时活动记录将被回收。通过 “** 运行时栈”** 实现活动记录的分配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数调用机制：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;①调用函数&lt;/strong&gt;使用参数寄存器保存变元（应该就是传给被调用函数的值）。如果大于 4 个，将其分配到运行时栈。（在函数调用前完成）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②被调用函数&lt;/strong&gt;完成活动记录的分配：将一些寄存器的值保存到运行时栈中 —— 寄存器的保存；如果局部变量寄存器不足，将局部变量压入运行时栈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③被调用函数&lt;/strong&gt;执行任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;④被调用函数&lt;/strong&gt;完成工作时，活动记录从栈中弹出，并且控制返回到调用函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;⑤调用函数&lt;/strong&gt;的控制返回后，执行代码取回被调用函数的&lt;strong&gt;返回值&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数调用结束时的出栈：要按顺序，后进先出：&lt;strong&gt;弹出变元（如果函数内部还调用了其他函数），弹出局部变量，恢复&lt;/strong&gt;保存的寄存器&lt;/strong&gt;，恢复&lt;strong&gt;动态链接（R30）&lt;/strong&gt;，恢复&lt;strong&gt;返回地址（R31），最后 JR R31。&lt;strong&gt;控制返回后，再取得&lt;/strong&gt;返回值&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;如无必要，可以不保存 R31，可以不使用 R30&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;第十六章-指针和数组&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第十六章-指针和数组&#34;&gt;#&lt;/a&gt; 第十六章 指针和数组&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;指针和数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数组：&lt;strong&gt;在存储器中连续存储。在 [] 中提供下标，即偏移量。同样是&lt;/strong&gt;基址 + 偏移量&lt;/strong&gt;的表示方式。&lt;strong&gt;数组的名字&lt;/strong&gt;即为数组的基址，但数组名不能被重新赋值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;・注意数组越界&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;二维数组&lt;/strong&gt;：一行一行地存储。a [n] 代表着第 n 行的首地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;int p [4][4]：p 类型为 *&lt;em&gt;int (&lt;em&gt;p)[4] ，指向一维数组的指针，或者也可以说是指向指针的指针&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;p+i: 第 i 行地址，但实际与下面那个意思不一样&lt;/p&gt;
&lt;p&gt;*&lt;strong&gt;(p+i) &amp;lt;=&amp;gt; p[i]&lt;/strong&gt;，第 i 行首地址（第一个数据的地址）&lt;/p&gt;
&lt;p&gt;*&lt;strong&gt;((p+i)+j) &amp;lt;=&amp;gt; p[i][j]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;・DLX 通路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/FCS/image18.png&#34; alt=&#34;image18.png&#34; /&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/12/CPL/</guid>
            <title>C语言部分知识点整理</title>
            <link>https://erinwithbmq.github.io/2025/01/12/CPL/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大一上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%B8%80%E4%B8%8A/" />
            <category term="CPL" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%B8%80%E4%B8%8A/CPL/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sun, 12 Jan 2025 15:44:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;代码块显示有点 bug，将就着看吧 QAQ&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&#34;指针与数组&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指针与数组&#34;&gt;#&lt;/a&gt; 指针与数组&lt;/h2&gt;
&lt;h3 id=&#34;一维数组&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#一维数组&#34;&gt;#&lt;/a&gt; 【一维数组】&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;int *arr &amp;lt;=&amp;gt; int arr[]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;arr[i] &amp;lt;=&amp;gt; *(arr + i)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;arr[i] &amp;lt;=&amp;gt; &amp;amp;(*(arr + i)) &amp;lt;=&amp;gt; arr + i&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若  &lt;code&gt;p&lt;/code&gt;  为指向 &lt;code&gt;a[i]&lt;/code&gt;  的指针变量，则 &lt;code&gt;p + 3&lt;/code&gt;  为指向  &lt;code&gt;a[i + 3]&lt;/code&gt;  的指针变量，&lt;strong&gt;不是地址 + 3!&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;malloc&lt;/code&gt;  手搓数组（有 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;  库）： &lt;code&gt;int *numbers = (int *)malloc(len * sizeof(*numbers));&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手搓数组后最后记得  &lt;code&gt;free(numbers);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组不是指针，但是数组名确实代表了第一个元素的地址！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;举个例子，手搓数组可以 &lt;code&gt;arr++&lt;/code&gt;  使指针移动，但是直接 * &lt;code&gt;arr[]&lt;/code&gt; * 出来的数组不可以 &lt;code&gt;arr++&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;交换函数指针的常见用法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#交换函数指针的常见用法&#34;&gt;#&lt;/a&gt; 【交换函数（指针的常见用法）】&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void Swap(int *left, int *right)
&amp;#123;
    int temp = *left;
    *left = *right;//将right指针指向的值赋值给left指针指向的值
    *right = temp;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数组与字符串&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数组与字符串&#34;&gt;#&lt;/a&gt; 【数组与字符串】&lt;/h3&gt;
&lt;h4 id=&#34;手搓字符串的两种不同方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#手搓字符串的两种不同方式&#34;&gt;#&lt;/a&gt; 手搓字符串的两种不同方式&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;char *ptr_msg = &amp;quot;Hello World!&amp;quot;; //定义指针指向该字符串.就是手搓数组，不过改不了元素
//指向静态变量，只读，不能修改
ptr_msg[0] = &#39;N&#39;; //错误操作

char msg[] = &amp;quot;Hello World!&amp;quot;;
msg[0] = &#39;N&#39;;
printf(&amp;quot;%s\n&amp;quot;, msg);
//这种可以修改
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常见string库函数用法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常见string库函数用法&#34;&gt;#&lt;/a&gt; 【常见 string 库函数用法】&lt;/h3&gt;
&lt;h3 id=&#34;strlen-读取字符串长短函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#strlen-读取字符串长短函数&#34;&gt;#&lt;/a&gt; strlen 读取字符串长短函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;手搓一个 strlen 函数：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int Strlen(const char *str)
&amp;#123;
    int len = 0;
    while (str[len ] != &#39;\0&#39;)
    &amp;#123;
        len++;
    &amp;#125;
    return len;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;strcpy-字符串复制函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#strcpy-字符串复制函数&#34;&gt;#&lt;/a&gt; strcpy 字符串复制函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;手搓一个&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void StrCpy2(char *dest, const char *src)
&amp;#123;
    int i = 0;
    while ((*(dest + i) = *(src + i)) != &#39;\0&#39;) //先赋值，再比较dest[i]是否为&#39;\0&#39;
    &amp;#123;
        i++;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;*&lt;em&gt; 对于标准库里的 strcpy 函数，返回值类型为 char &lt;em&gt;，即将复制后的字符串返回了，所以可以直接用&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;strcmp-比较两个字符串第一个不同元素ascii值大小函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#strcmp-比较两个字符串第一个不同元素ascii值大小函数&#34;&gt;#&lt;/a&gt; strcmp 比较两个字符串第一个不同元素 ascii 值大小函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一般用于比较两个字符串相不相等了，相等返回 0，前面大于后面返回正数，反之负数。&lt;/strong&gt; &lt;strong&gt;在作业里出现了一种它的用法，即从一堆字符串里面找有没有我要的那个字符串&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;strtok-字符串分割函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#strtok-字符串分割函数&#34;&gt;#&lt;/a&gt; strtok 字符串分割函数&lt;/h3&gt;
&lt;p&gt;直接看具体应用（函数原理看 cpp 网站）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;//arr,cut都是字符串。arr是原字符串，cut是目标剪掉的字符串。该程序将arr字符串切成若干部分放在tokens数组里，count为切后字符串数目
char *tokens[103];
char *token = strtok(arr, cut);
int i = 0;
while (token != NULL &amp;amp;&amp;amp; i &amp;lt; 1000)
&amp;#123;
    tokens[i] = token;
    i++;
    token = strtok(NULL, cut);
&amp;#125;
int count = i;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt; &lt;code&gt;token = strtok(NULL, cut);&lt;/code&gt;  是什么意思？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;若 str 为空指针，则将调用当做对 strtok 的后继调用，函数从先前调用中它剩下的位置开始。 行为如同将先前存储的指针作为 str 传递&lt;/p&gt;
&lt;h3 id=&#34;strstr-查找首个目标字符串出现位置函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#strstr-查找首个目标字符串出现位置函数&#34;&gt;#&lt;/a&gt; strstr 查找首个目标字符串出现位置函数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void find_str(char const *str, char const *substr)
&amp;#123;
char *pos = strstr(str, substr);
pos ? printf(&amp;quot;found the string &#39;%s&#39; in &#39;%s&#39; at position %td\n&amp;quot;,
    substr, str, pos - str)
    : printf(&amp;quot;the string &#39;%s&#39; was not found in &#39;%s&#39;\n&amp;quot;,
    substr, str);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;strcat-字符串拼接函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#strcat-字符串拼接函数&#34;&gt;#&lt;/a&gt; strcat 字符串拼接函数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;char *strcat( char *dest, const char *src );&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回值是 &lt;code&gt;dest&lt;/code&gt; 。会改变 &lt;code&gt;dest&lt;/code&gt;  指向的内容&lt;/p&gt;
&lt;h3 id=&#34;指针数组&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指针数组&#34;&gt;#&lt;/a&gt; 【指针数组】&lt;/h3&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;const char *musicians[] = &amp;#123;
            &amp;quot;Luo Dayou&amp;quot;,
            &amp;quot;Cui Jian&amp;quot;,
            &amp;quot;Dou Wei&amp;quot;,
            &amp;quot;Zhang Chu&amp;quot;,
            &amp;quot;Wan Qing&amp;quot;,
            &amp;quot;Li Zhi&amp;quot;,
            &amp;quot;Yao&amp;quot;,
            &amp;quot;ZuoXiao&amp;quot;,
            &amp;quot;ErShou Rose&amp;quot;,
            &amp;quot;Hu Mage&amp;quot;,
    &amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;这里的 &lt;code&gt;const&lt;/code&gt;  保护的是指针所指向的字符串，并不是保护字符指针数组内的值不可修改&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;保护字符指针数组内的值： &lt;code&gt;const char * const arr[]&lt;/code&gt; &lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;musicians [0] 为指针数组内第 0 个字符串的首地址。但是 printf (&amp;quot;% s&amp;quot;, arr [i]); 就可以直接打印出第 i 个字符串了。&lt;/strong&gt; 这是为什么？&lt;/p&gt;
&lt;p&gt;我的理解：这个地址已经直接指向字符串了，他不是一个存粹的地址，只有十六进制表示，而是一个有指向的指针。因此可以不用解地址符？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;[] 的转换关系：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;char-arr-char-arr&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#char-arr-char-arr&#34;&gt;#&lt;/a&gt;  &lt;code&gt;char arr[] : char *arr&lt;/code&gt;&lt;/h4&gt;
&lt;h4 id=&#34;char-arr-char-arr-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#char-arr-char-arr-2&#34;&gt;#&lt;/a&gt;  &lt;code&gt;char *arr[]: char **arr&lt;/code&gt;&lt;/h4&gt;
&lt;h3 id=&#34;二维数组的指针形式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二维数组的指针形式&#34;&gt;#&lt;/a&gt; 【二维数组的指针形式】&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;**int table[][col]**&lt;/code&gt;  : &lt;strong&gt; &lt;code&gt;int (*table)[col]&lt;/code&gt; &lt;/strong&gt;, &lt;code&gt;table&lt;/code&gt;  是指针，指向一个 ** 长度为 &lt;code&gt;col&lt;/code&gt;  类型为 &lt;code&gt;int&lt;/code&gt; ** 的数组&lt;/p&gt;
&lt;p&gt;另一种形式： &lt;code&gt;int table[][col] &amp;lt;=&amp;gt; int[col] *table&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;即：table 是一个&lt;strong&gt;指针&lt;/strong&gt;，它的具体类型是 ** &lt;code&gt;int[col] *&lt;/code&gt; &lt;strong&gt;，指向一个&lt;/strong&gt;长度为 &lt;code&gt;col&lt;/code&gt;  类型为 &lt;code&gt;int&lt;/code&gt; ** 的数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;//一个推导
             table[i][j] : *(*(table + i) + j)
             table : int (*)[]
             table + i : int (*)[]    //指向数组的指针
             *(table + i) : int *     //数组的首地址。与上一个指向同一个位置，但含义不一样。
             *(table + i) + j : int *
             *(*(table + i) + j) : int
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;函数指针&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#函数指针&#34;&gt;#&lt;/a&gt; 【函数指针】&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int (*comp)(const void *, const void *) = CompareInts;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明一个 camp &lt;strong&gt;函数指针&lt;/strong&gt;，它所对应的函数的类型是 接收接受两个 const int * 类型指针，返回 int。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef int (*CompareFunction)(const void *, const void *);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将函数指针（接受两个 const int * 类型指针，返回 int 的类型）命名为 CompareFunction&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多的例子：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;double Integrate(double low, double high, double (*func)(double));
    //func是一个函数指针，指针指向函数，函数接受一个double，返回一个double

double (*funsarr[])(double) = &amp;#123;sin, cos&amp;#125;;
    //一个数组，存储类型为函数指针，该指针对应函数接受一个double类型，返回一个double类型
    //sin不一定要取地址，sin在这里被隐式地转成函数指针
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;函数指针的使用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;double Integrate(double low, double high, double (*func)(double))
&amp;#123;
    double x = func(5); //在这里不需要对fun解引用，因为被隐式地转成函数
    //后面省略
&amp;#125;

integration = Integrate(low, high, sin); //sin不一定要取地址，sin在这里被隐式地转成函数指针
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;判断指针 or 函数 or 数组：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;最关键的是看最里面的内容，结合运算符优先级&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;运算符优先级-函数调用-数组下标-解引用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#运算符优先级-函数调用-数组下标-解引用&#34;&gt;#&lt;/a&gt; 运算符优先级：() 函数调用 / [] 数组下标 &amp;gt; * 解引用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;char **argv; //指向指针的指针
int *names[10]; //指针数组
int (*musician_score_table)[10]; //指针，指向长度为10的数组
int *StrCpyStd(char *dest, const char *src); //函数，接收一个char *与const char *，返回int *
int (*comp)(const void *left, const void *right); //指针，指向一个接收两个const void *，返回int的函数
int atexit(void (*func)(void)); //函数，接受一个函数指针，返回int
void (*signal(int sig, void (*handler)(int)))(int); 
//函数，接收一个int、一个函数指针（接收int返回void类型），返回一个函数指针（接收int返回void类型）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;qsort用法与bsearch用法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#qsort用法与bsearch用法&#34;&gt;#&lt;/a&gt; 【qsort 用法与 bsearch 用法】&lt;/h3&gt;
&lt;p&gt;头文件： &lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;qsort：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void qsort( void *ptr, size_t count, size_t size,
            int (*comp)(const void *, const void *) );
//参数分别是：要排序的数组，数组内元素个数，数组内单个元素大小，具体的排序准则（一个函数，要自己写）

//comp函数参考：
int comp(const void *left, const void *right)
&amp;#123;
    int left_int = *(const int *)left; //强制类型转换后解引用
    int right_int = *(const int *)right; //强制类型转换后解引用

    return (left_int &amp;gt; right_int) - (left_int &amp;lt; right_int);
    // 如果左大于右，则返回 1 - 0 = 1. 其他类推
&amp;#125;
//那么，在qsort中将会按照升序排序、
//改成降序排序：将返回值取相反值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想要以结构数组中某一个元素的值为参考排序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int CompareMusician(const void *m1, const void *m2)
&amp;#123;
    const Musician *left_m = m1;
    const Musician *right_m = m2;
    return strcmp(left_m-&amp;gt;name, right_m-&amp;gt;name);

//  改变比较对象即可。注意，这里left_m和right_m都是指针，所以不能用 &amp;quot;.&amp;quot; 运算符，要用 &amp;quot;-&amp;gt;&amp;quot;
// *(left_m).name &amp;lt;=&amp;gt; left_m-&amp;gt;name
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;bsearch：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void *bsearch(const void *key, const void *ptr, size_t count, size_t size,
            int (*comp)(const void*, const void*) );
//参数分别是：要查找的对象的地址，查找的数组，数组内元素的个数，数组内单个元素的大小，comp函数（这个函数这里必须要大于返回1了）
//返回值是目标对象的地址。如果没找到，返回NULL空指针
//要求：数组必须已经升序排序完成

//comp函数参考：
int CompareStrs(const void *left, const void *right)
&amp;#123;
    char *const *pp1 = left;
    char *const *pp2 = right;
    return strcmp(*pp1, *pp2);
    //必须要解引用！不然比较的是指针了
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;具体使用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;const char *names[] = &amp;#123;
        &amp;quot;Cui Jian&amp;quot;,
        &amp;quot;Dou Wei&amp;quot;,
        &amp;quot;ErShou Rose&amp;quot;,
        &amp;quot;Hu Mage&amp;quot;,
        &amp;quot;Li Zhi&amp;quot;,
        &amp;quot;Luo Dayou&amp;quot;,
        &amp;quot;Wan Qing&amp;quot;,
        &amp;quot;Yao&amp;quot;,
        &amp;quot;Zhang Chu&amp;quot;,
        &amp;quot;ZuoXiao&amp;quot;,
&amp;#125;;
char *key_name = &amp;quot;Zhang Chu&amp;quot;;

char **name_str = bsearch(&amp;amp;key_name, names,
                          sizeof names / sizeof names[0], sizeof names[0],
                          CompareStrs);
//为什么要 &amp;amp; :参数为const void *key，目标元素的地址
//为什么是char **：返回的是找到的那个元素的地址。元素是char *类型，地址自然是char **
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结构与链表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#结构与链表&#34;&gt;#&lt;/a&gt; 结构与链表&lt;/h2&gt;
&lt;h3 id=&#34;结构体&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#结构体&#34;&gt;#&lt;/a&gt; 【结构体】&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct score&amp;#123;
    int c_score; // 4
    int java_score; // 4
    int python_score; // 4
&amp;#125; Score;

typedef struct musician &amp;#123;  //类型为 struct musician
    char *name; // 8
    Gender gender; // 1

    char *album; // 8

    Score score;  //结构体的嵌套
&amp;#125; Musician;  //利用 typedef 定义为 Musician
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么内存空间不是 29：（1）地址最后应该为 8 的倍数，所以要补字节使其合法。 （2）每个部分字节为多少，它的起始地址 % 多少 就应该为 0。如 8 字节 char * 起始地址 应该 %8 为 0。 定义顺序不同，大小也可能不一样&lt;/p&gt;
&lt;p&gt;初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;    Musician luo = &amp;#123;
            .name = &amp;quot;Luo Dayou&amp;quot;,
            .gender = MALE,
            .album = &amp;quot;ZhiHuZheYe&amp;quot;,
            .score.c_score = 0,
            .score.java_score = 10,
            .score.python_score = 20,  //伪逗号可以加
    &amp;#125;;
    //没有初始化的默认为0
    
    Musician cui = &amp;#123;
            .name = &amp;quot;Cui Jian&amp;quot;,
            .gender = MALE,
            .album = &amp;quot;XinChangZhengLuShangDeYaoGun&amp;quot;,
            .score = &amp;#123;
                    .c_score = 10,
                    .java_score = 20,
                    .python_score = 30,
                    &amp;#125;
    &amp;#125;;
    //上面这样也行

    Musician luo = cui; //结构体可以直接赋值，与数组不同

    Musician musicians[] = &amp;#123;luo, cui, zhang&amp;#125;;  //结构数组
    int len = sizeof musicians / sizeof *musicians;   //数组内元素个数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结构体在函数中的使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;//尽量不要传递结构体，因为复制花费时间。可以传递指针
void PrintMusician(const Musician *m)
&amp;#123;
    printf(&amp;quot;%s\t%c\t%s\t%d\t%d\t%d\n&amp;quot;,
           (*m).name,      // . 的优先级高于 *
           m -&amp;gt; gender,    //语法糖，等同于上面的写法
           m -&amp;gt; album,
           m -&amp;gt; score.c_score,
           m -&amp;gt; score.java_score,
           m -&amp;gt; score.python_score);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;链表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#链表&#34;&gt;#&lt;/a&gt; 【链表】&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// 定义数据类型 : linked list (circular)

typedef struct node &amp;#123;
    int index;
    struct node *next;  //不能写成 Node *
&amp;#125; Node;
// 节点结构

typedef struct list &amp;#123;
    Node *head; //头指针
    Node *tail; //尾指针
&amp;#125; Linkedlist;
// 链表结构
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常见链表函数 (很多)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void Init(Linkedlist *list); //传指针. 初始化链表
void Free(Linkedlist *list); //释放链表
void Append(Linkedlist *list, int index); //添加节点
void Insert(Linkedlist *list, Node *prev, int index); //在指定节点prev后添加节点
bool Isempty(const Linkedlist *list);  //链表是否为空
void Print(Linkedlist *list); //输出链表
void Delete(Linkedlist *list, Node *prev); //删除prev节点后的节点
void Nilist(Linkedlist *list);  //使单向链表倒序

void Init(Linkedlist *list)
&amp;#123;
    list-&amp;gt;head = NULL;
    list-&amp;gt;tail = NULL;
&amp;#125;

void Free(Linkedlist *list)
&amp;#123;
    if (list-&amp;gt;head == NULL)
    &amp;#123;
        return;
    &amp;#125;

    Node *point = list-&amp;gt;head;
    Node *next = point-&amp;gt;next;
    while (point != NULL)
    &amp;#123;
        next = point-&amp;gt;next;
        free(point);
        point = next;
    &amp;#125;
&amp;#125;

bool Isempty(const Linkedlist *list)
&amp;#123;
    return list-&amp;gt;head == NULL;
&amp;#125;

void Append(Linkedlist *list, int index)
&amp;#123;
    Node *node = malloc(sizeof *node); // 生成一个指针，指向Node结构类型,并分配了Node结构大小的空间
    if (node == NULL)
    &amp;#123;
        return;
    &amp;#125;

    if (Isempty(list)) //链表为空
    &amp;#123;
        list-&amp;gt;head = node;
    &amp;#125;
    else  //通用情况
    &amp;#123;
        list-&amp;gt;tail-&amp;gt;next = node;
    &amp;#125;

    node-&amp;gt;index = index;
    list-&amp;gt;tail = node;
    list-&amp;gt;tail-&amp;gt;next = list-&amp;gt;head; // 啊这里是环形链表吗？
&amp;#125;

void Insert(Linkedlist *list, Node *prev, int index)
&amp;#123;
    // 首先，创建一个新节点
    Node *new_node = (Node *)malloc(sizeof(Node));
    if (new_node == NULL)
    &amp;#123;
        // 处理内存分配失败的情况
        return;
    &amp;#125;
    new_node-&amp;gt;index = index; // 设置新节点的值
    new_node-&amp;gt;next = NULL; // 新节点的下一个节点先设置为NULL

    if (prev == NULL)
    &amp;#123;
        // 如果prev是NULL，那么将新节点插入到链表头部
        if (list-&amp;gt;head == NULL)
        &amp;#123;
            // 如果链表为空，那么新节点同时也是链表的尾部
            list-&amp;gt;tail = new_node;
        &amp;#125;
        else
        &amp;#123;
            // 将新节点链接到当前的头节点
            new_node-&amp;gt;next = list-&amp;gt;head;
        &amp;#125;
        // 更新链表的头部为新节点
        list-&amp;gt;head = new_node;
    &amp;#125;
    else
    &amp;#123;
        // 插入到指定节点prev后面
        new_node-&amp;gt;next = prev-&amp;gt;next; // 新节点的下一个节点是prev原来指向的节点
        prev-&amp;gt;next = new_node; // 将prev的下一个节点设置为新节点
        if (prev == list-&amp;gt;tail)
        &amp;#123;
            // 如果prev是尾节点，那么更新尾部为新节点
            list-&amp;gt;tail = new_node;
        &amp;#125;
    &amp;#125;
&amp;#125;

bool Isempty(const Linkedlist *list)
&amp;#123;
    return list-&amp;gt;head == NULL;


void Print(Linkedlist *list)
&amp;#123;
    if (Isempty(list))
    &amp;#123;
        return;
    &amp;#125;

    Node *node = list-&amp;gt;head;

    do &amp;#123;
        printf(&amp;quot;%d &amp;quot;, node-&amp;gt;index);
        node = node-&amp;gt;next;
    &amp;#125; while (node != list-&amp;gt;head);
&amp;#125;

void Delete(Linkedlist *list, Node *prev)
&amp;#123;
    if (Isempty(list))
    &amp;#123;
        return;
    &amp;#125;
    if (Issingleton(list))
    &amp;#123;
        Init(list);
        free(prev);
        return;
    &amp;#125;
    Node *cur = prev-&amp;gt;next;  //指向被删节点
    Node *next = cur-&amp;gt;next;

    prev-&amp;gt;next = next;

    if (cur == list-&amp;gt;head)
    &amp;#123;
        list-&amp;gt;head = next;
    &amp;#125;

    if (cur == list-&amp;gt;tail)
    &amp;#123;
        list-&amp;gt;tail = prev;
    &amp;#125;
    free(cur);
&amp;#125;


void Nilist(Linkedlist *list)
&amp;#123;
    // 检查链表是否为空或只包含一个节点
    if (list-&amp;gt;head == NULL || list-&amp;gt;head == list-&amp;gt;tail)
    &amp;#123;
        return; // 空链表或只有一个节点的链表不需要倒序处理
    &amp;#125;

    Node *prev = NULL;
    Node *current = list-&amp;gt;head;
    Node *next = NULL;

    // 更新tail指向原链表的头节点
    list-&amp;gt;tail = list-&amp;gt;head;

    // 遍历每个节点，并反转next指针
    while (current != NULL)
    &amp;#123;
        next = current-&amp;gt;next; // 临时保存下一个节点
        current-&amp;gt;next = prev; // 反转next指针
        prev = current;       // 移动prev到当前节点
        current = next;       // 继续下一个迭代
    &amp;#125;

    // 更新head指向原链表的最后一个节点
    list-&amp;gt;head = prev;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;输入输出&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#输入输出&#34;&gt;#&lt;/a&gt; 输入输出&lt;/h2&gt;
&lt;h3 id=&#34;关于scanf&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关于scanf&#34;&gt;#&lt;/a&gt; 【关于 scanf】&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;输入的终止&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;while ((scanf(&amp;quot;%s&amp;quot;, s) != EOF))
&amp;#123;
    // 其它代码
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;正则表达式匹配读入&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;scanf(&amp;quot;%[^;];%[^;];%d;%d;%d&amp;quot;, s1, s2, &amp;amp;d1, &amp;amp;d2, &amp;amp;size);
getchar();  // 为什么有这个？因为回车也会被读进来
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;%[^;] 意为读入除 &#39;;&#39; 外的所有字符。（本题的要求是所有部分用分号隔开）&lt;/p&gt;
&lt;h2 id=&#34;杂项&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#杂项&#34;&gt;#&lt;/a&gt; 杂项&lt;/h2&gt;
&lt;h3 id=&#34;ub未定义行为&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ub未定义行为&#34;&gt;#&lt;/a&gt; 【UB—— 未定义行为】&lt;/h3&gt;
&lt;p&gt;数字除以 0、scanf printf 类型不匹配、访问未初始化局部变量、&lt;em&gt;&lt;strong&gt;数组访问越界&lt;/strong&gt;&lt;/em&gt; 等&lt;/p&gt;
&lt;p&gt;千万不要数组越界！在循环时，记得加上限制条件。&lt;/p&gt;
&lt;h3 id=&#34;数字翻转&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数字翻转&#34;&gt;#&lt;/a&gt; &lt;strong&gt;数字翻转&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int reverse(int n)
&amp;#123;
    int ans = 0;
    while (n)
    &amp;#123;
        ans = ans * 10 + n % 10;
        n /= 10;
    &amp;#125;
    return ans;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/COA16/</guid>
            <title>计组期末复习第十六讲 输入输出</title>
            <link>https://erinwithbmq.github.io/2025/01/11/COA16/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="计算机组织结构" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 19:38:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;LaTeX 渲染有问题。将就着看吧。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;能否将外设直接连接到系统总线上？&lt;strong&gt;不可以&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么不能把外设直接连接到系统总线上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;外设种类繁多，操作方法&lt;strong&gt;多种多样&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外设的数据传送速度一般比存储器或处理器的&lt;strong&gt;慢得多&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;某些外设的数据传送速度比存储器或处理器&lt;strong&gt;要快&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外设使用的&lt;strong&gt;数据格式和字长度&lt;/strong&gt;通常与处理器不同&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;io-模块&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#io-模块&#34;&gt;#&lt;/a&gt; I/O 模块&lt;/h1&gt;
&lt;p&gt;I/O 模块是计算机内部系统和外设之间的桥梁&lt;/p&gt;
&lt;h2 id=&#34;功能&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#功能&#34;&gt;#&lt;/a&gt; 功能&lt;/h2&gt;
&lt;h3 id=&#34;处理器通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#处理器通信&#34;&gt;#&lt;/a&gt; 处理器通信&lt;/h3&gt;
&lt;p&gt;命令译码，状态报告，数据，地址识别&lt;/p&gt;
&lt;h3 id=&#34;设备通信&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#设备通信&#34;&gt;#&lt;/a&gt; 设备通信&lt;/h3&gt;
&lt;p&gt;通信内容包含命令、状态信息和数据&lt;/p&gt;
&lt;h3 id=&#34;数据缓冲&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据缓冲&#34;&gt;#&lt;/a&gt; 数据缓冲&lt;/h3&gt;
&lt;h3 id=&#34;控制和定时&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#控制和定时&#34;&gt;#&lt;/a&gt; 控制和定时&lt;/h3&gt;
&lt;h3 id=&#34;检错&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#检错&#34;&gt;#&lt;/a&gt; 检错&lt;/h3&gt;
&lt;h2 id=&#34;外部接口&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#外部接口&#34;&gt;#&lt;/a&gt; 外部接口&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;并行接口：多根线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;串行接口：一根线&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;操作技术&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#操作技术&#34;&gt;#&lt;/a&gt; 操作技术&lt;/h1&gt;
&lt;h2 id=&#34;编程式-io&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#编程式-io&#34;&gt;#&lt;/a&gt; 编程式 I/O&lt;/h2&gt;
&lt;p&gt;轮询？&lt;/p&gt;
&lt;p&gt;I/O 不会中断处理器，因此处理器需要周期性地检查 I/O 模块的状态，直到发现该操作完成&lt;/p&gt;
&lt;p&gt;CPU 全程 100% 投入&lt;/p&gt;
&lt;p&gt;为了执行 I/O 操作，处理器发送一个指定具体 I/O 模块和外设的地址，并发送一条&lt;strong&gt; I/O 命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I/O 指令很容易&lt;strong&gt;映射为 I/O 命令&lt;/strong&gt;，并且两者之间通常是简单的一一对应关系&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编址方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;存储器映射式 I/O：合并到指令系统里&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分离式 I/O：有独立的线&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;中断驱动式-io&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#中断驱动式-io&#34;&gt;#&lt;/a&gt; 中断驱动式 I/O&lt;/h2&gt;
&lt;p&gt;中断处理器来进行 I/O 操作&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA16/152c3c6e93f27b59af4dc5a626ad1f34.png&#34; alt=&#34;152c3c6e93f27b59af4dc5a626ad1f34.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;响应优先级和处理优先级&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#响应优先级和处理优先级&#34;&gt;#&lt;/a&gt; 响应优先级和处理优先级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;响应优先级：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;响应优先级&lt;/strong&gt;决定了&lt;strong&gt;中断控制器&lt;/strong&gt;在接收到多个中断信号时，应该&lt;strong&gt;优先响应&lt;/strong&gt;哪一个中断请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应优先级仅涉及&lt;strong&gt;哪一个中断首先被响应&lt;/strong&gt;，不直接决定中断的具体处理时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理优先级：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理优先级&lt;/strong&gt;决定了&lt;strong&gt; CPU&lt;/strong&gt; 在响应中断后，如何分配资源来处理这些中断。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理中断时，可能出现嵌套中断的情况，此时需要根据处理优先级决定是否允许其他中断&lt;strong&gt;打断当前中断&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;：如果当前正在处理一个低优先级的中断，但又有一个高优先级的中断到来，则高优先级中断可以中断低优先级中断的处理（称为嵌套中断）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;** 例子：** 假设中断系统中有 4 个中断源，其响应优先级为 L1&amp;gt;L2&amp;gt;L3&amp;gt;L4，处理优先级为 L1&amp;gt;L4&amp;gt;L3&amp;gt;L2。如果在主程序执行时同时发生 L1、L3 和 L4 中断，并且在处理 L3 中断的过程中发生 L2 中断，写出掩码字和所有中断服务程序的过程。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA16/b264a7cd4b7e43fe4e4ce2293b48c6bb.png&#34; alt=&#34;b264a7cd4b7e43fe4e4ce2293b48c6bb.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;** 掩码字：** 为 1 代表可打断，为 0 代表不可打断&lt;/p&gt;
&lt;h1 id=&#34;直接存储器存取dma&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#直接存储器存取dma&#34;&gt;#&lt;/a&gt; 直接存储器存取（DMA）&lt;/h1&gt;
&lt;p&gt;直接存储器存取：无需经过处理器即可&lt;strong&gt;直接访问内存&lt;/strong&gt;的模块&lt;/p&gt;
&lt;p&gt;DMA 模块将全部数据块，每次一个字，直接将数据传输到存储器或从存储器读出，&lt;strong&gt;而无需经过处理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传输完成时，DMA 模块向处理器发送一个&lt;strong&gt;中断信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内存访问时，DMA 优先于 CPU&lt;/p&gt;
&lt;h2 id=&#34;内存访问&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内存访问&#34;&gt;#&lt;/a&gt; 内存访问&lt;/h2&gt;
&lt;h3 id=&#34;cpu-停止法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cpu-停止法&#34;&gt;#&lt;/a&gt; CPU 停止法&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA16/e3fd9487d3368fcc89bfa31c1aeea396.png&#34; alt=&#34;e3fd9487d3368fcc89bfa31c1aeea396.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;直接打断 CPU？&lt;/p&gt;
&lt;p&gt;优点：控制简单&lt;/p&gt;
&lt;p&gt;缺点：影响 CPU，没有充分利用内存&lt;/p&gt;
&lt;p&gt;适用：高速 I/O 设备的块传输&lt;/p&gt;
&lt;h3 id=&#34;周期窃取&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#周期窃取&#34;&gt;#&lt;/a&gt; 周期窃取&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA16/210c6722eefcd38c43f94182d41bac73.png&#34; alt=&#34;210c6722eefcd38c43f94182d41bac73.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在 CPU 访问的间隔期使用 DMA？&lt;/p&gt;
&lt;p&gt;适用：I/O 周期大于存储周期&lt;/p&gt;
&lt;h3 id=&#34;交替分时访问&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#交替分时访问&#34;&gt;#&lt;/a&gt; 交替分时访问&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA16/3b8b71c86f3097515555f02a285f9db8.png&#34; alt=&#34;3b8b71c86f3097515555f02a285f9db8.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;优点：CPU 未停止或等待，DMA 不请求总线&lt;/p&gt;
&lt;p&gt;缺点：CPU 周期大于存储周期&lt;/p&gt;
&lt;h2 id=&#34;配置机制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#配置机制&#34;&gt;#&lt;/a&gt; 配置机制&lt;/h2&gt;
&lt;h3 id=&#34;单总线分离dma&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#单总线分离dma&#34;&gt;#&lt;/a&gt; 单总线分离 DMA&lt;/h3&gt;
&lt;p&gt;所有模块&lt;strong&gt;共享相同的系统总线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DMA 直接连在总线上&lt;/p&gt;
&lt;h3 id=&#34;单总线集合的dma-io&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#单总线集合的dma-io&#34;&gt;#&lt;/a&gt; 单总线集合的 DMA-I/O&lt;/h3&gt;
&lt;p&gt;DMA 逻辑实际上可能是&lt;strong&gt; I/O 模块的一部分&lt;/strong&gt;，也可能是控制一个或多个 I/O 模 块的单独模块&lt;/p&gt;
&lt;h3 id=&#34;io-总线&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#io-总线&#34;&gt;#&lt;/a&gt; I/O 总线&lt;/h3&gt;
&lt;p&gt;使用 I/O 总线将 I/O 模块连接到 DMA 模块&lt;/p&gt;
&lt;p&gt;多个 I/O 模块&lt;strong&gt;共享 DMA&lt;/strong&gt;，且易于扩展&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/COA15/</guid>
            <title>计组期末复习第十五讲 控制器</title>
            <link>https://erinwithbmq.github.io/2025/01/11/COA15/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="计算机组织结构" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 19:37:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;LaTeX 渲染有问题。将就着看吧。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&#34;寄存器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#寄存器&#34;&gt;#&lt;/a&gt; 寄存器&lt;/h2&gt;
&lt;h3 id=&#34;分类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分类&#34;&gt;#&lt;/a&gt; 分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用户可见寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通用寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件码寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;控制和状态寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序计数器 PC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指令寄存器 IR&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储器地址寄存器 MAR&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储器缓冲寄存器 MBR（或者说是 MDR）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序状态字 PSW&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计出发点：对操作系统的支持 / 控制信息在寄存器和存储器之间的分配&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;两者的区分并不严格&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;微操作&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微操作&#34;&gt;#&lt;/a&gt; 微操作&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA15/b6c20b22a81a5a2cebd5c3a4ead6bb1d.png&#34; alt=&#34;b6c20b22a81a5a2cebd5c3a4ead6bb1d.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;微操作分组的原则&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微操作分组的原则&#34;&gt;#&lt;/a&gt; 微操作分组的原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事件的流动顺序必须是恰当的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必须避免冲突&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;满足上述条件下，所用的时间单位尽可能少&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;子周期&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#子周期&#34;&gt;#&lt;/a&gt; 子周期&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;取指周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;间址周期&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果指令采用&lt;strong&gt;间接寻址&lt;/strong&gt;，则在指令执行前有一个间址周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完成间址周期后，IR 的状态与不使用间接寻址方式的状态是相同的，已经为执行周期准备就绪&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA15/d024815799acb7ad9c48d35841d71c14.png&#34; alt=&#34;d024815799acb7ad9c48d35841d71c14.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;即将 IR 存储指令内的地址部分存入 MAR，读出数据后存入 MBR，MBR 将更新后的地址再存入 IR 指令内的地址部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中断周期&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在完成执行周期时，要确定是否有允许的中断产生&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有，则出现一个中断周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下图是微操作示意。注意微操作的分组&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA15/3b90fbf4a75322625f8095c67ea53369.png&#34; alt=&#34;3b90fbf4a75322625f8095c67ea53369.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;指令周期代码-icc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指令周期代码-icc&#34;&gt;#&lt;/a&gt; 指令周期代码 ICC&lt;/h3&gt;
&lt;p&gt;00：取指&lt;/p&gt;
&lt;p&gt;01：间址&lt;/p&gt;
&lt;p&gt;10：执行&lt;/p&gt;
&lt;p&gt;11：中断&lt;/p&gt;
&lt;h2 id=&#34;控制器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#控制器&#34;&gt;#&lt;/a&gt; 控制器&lt;/h2&gt;
&lt;h3 id=&#34;输入&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#输入&#34;&gt;#&lt;/a&gt; 输入&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令寄存器：当前指令的寻址方式和操作码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标志：确定 CPU 的状态和前一个 ALU 操作的结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时钟：控制器要在每个时钟脉冲完成一个或一组同时的微操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;来自控制总线的控制信号：向控制器提供控制&lt;s&gt;信号&lt;/s&gt;（请求）比如中断请求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;输出&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#输出&#34;&gt;#&lt;/a&gt; 输出&lt;/h3&gt;
&lt;p&gt;控制信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU 内&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制总线&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储器、IO 模块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;控制门的开关，从而控制数据传递&lt;/p&gt;
&lt;p&gt;所有的控制信号最终作为二进制输入量直接输入到各个逻辑门上&lt;/p&gt;
&lt;h3 id=&#34;控制器的最小特性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#控制器的最小特性&#34;&gt;#&lt;/a&gt; 控制器的最小特性&lt;/h3&gt;
&lt;p&gt;它只需要知道将被执行的指令和算术、逻辑运算结果的性质（如正负、溢出 等），而不需要知道正被处理的数据或得到的实际结果具体是什么&lt;/p&gt;
&lt;p&gt;它只是以少量的送到 CPU 内的和送到系统总线上的控制信号来实现控制&lt;/p&gt;
&lt;h3 id=&#34;功能需求&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#功能需求&#34;&gt;#&lt;/a&gt; 功能需求&lt;/h3&gt;
&lt;h4 id=&#34;cpu的基本元素&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cpu的基本元素&#34;&gt;#&lt;/a&gt; CPU 的基本元素&lt;/h4&gt;
&lt;p&gt;ALU，寄存器组，内部数据通路，控制器，外部数据通路&lt;/p&gt;
&lt;h4 id=&#34;cpu需要完成的微操作&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cpu需要完成的微操作&#34;&gt;#&lt;/a&gt; CPU 需要完成的微操作&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在寄存器之间传送数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将数据由寄存器传送到外部接口（如系统总线）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将数据由外部接口传送到寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将寄存器作为输入和输出，完成算术和逻辑运算&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实现&#34;&gt;#&lt;/a&gt; 实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;硬布线实现&lt;/strong&gt;（hardwired implementation）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;微程序实现&lt;/strong&gt;（microprogrammed implementation）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;硬布线实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#硬布线实现&#34;&gt;#&lt;/a&gt; 硬布线实现&lt;/h4&gt;
&lt;p&gt;控制器是一个组合电路，把输入逻辑信号转换为一组输出逻辑信号，即控制信号&lt;/p&gt;
&lt;h4 id=&#34;微程序实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#微程序实现&#34;&gt;#&lt;/a&gt; 微程序实现&lt;/h4&gt;
&lt;p&gt;控制逻辑是微程序指定的，控制器是一个相对简单的逻辑电路，通过执行每条微指令来产生控制信号&lt;/p&gt;
&lt;p&gt;微程序（固件）介于硬件与软件之间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点与缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简化了控制器的设计任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现起来既成本较低，也能减少出错机会&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;便于更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要比采用相同或相近半导体工艺的硬布线控制器慢一些&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/COA14/</guid>
            <title>计组期末复习第十四讲 指令周期与指令流水线</title>
            <link>https://erinwithbmq.github.io/2025/01/11/COA14/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="计算机组织结构" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 19:36:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;LaTeX 渲染有问题。将就着看吧。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&#34;指令周期&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指令周期&#34;&gt;#&lt;/a&gt; 指令周期&lt;/h2&gt;
&lt;p&gt;指令周期：处理单个指令的过程（时间）&lt;/p&gt;
&lt;p&gt;取指周期：从内存中提取一条指令&lt;/p&gt;
&lt;p&gt;执行周期：执行所提取的指令&lt;/p&gt;
&lt;p&gt;还可能有中断周期、间址周期&lt;/p&gt;
&lt;h3 id=&#34;间址周期&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#间址周期&#34;&gt;#&lt;/a&gt; 间址周期&lt;/h3&gt;
&lt;p&gt;间址周期：把间接地址的读取看成是一个额外的指令子周期&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA14/274c366cb6404d1a22a876a8e6ac932a.png&#34; alt=&#34;274c366cb6404d1a22a876a8e6ac932a.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;cpu-的任务与需求&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cpu-的任务与需求&#34;&gt;#&lt;/a&gt; CPU 的任务与需求&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA14/3882187eb23f1c685343376c0070d4fc.png&#34; alt=&#34;3882187eb23f1c685343376c0070d4fc.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;取指令（从特定地方获取），解释指令（译码），取数据（从特定地方获取），处理数据（如进行算术运算），写数据（写入特定地方）&lt;/p&gt;
&lt;h2 id=&#34;数据流&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据流&#34;&gt;#&lt;/a&gt; 数据流&lt;/h2&gt;
&lt;h3 id=&#34;取值周期&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#取值周期&#34;&gt;#&lt;/a&gt; 取值周期&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;控制器下达指令：取指周期的开始。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 MAR 将地址传入地址总线&lt;/p&gt;
&lt;p&gt;控制器通过控制线通知存储器地址就绪&lt;/p&gt;
&lt;p&gt;存储器读取地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储器通过数据总线将数据发送给 MBR&lt;/p&gt;
&lt;p&gt;如果是异步总线，存储器提供反馈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指令取回来后，PC+“1”&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;间址周期-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#间址周期-2&#34;&gt;#&lt;/a&gt; 间址周期&lt;/h3&gt;
&lt;p&gt;将 MBR 中的&lt;strong&gt;地址引用送入 MAR&lt;/strong&gt; 得到地址&lt;/p&gt;
&lt;p&gt;MAR 将地址传入地址总线&lt;/p&gt;
&lt;p&gt;控制器通知&lt;strong&gt;存储器取地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储器通过数据总线将&lt;strong&gt;有效地址发送给 MBR&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;中断周期&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#中断周期&#34;&gt;#&lt;/a&gt; 中断周期&lt;/h3&gt;
&lt;p&gt;处理中断前，将下一条指令放到 MBR 中，再放到数据总线上&lt;/p&gt;
&lt;p&gt;控制器将下一条指令的取值地址通过 MAR 放到地址总线上&lt;/p&gt;
&lt;p&gt;控制器通知存储器获得数据&lt;/p&gt;
&lt;p&gt;存储器从地址线获得地址&lt;/p&gt;
&lt;p&gt;存储器从数据线获得数据，并将数据写入到获得的地址&lt;/p&gt;
&lt;h2 id=&#34;指令流水线&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指令流水线&#34;&gt;#&lt;/a&gt; 指令流水线&lt;/h2&gt;
&lt;h3 id=&#34;两阶段方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#两阶段方法&#34;&gt;#&lt;/a&gt; 两阶段方法&lt;/h3&gt;
&lt;p&gt;将指令处理分成两个阶段：取指令和执行指令&lt;/p&gt;
&lt;h3 id=&#34;六阶段方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#六阶段方法&#34;&gt;#&lt;/a&gt; 六阶段方法&lt;/h3&gt;
&lt;p&gt;为了进一步的加速，流水线必须有&lt;strong&gt;更多的阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;取指令&lt;/strong&gt;（Fetch instruction，FI）：读下一条预期的指令到缓冲器&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;译码指令&lt;/strong&gt;（Decode instruction，DI）：确定操作码和操作数指定符&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;计算操作数&lt;/strong&gt;（Calculate operands，CO）：计算每个源操作数的有效地址&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;取操作数&lt;/strong&gt;（Fetch operands，FO）：从存储器取出每个操作数，寄存器 中的操作数不需要取&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;执行指令&lt;/strong&gt;（Execute instruction，EI）：完成指定的操作。若有指定的目 的操作数位置，则将结果写入此位置&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;写操作数&lt;/strong&gt;（Write operand，WO）：将结果存入存储器&lt;/p&gt;
&lt;h3 id=&#34;流水线性能&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#流水线性能&#34;&gt;#&lt;/a&gt; 流水线性能&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA14/75a8ce7a9da4d09beba328505bcfb97c.png&#34; alt=&#34;75a8ce7a9da4d09beba328505bcfb97c.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加速比：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA14/37ed6e00bc2d027c051bd3f8c389dbf7.png&#34; alt=&#34;37ed6e00bc2d027c051bd3f8c389dbf7.png&#34; /&gt;&lt;/p&gt;
&lt;p k+(n-1)=&#34;&#34;&gt;S_k = \frac{T_{1,n}}{T_{k,n}} = \frac{nkt}{[k+(n-1)]t}=\frac{nk}&lt;/p&gt;
&lt;h2 id=&#34;冒险&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#冒险&#34;&gt;#&lt;/a&gt; 冒险&lt;/h2&gt;
&lt;h3 id=&#34;数据冒险&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据冒险&#34;&gt;#&lt;/a&gt; 数据冒险&lt;/h3&gt;
&lt;p&gt;数据依赖性&lt;/p&gt;
&lt;p&gt;有些数据要等前序计算完成&lt;/p&gt;
&lt;p&gt;解决方案 1：插入&lt;strong&gt; nop 指令&lt;/strong&gt;（软件）（不进行任何操作）&lt;/p&gt;
&lt;p&gt;解决方案 2：插入&lt;strong&gt; bubble&lt;/strong&gt;（硬件）&lt;/p&gt;
&lt;p&gt;解决方案 3：前递（forwarding）/ &lt;strong&gt;旁路&lt;/strong&gt;（bypassing）（快速传递数据）&lt;/p&gt;
&lt;p&gt;解决方案 4：&lt;strong&gt;交换&lt;/strong&gt;指令顺序&lt;/p&gt;
&lt;h3 id=&#34;控制冒险&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#控制冒险&#34;&gt;#&lt;/a&gt; 控制冒险&lt;/h3&gt;
&lt;p&gt;指令的执行顺序被更改&lt;/p&gt;
&lt;p&gt;解决方案 1：&lt;strong&gt;提早确定&lt;/strong&gt;分支&lt;/p&gt;
&lt;p&gt;解决方案 2：取&lt;strong&gt;多条指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方案 3：分支&lt;strong&gt;预测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态预测（规则不变）&lt;/p&gt;
&lt;p&gt;动态预测（规则变化）&lt;/p&gt;
&lt;p&gt;解决方案 4：&lt;strong&gt;交换&lt;/strong&gt;指令顺序&lt;/p&gt;
&lt;h3 id=&#34;结构冒险&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#结构冒险&#34;&gt;#&lt;/a&gt; 结构冒险&lt;/h3&gt;
&lt;p&gt;已进入流水线的不同指令在同一时刻访问相同的硬件资源（内存或寄存器）&lt;/p&gt;
&lt;p&gt;解决：使用多个不同的硬件资源，或者分时使用同一个硬件资源&lt;/p&gt;
&lt;p&gt;解决方案 1：流水线停顿（stall），&lt;strong&gt;插入空泡&lt;/strong&gt;（bubble）&lt;/p&gt;
&lt;p&gt;解决方案 2：使用不同用途的&lt;strong&gt;多个存储器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方案 3：同一个存储器提供&lt;strong&gt;分时处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是 GPT 写的：&lt;/p&gt;
&lt;p&gt;在计算机体系结构中，** 冒险（Hazard）** 是指在指令流水线（Pipeline）中，由于某些原因，指令无法按预期执行，导致执行暂停或结果错误。冒险通常分为三种类型：结构冒险、数据冒险和控制冒险。下面分别介绍这三种冒险：&lt;/p&gt;
&lt;h3 id=&#34;1-结构冒险structural-hazard&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-结构冒险structural-hazard&#34;&gt;#&lt;/a&gt; 1. 结构冒险（Structural Hazard）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：结构冒险是由于硬件资源冲突导致的流水线停顿，通常发生在多个指令需要同时使用相同硬件资源时，导致资源无法同时满足所有指令的需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指令流水线中的不同阶段可能会共享相同的硬件资源，例如 ALU（算术逻辑单元）、寄存器堆、内存总线等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果两个或多个指令在同一时刻需要访问相同的硬件资源，硬件资源就无法同时满足所有指令的需求，从而引发结构冒险。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在一个简单的流水线中，如果同时有两条指令需要访问内存（例如一条加载指令和一条存储指令），而只有一个内存访问单元时，就会发生结构冒险。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类似地，如果同一时刻多个指令需要访问 ALU，但 ALU 资源有限，也可能发生结构冒险。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;增加硬件资源（如多路复用器、独立的内存访问端口等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用流水线阶段的资源调度技术，确保指令不同时访问相同的资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-数据冒险data-hazard&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-数据冒险data-hazard&#34;&gt;#&lt;/a&gt; 2. 数据冒险（Data Hazard）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：数据冒险发生在指令间存在数据依赖时，前序指令的结果尚未计算出来，后续指令需要依赖该结果，从而导致停顿或错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据冒险类型&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;读后写（RAW，Read After Write）&lt;/strong&gt;：也称为真正的数据依赖。后续指令需要读取前序指令计算的结果，但该结果尚未写回寄存器或内存，导致后续指令无法执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;ADD R1, R2, R3  // R1 = R2 + R3
SUB R4, R1, R5  // 需要R1的值，但R1尚未计算出来
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在此例中，第二条指令需要依赖第一条指令计算的 R1 的值，但由于第一条指令尚未完成，第二条指令不能立即执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写后读（WAR，Write After Read）&lt;/strong&gt;：后续指令写入寄存器的值会覆盖前序指令的结果，导致数据依赖错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;ADD R1, R2, R3  // R1 = R2 + R3
SUB R2, R1, R5  // 需要R1的值，但R2被后续指令修改
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写后写（WAW，Write After Write）&lt;/strong&gt;：前序指令和后续指令都试图向同一寄存器写值，顺序不一致会导致数据错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;ADD R1, R2, R3  // R1 = R2 + R3
SUB R1, R4, R5  // R1被修改
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;流水线插入气泡（Pipeline Stalls）&lt;/strong&gt;：通过插入 “空指令”（气泡）来等待读取数据，减少数据依赖冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据前推（Data Forwarding/Bypassing）&lt;/strong&gt;：将计算结果直接从一个流水线阶段传送到需要的后续阶段，避免等待数据写回寄存器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重排序（Instruction Reordering）&lt;/strong&gt;：重新排列指令的顺序，避免数据依赖冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-控制冒险control-hazard&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-控制冒险control-hazard&#34;&gt;#&lt;/a&gt; 3. 控制冒险（Control Hazard）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：控制冒险是由于程序中的控制指令（如跳转、分支等）导致流水线不能确定下一条指令是哪一条，从而发生停顿或错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当程序遇到分支指令时，流水线无法提前知道分支的目标地址，因此必须等待分支指令执行完成以确定跳转的目标。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这通常发生在条件分支指令（如 &lt;code&gt;if&lt;/code&gt;  语句、循环等）和无条件跳转指令（如 &lt;code&gt;goto&lt;/code&gt; 、 &lt;code&gt;return&lt;/code&gt;  等）之后。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;BEQ R1, R2, LABEL  // 如果R1 == R2，跳转到LABEL
ADD R3, R4, R5     // 该指令要等BEQ完成才能执行，因为BEQ决定了跳转
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在此例中， &lt;code&gt;BEQ&lt;/code&gt;  指令的执行结果不确定，直到它被完全执行后，流水线才能知道是否跳转以及跳转到哪个地址，从而导致控制冒险。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分支预测（Branch Prediction）&lt;/strong&gt;：根据历史执行模式预测分支的方向，提前加载指令。如果预测正确，可以减少控制冒险的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;延迟分支（Delayed Branch）&lt;/strong&gt;：在分支指令后插入一条可以执行的指令，即使分支未确定，流水线仍然可以继续执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态分支预测（Dynamic Branch Prediction）&lt;/strong&gt;：使用硬件动态调整分支预测策略，通过复杂的算法来预测跳转指令的目标。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提早确定分支&lt;/strong&gt;（？）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;总结来说，冒险的出现是因为流水线中的不同阶段存在相互依赖和硬件资源竞争。通过优化硬件和采用各种技术（如数据前推、分支预测等），可以最大限度地减少冒险对流水线性能的影响。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/COA13/</guid>
            <title>计组期末复习第十三讲 指令系统</title>
            <link>https://erinwithbmq.github.io/2025/01/11/COA13/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="计算机组织结构" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 19:34:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;LaTeX 渲染有问题。将就着看吧。&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id=&#34;指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指令&#34;&gt;#&lt;/a&gt; 指令&lt;/h1&gt;
&lt;p&gt;指令是计算机处理的最基本单位&lt;/p&gt;
&lt;p&gt;操作码（指令执行的内容）+ 操作数（要操作的对象）&lt;/p&gt;
&lt;p&gt;多周期实现方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;取指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;译码 / 取寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行 / 有效地址 / 完成分支&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问内存，存储结果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;源操作数引用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果操作数引用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下一指令引用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;指令格式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指令格式&#34;&gt;#&lt;/a&gt; 指令格式&lt;/h2&gt;
&lt;h3 id=&#34;扩展操作码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#扩展操作码&#34;&gt;#&lt;/a&gt; 扩展操作码&lt;/h3&gt;
&lt;p&gt;不同地址数的指令具有不同长度的操作码&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA13/849b68ccb8402d2588526f25cb5f9d30.png&#34; alt=&#34;849b68ccb8402d2588526f25cb5f9d30.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;怎么区分？&lt;strong&gt;看最前面有多少个 1&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;例题：&lt;/p&gt;
&lt;p&gt;假设指令字长为 16 位，操作数的地址码为 6 位，指令有零地址、一地址、二地址 3 种格式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设操作码固定，若零地址指令有 M 种，一地址指令有 N 种，则二地址指令最多有几种？&lt;/p&gt;
&lt;p&gt;由于操作码固定，最多有二地址，则 16 - 6 * 2 = 4，操作码有 4 位&lt;/p&gt;
&lt;p&gt;那么总共有 16 种指令。&lt;/p&gt;
&lt;p&gt;二地址指令有 16 - M - N 种。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用扩展操作码技术，二地址指令最多有几种？&lt;/p&gt;
&lt;p&gt;对于二地址指令操作码有 4 位，&lt;strong&gt;全 1 不可用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0000~1110, 15 种&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用扩展操作码技术，若二地址指令有 P 条，零地址指令有 Q 条，则一地址指令最多有几种？&lt;/p&gt;
&lt;p&gt;2^4 - P：二地址没有用的操作码（指令前缀）个数（4 位）&lt;/p&gt;
&lt;p&gt;(2^4 - P）* 2^6：一地址总共可以表示的总数（一地址操作码为 10 位）&lt;/p&gt;
&lt;p&gt;(2^4 - P）* 2^6 - R：一地址没有用的操作码个数&lt;/p&gt;
&lt;p&gt;[(2^4 - P）* 2^6 - R] * 2^6：零地址总共可以表示的总数&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;Q = [(2^4 - P）&lt;/em&gt; 2^6 - R] * 2^6&lt;/em&gt;*&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;寻址方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#寻址方式&#34;&gt;#&lt;/a&gt; 寻址方式&lt;/h2&gt;
&lt;h3 id=&#34;记号&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#记号&#34;&gt;#&lt;/a&gt; 记号&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A: 指令中地址字段的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;R: 指向寄存器的指令地址字段内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EA: 被访问位置的实际（有效）地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(X): &lt;strong&gt;存储器位置 X 或寄存器 X 的内容&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;操作数 = (EA)，即操作数为 EA 内的内容&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;立即寻址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#立即寻址&#34;&gt;#&lt;/a&gt; 立即寻址&lt;/h3&gt;
&lt;p&gt;操作数 = A&lt;/p&gt;
&lt;p&gt;立即数。&lt;/p&gt;
&lt;h3 id=&#34;直接寻址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#直接寻址&#34;&gt;#&lt;/a&gt; 直接寻址&lt;/h3&gt;
&lt;p&gt;EA = A&lt;/p&gt;
&lt;p&gt;把地址写在指令里面，进行一次存储器访问&lt;/p&gt;
&lt;h3 id=&#34;间接寻址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#间接寻址&#34;&gt;#&lt;/a&gt; 间接寻址&lt;/h3&gt;
&lt;p&gt;EA = (A)&lt;/p&gt;
&lt;p&gt;两次存储器访问&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA13/7d5f5a89194f02dff0ad79122ad99017.png&#34; alt=&#34;7d5f5a89194f02dff0ad79122ad99017.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;寄存器寻址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#寄存器寻址&#34;&gt;#&lt;/a&gt; 寄存器寻址&lt;/h3&gt;
&lt;p&gt;EA = R&lt;/p&gt;
&lt;p&gt;给出寄存器编号，读寄存器内的值&lt;/p&gt;
&lt;h3 id=&#34;寄存器间接寻址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#寄存器间接寻址&#34;&gt;#&lt;/a&gt; 寄存器间接寻址&lt;/h3&gt;
&lt;p&gt;EA = (R)&lt;/p&gt;
&lt;p&gt;寄存器里存的是地址，拿到地址再读一次存储器&lt;/p&gt;
&lt;h3 id=&#34;偏移寻址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#偏移寻址&#34;&gt;#&lt;/a&gt; 偏移寻址&lt;/h3&gt;
&lt;p&gt;EA = (R) + A&lt;/p&gt;
&lt;p&gt;在读出的地址上加一个立即数得到新的地址&lt;/p&gt;
&lt;p&gt;类型&lt;/p&gt;
&lt;p&gt;相对寻址&lt;/p&gt;
&lt;p&gt;基址寄存器寻址&lt;/p&gt;
&lt;p&gt;变址寻址&lt;/p&gt;
&lt;h4 id=&#34;偏移寻址相对寻址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#偏移寻址相对寻址&#34;&gt;#&lt;/a&gt; 偏移寻址：相对寻址&lt;/h4&gt;
&lt;p&gt;隐含引用的寄存器是程序计数器（PC）&lt;/p&gt;
&lt;p&gt;EA = (PC) + A&lt;/p&gt;
&lt;p&gt;在 PC 寄存器读出的地址上加一个立即数得到新的地址&lt;/p&gt;
&lt;h4 id=&#34;偏移寻址基址寄存器寻址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#偏移寻址基址寄存器寻址&#34;&gt;#&lt;/a&gt; 偏移寻址：基址寄存器寻址&lt;/h4&gt;
&lt;p&gt;EA = (B) + A&lt;/p&gt;
&lt;p&gt;在寄存器读出的地址上加一个立即数得到新的地址&lt;/p&gt;
&lt;h4 id=&#34;偏移寻址变址寻址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#偏移寻址变址寻址&#34;&gt;#&lt;/a&gt; 偏移寻址：变址寻址&lt;/h4&gt;
&lt;p&gt;EA = A + (IX)&lt;/p&gt;
&lt;p&gt;A 是基地址，从寄存器 IX 里读出一个数与它相加得到新的地址&lt;/p&gt;
&lt;h3 id=&#34;栈寻址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#栈寻址&#34;&gt;#&lt;/a&gt; 栈寻址&lt;/h3&gt;
&lt;p&gt;方式：栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种&lt;strong&gt;寄存器间接寻址方式&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;指令格式的设计原则&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指令格式的设计原则&#34;&gt;#&lt;/a&gt; 指令格式的设计原则&lt;/h2&gt;
&lt;p&gt;指令尽量短&lt;/p&gt;
&lt;p&gt;有足够的操作码位数&lt;/p&gt;
&lt;p&gt;操作码的编码必须有唯一的解释&lt;/p&gt;
&lt;p&gt;指令长度是字节的整数倍&lt;/p&gt;
&lt;p&gt;合理选择地址字段的个数&lt;/p&gt;
&lt;p&gt;指令尽量规整&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/COA12/</guid>
            <title>计组期末复习第十二讲 总线</title>
            <link>https://erinwithbmq.github.io/2025/01/11/COA12/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="计算机组织结构" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 19:33:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;LaTeX 渲染有问题。将就着看吧。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;芯片内部总线&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统总线&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通信总线&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;总线结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#总线结构&#34;&gt;#&lt;/a&gt; 总线结构&lt;/h1&gt;
&lt;h3 id=&#34;数据线&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据线&#34;&gt;#&lt;/a&gt; 数据线&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;系统组件&lt;/strong&gt;之间传输数据&lt;/p&gt;
&lt;p&gt;数据线的数量决定了一次可以&lt;strong&gt;传输的数据的大小&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;地址线&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#地址线&#34;&gt;#&lt;/a&gt; 地址线&lt;/h3&gt;
&lt;p&gt;在数据线和地址 I/O 端口上指定数据的来源和去向&lt;/p&gt;
&lt;p&gt;地址线的数量决定了&lt;strong&gt;寻址空间&lt;/strong&gt;的大小&lt;/p&gt;
&lt;p&gt;即：如果寻址空间为 2^32，那么地址线有 32 根&lt;/p&gt;
&lt;p&gt;两台地址线数量相同的计算机，寻址空间的大小一样吗？&lt;/p&gt;
&lt;p&gt;其理论寻址空间是相同的，但 &lt;strong&gt;实际寻址空间大小&lt;/strong&gt; 和 &lt;strong&gt;使用方式&lt;/strong&gt; 可能不同，取决于多种其他因素。&lt;/p&gt;
&lt;h3 id=&#34;控制线&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#控制线&#34;&gt;#&lt;/a&gt; &lt;strong&gt;控制线&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;控制对数据线和地址线的存取和使用&lt;/p&gt;
&lt;p&gt;・时钟（clock）：用于总线同步操作&lt;/p&gt;
&lt;p&gt;・总线请求（bus request）：表示模块需要获得对总线的控制&lt;/p&gt;
&lt;p&gt;・总线允许（bus grant）：发出请求的设备已经被允许控制总线&lt;/p&gt;
&lt;p&gt;・中断请求（interrupt request）：表示某个中断正在悬而未决&lt;/p&gt;
&lt;p&gt;・中断响应（interrupt ACK）：未决的终端请求被响应&lt;/p&gt;
&lt;p&gt;・存储器读（memory read）：从存储器读数据到总线&lt;/p&gt;
&lt;p&gt;・存储器写（memory write）：将数据从总线写入存储器&lt;/p&gt;
&lt;p&gt;・I/O 读（I/O read）：从 I/O 端口读数据到总线&lt;/p&gt;
&lt;p&gt;・I/O 写（I/O write）：将数据从总线写入 I/O 端口&lt;/p&gt;
&lt;p&gt;• ……&lt;/p&gt;
&lt;h1 id=&#34;总线上数据传输的特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#总线上数据传输的特点&#34;&gt;#&lt;/a&gt; 总线上数据传输的特点&lt;/h1&gt;
&lt;p&gt;总线可以被&lt;strong&gt;多个设备监听&lt;/strong&gt;，但同一时刻只能由&lt;strong&gt;一个设备&lt;/strong&gt;发送数据&lt;/p&gt;
&lt;p&gt;当总线在被使用过程中，其它设备&lt;strong&gt;不可以抢占&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果设备想发送数据 / 请求数据，需要先&lt;strong&gt;获得总线的使用权&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;设计要素&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#设计要素&#34;&gt;#&lt;/a&gt; 设计要素&lt;/h1&gt;
&lt;h2 id=&#34;用途&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用途&#34;&gt;#&lt;/a&gt; 用途&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;专用（dedicated）总线&lt;/strong&gt;：始终只负责一项功能，或始终分配给特定的计算 机组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复用（multiplexed）总线&lt;/strong&gt;：将同一线路用于多种用途&lt;/p&gt;
&lt;h2 id=&#34;仲裁与仲裁方案&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#仲裁与仲裁方案&#34;&gt;#&lt;/a&gt; 仲裁与仲裁方案&lt;/h2&gt;
&lt;p&gt;当多个设备需要与总线通信时，通过某种策略选择一个设备&lt;/p&gt;
&lt;p&gt;仲裁方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;集中式&lt;/strong&gt;（centralized）：由&lt;strong&gt;仲裁器&lt;/strong&gt;（arbiter）或&lt;strong&gt;总线控制器&lt;/strong&gt;（bus controller）负责&lt;strong&gt;分配总线使用权&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;链式查询 / 菊花链&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计数器查询&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独立请求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分布式&lt;/strong&gt;（distributed）：每个设备都包含访问控制逻辑，各设备共同作用分享总线&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自举式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冲突检测&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;链式查询&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#链式查询&#34;&gt;#&lt;/a&gt; 链式查询&lt;/h3&gt;
&lt;p&gt;所有的设备都是&lt;strong&gt;串行连接&lt;/strong&gt;的，并将&lt;strong&gt;允许信号&lt;/strong&gt;从&lt;strong&gt;优先级最高&lt;/strong&gt;的设备下发到&lt;strong&gt;优先级最低&lt;/strong&gt;的设备。&lt;/p&gt;
&lt;p&gt;总线仲裁器收到请求后，在&lt;strong&gt;总线不忙&lt;/strong&gt;的前提下，发起&lt;strong&gt;允许信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果某个设备&lt;strong&gt;收到了允许信号&lt;/strong&gt;并且&lt;strong&gt;发起了总线请求&lt;/strong&gt;，该设备将总线设置为&lt;strong&gt;繁忙&lt;/strong&gt;状态，允许信号将不再被进一步传递&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA12/197144221c5fbc9c6e686b852fcca5b9.png&#34; alt=&#34;197144221c5fbc9c6e686b852fcca5b9.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;确定优先级简单，可以灵活添加设备，但是不能保证公平性，限制总线的速度。&lt;/p&gt;
&lt;h3 id=&#34;计数器查询&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#计数器查询&#34;&gt;#&lt;/a&gt; 计数器查询&lt;/h3&gt;
&lt;p&gt;将总线允许线替换为&lt;strong&gt;设备 ID（地址）线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当总线仲裁器收到总线请求信号，判断总线&lt;strong&gt;空闲&lt;/strong&gt;时，计数器开始计数，计数值通过&lt;strong&gt;设备 ID 线&lt;/strong&gt;发向各个部件&lt;/p&gt;
&lt;p&gt;如果当前发送请求的设备 ID&lt;strong&gt; 等于&lt;/strong&gt;裁决器当前的计数，裁决器将停止计数，设备将总线设置为&lt;strong&gt;繁忙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人话就是仲裁器依次从高往低询问每个设备要不要使用总线，如果当前设备请求总线，则赋予其总线控制权，如果没有请求，则&lt;strong&gt;继续查询&lt;/strong&gt;下一个设备。&lt;/p&gt;
&lt;p&gt;一旦某个设备获得总线控制权，其他设备需要等待其释放总线后才能竞争。&lt;/p&gt;
&lt;p&gt;强调优先级和公平性，但是限制总线的速度。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA12/345f37f2276b2624abadc1b28b3391b8.png&#34; alt=&#34;345f37f2276b2624abadc1b28b3391b8.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;独立请求&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#独立请求&#34;&gt;#&lt;/a&gt; 独立请求&lt;/h3&gt;
&lt;p&gt;每个设备都有自己的&lt;strong&gt;总线请求线和总线允许线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总线仲裁器决定哪个设备可以使用总线&lt;/p&gt;
&lt;p&gt;有很多确定策略：固定优先级，公平链式，LRU，FIFO，…&lt;/p&gt;
&lt;p&gt;快速响应，可编程的优先级，但是逻辑更复杂，线路更多&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA12/73c85b510ec39c44c344c7417ce262a1.png&#34; alt=&#34;73c85b510ec39c44c344c7417ce262a1.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;自举式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#自举式&#34;&gt;#&lt;/a&gt; 自举式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;固定优先级&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个设备&lt;strong&gt;在其总线请求线&lt;/strong&gt;上发送请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最低优先级的设备没有请求线&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个设备自行判断自己是否在请求总线的设备中优先级最高&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA12/2c0ae01f5a75dd975a3a5a5d22d8dc25.png&#34; alt=&#34;2c0ae01f5a75dd975a3a5a5d22d8dc25.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;时序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#时序&#34;&gt;#&lt;/a&gt; 时序&lt;/h2&gt;
&lt;p&gt;确定每个总线事务的&lt;strong&gt;开始和结束时间&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;同步时序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#同步时序&#34;&gt;#&lt;/a&gt; 同步时序&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA12/b373550f1d75534e4ddb603ba8c8ebf5.png&#34; alt=&#34;b373550f1d75534e4ddb603ba8c8ebf5.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所有设备&lt;strong&gt;共享同一个时钟&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;异步时序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#异步时序&#34;&gt;#&lt;/a&gt; 异步时序&lt;/h3&gt;
&lt;p&gt;异步时序（Asynchronous Timing）是指总线通信过程中不依赖全局时钟，而是通过 &lt;strong&gt;握手信号&lt;/strong&gt; 来协调各设备之间的操作。&lt;/p&gt;
&lt;p&gt;分为非互锁、半互锁、全互锁。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA12/e62bf4b220c06f86733747af020b0ad7.png&#34; alt=&#34;e62bf4b220c06f86733747af020b0ad7.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA12/ef04e187ba71f25f4caee9e79fa29068.png&#34; alt=&#34;ef04e187ba71f25f4caee9e79fa29068.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;半同步时序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#半同步时序&#34;&gt;#&lt;/a&gt; 半同步时序&lt;/h3&gt;
&lt;p&gt;为了减少噪声的影响，在异步计时中使用时钟&lt;/p&gt;
&lt;p&gt;准备和响应信号在时钟&lt;strong&gt;上升沿&lt;/strong&gt;有效&lt;/p&gt;
&lt;h3 id=&#34;分离事务&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分离事务&#34;&gt;#&lt;/a&gt; 分离事务&lt;/h3&gt;
&lt;p&gt;将一个总线事件分离为&lt;strong&gt;两个过程&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;总线带宽和数据传输速率&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#总线带宽和数据传输速率&#34;&gt;#&lt;/a&gt; 总线带宽和数据传输速率&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;总线带宽&lt;/strong&gt;（bus bandwidth）：总线的&lt;strong&gt;最大&lt;/strong&gt;数据传输速率&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要&lt;/strong&gt;考虑总线仲裁、地址传输等因素&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据传输速率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;考虑&lt;/strong&gt;地址传输、握手等因素&lt;/p&gt;
&lt;h2 id=&#34;同步总线和异步总线的数据传输速率&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#同步总线和异步总线的数据传输速率&#34;&gt;#&lt;/a&gt; 同步总线和异步总线的数据传输速率&lt;/h2&gt;
&lt;p&gt;** 例题 1：** 假设同步总线的时钟周期为 50ns，每次传输需要一个时钟周期，异步 总线每次握手需要 40ns。两个总线都是 32 位宽，内存的数据准备时间为 200ns。 &lt;strong&gt;当从存储器中读出一个 32 位的字时&lt;/strong&gt;，计算两个总线的数据传输速率。&lt;/p&gt;
&lt;p&gt;同步总线：&lt;/p&gt;
&lt;p&gt;从存储器中读出一个 32 位的字，三个流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU 发送指令和地址到内存：50ns&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存准备数据：200ns&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将数据传输回 CPU：50ns&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于一次传递 32 位，速率单位为 bps&lt;/p&gt;
&lt;p&gt;所以：数据传输速率 = 32bit / (50 + 200 + 50) ns = 106.7Mbps&lt;/p&gt;
&lt;p&gt;（1 ns 等于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;9&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;10^{-9}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; s）&lt;/p&gt;
&lt;p&gt;异步总线：&lt;/p&gt;
&lt;p&gt;步骤 1：40 ns&lt;/p&gt;
&lt;p&gt;步骤 2、3、4 / 数据准备：max (40ns* 3,200ns) = 200ns&lt;/p&gt;
&lt;p&gt;步骤 5、6、7：40ns * 3 = 120ns&lt;/p&gt;
&lt;p&gt;数据传输速率 = 32bit / (40 + 200 + 120) ns = 88.9Mbps&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA12/1f44d4181a9237b28d969db2c6151274.png&#34; alt=&#34;1f44d4181a9237b28d969db2c6151274.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;每一步的解释看上面&lt;/p&gt;
&lt;p&gt;** 例题 2：** 假设同步总线的时钟周期为 50ns，每次传输需要一个时钟周期，异步 总线每次握手需要 40ns。两个总线都是 32 位宽，存储器的数据准备时间为 230ns。当从存储器中读出一个 32 位的字时，计算两个总线的数据传输速率。&lt;/p&gt;
&lt;p&gt;同步总线&lt;/p&gt;
&lt;p&gt;数据传输速率 = 32bit / (50 + &lt;strong&gt;250&lt;/strong&gt; + 50)ns = 91.4Mbps&lt;/p&gt;
&lt;p&gt;250 是因为需要是&lt;strong&gt;时钟周期的倍数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;异步总线&lt;/p&gt;
&lt;p&gt;数据传输速率 = 32bit / (40 + 230 + 120) ns = 82.1Mbps&lt;/p&gt;
&lt;p&gt;40：步骤 1&lt;/p&gt;
&lt;p&gt;230：max（40*3,230）&lt;/p&gt;
&lt;p&gt;120：40*3&lt;/p&gt;
&lt;h2 id=&#34;不同数据块大小的数据传输速率&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#不同数据块大小的数据传输速率&#34;&gt;#&lt;/a&gt; 不同数据块大小的数据传输速率&lt;/h2&gt;
&lt;p&gt;** 例题 3：** 假设系统具有以下特征:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;它支持访问大小为 4 到 16 个字（每个字 32 位）的块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步总线具有&lt;strong&gt; 64 位宽&lt;/strong&gt;和&lt;strong&gt; 200MHz 时钟频率&lt;/strong&gt;，需要&lt;strong&gt; 1 个时钟周期&lt;/strong&gt;来传输地址或 64 位数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在两个总线事务之间有&lt;strong&gt; 2 个空闲时钟周期&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存访问时准备&lt;strong&gt;前 4 个字需要 200ns&lt;/strong&gt;，后面&lt;strong&gt;每 4 个字&lt;/strong&gt;准备需要 20ns&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当前面的数据在总线上传输时，内存可以&lt;strong&gt;同时读取后面的数据&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果读取 256 个字，分别计算每次传输 4 个字和 16 个字时的数据传输速率、 传输时间和每秒总线事务数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次传输 4 个字：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;200MHz 时钟频率 → 5ns 一个时钟周期&lt;/p&gt;
&lt;p&gt;先计算总共的时间周期：&lt;/p&gt;
&lt;p&gt;总线事务：传地址＋传 4 个字&lt;/p&gt;
&lt;p&gt;地址传输：需要 1 个时钟周期&lt;/p&gt;
&lt;p&gt;数据准备：需要 200ns (40 个时钟周期)&lt;/p&gt;
&lt;p&gt;数据传输：2 个时钟周期（一个时钟周期传输 64 位，4*32/64=2）&lt;/p&gt;
&lt;p&gt;空闲：2 个时钟周期&lt;/p&gt;
&lt;p&gt;总共传 256 个字，256/4=64，传 64 次&lt;/p&gt;
&lt;p&gt;因此总共：64*（1+40+2+2）=2880 个时钟周期&lt;/p&gt;
&lt;p&gt;传输时间：2880 * 5 ns = 14400 ns&lt;/p&gt;
&lt;p&gt;每秒总线事务数：&lt;/p&gt;
&lt;p&gt;单次时间：（1+40+2+2）*5=225ns&lt;/p&gt;
&lt;p&gt;每秒总线事务数 = 1s / 225ns = 4.44M&lt;/p&gt;
&lt;p&gt;数据传输速率：总传输数据量 / 总时间&lt;/p&gt;
&lt;p&gt;256 * 32bit / 14400ns = 568.9Mbps&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次传输 16 个字：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先计算总共的时间周期：&lt;/p&gt;
&lt;p&gt;总线事务：传地址＋传 16 个字&lt;/p&gt;
&lt;p&gt;地址传输：需要 1 个时钟周期&lt;/p&gt;
&lt;p&gt;数据准备（前四个字）：需要 200ns (40 个时钟周期)&lt;/p&gt;
&lt;p&gt;数据传输：2 个时钟周期（同时读取后 4 个字：20ns，4 个时钟周期）&lt;/p&gt;
&lt;p&gt;空闲：2 个时钟周期&lt;/p&gt;
&lt;p&gt;总共传 256 个字，256/16=16，传 64 次&lt;/p&gt;
&lt;p&gt;因此总共：16 *（1+40+ 3 * max（2 , 4）+ 2+2）= 912 个时钟周期&lt;/p&gt;
&lt;p&gt;解释一下，还是一次传 4 个字，16 个字传 4 组。在传第 1 组时，同时读取第 2 组数据，4&amp;gt;2 所以耗费 4 个时钟周期，同理传第 2 组读第 3 组，传第 3 组读第 4 组，都是 4 个时钟周期。传第 4 组时，不用读数据了，因此 2 个时钟周期即可。&lt;/p&gt;
&lt;p&gt;传输时间： 912 * 5 ns = 4560 ns&lt;/p&gt;
&lt;p&gt;每秒总线事务数：&lt;/p&gt;
&lt;p&gt;单次时间：（1+40+ 3 * max（2 , 4）+ 2+2）*5=285ns&lt;/p&gt;
&lt;p&gt;每秒总线事务数 = 1s / 285ns = 4.44M&lt;/p&gt;
&lt;p&gt;数据传输速率：总传输数据量 / 总时间&lt;/p&gt;
&lt;p&gt;256 * 32bit / 4560ns = 1796.5Mbps&lt;/p&gt;
&lt;h2 id=&#34;提高总线的数据传输率&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#提高总线的数据传输率&#34;&gt;#&lt;/a&gt; 提高总线的数据传输率&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;提高时钟频率（时钟周期数不变的情况下）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;增加数据总线宽度，每次传输更多的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;块传输，传输一次地址就传输一块数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分离总线事务，减少总线空闲时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分离地址线和数据线，同时传输地址和数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;总线层次结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#总线层次结构&#34;&gt;#&lt;/a&gt; 总线层次结构&lt;/h1&gt;
&lt;h2 id=&#34;单总线结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#单总线结构&#34;&gt;#&lt;/a&gt; 单总线结构&lt;/h2&gt;
&lt;p&gt;CPU、存储器和 I/O 模块都连接到&lt;strong&gt;一条系统总线&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;双总线结构i&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#双总线结构i&#34;&gt;#&lt;/a&gt; 双总线结构 I&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA12/04a72126603bd6219207a1f08cb3edf8.png&#34; alt=&#34;04a72126603bd6219207a1f08cb3edf8.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在 CPU 和存储器中间增加一个&lt;strong&gt;存储器总线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增加 CPU 和存储器之间的传输效率，同时降低系统总线的负担&lt;/p&gt;
&lt;h2 id=&#34;双总线结构ii&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#双总线结构ii&#34;&gt;#&lt;/a&gt; 双总线结构 II&lt;/h2&gt;
&lt;p&gt;将系统总线分为&lt;strong&gt;存储器总线&lt;/strong&gt;、&lt;strong&gt;I/O 总线&lt;/strong&gt; 和 &lt;strong&gt;IOP&lt;/strong&gt;(input/output processer)&lt;/p&gt;
&lt;p&gt;降低 I/O 对总线的负担&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA12/image.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;多总线结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#多总线结构&#34;&gt;#&lt;/a&gt; 多总线结构&lt;/h2&gt;
&lt;p&gt;都是增加 I/O 交互效率的。略&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/COA11/</guid>
            <title>计组期末复习第十一讲 虚拟存储器</title>
            <link>https://erinwithbmq.github.io/2025/01/11/COA11/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="计算机组织结构" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 19:32:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;LaTeX 渲染有问题。将就着看吧。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;虚拟存储器&lt;/p&gt;
&lt;p&gt;请求分页：每次访问仅将当前需要的页面调入主存，而其他不活跃的页面放在外存磁盘上&lt;/p&gt;
&lt;p&gt;虚拟地址&lt;/p&gt;
&lt;h3 id=&#34;分区方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分区方式&#34;&gt;#&lt;/a&gt; 分区方式&lt;/h3&gt;
&lt;p&gt;将主存分为两大区域&lt;/p&gt;
&lt;p&gt;系统区：固定的地址范围内，存放操作系统&lt;/p&gt;
&lt;p&gt;用户区：存放所有用户程序&lt;/p&gt;
&lt;p&gt;分区方式&lt;/p&gt;
&lt;p&gt;简单固定分区：用户区划分成长度不等的&lt;strong&gt;固定长&lt;/strong&gt;的分区&lt;/p&gt;
&lt;p&gt;可变长分区：用户区&lt;strong&gt;按每个任务所需要的内存大小&lt;/strong&gt;进行分配&lt;/p&gt;
&lt;h3 id=&#34;分页方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分页方式&#34;&gt;#&lt;/a&gt; 分页方式&lt;/h3&gt;
&lt;p&gt;把&lt;strong&gt;主存&lt;/strong&gt;分成&lt;strong&gt;固定长且比较小&lt;/strong&gt;的存储块，称为&lt;strong&gt;页框（page frame）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个&lt;strong&gt;任务&lt;/strong&gt;也被划分成&lt;strong&gt;固定长的程序块&lt;/strong&gt;，称为&lt;strong&gt;页（page）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将&lt;strong&gt;页装入页框&lt;/strong&gt;中，且&lt;strong&gt;无需采用&lt;/strong&gt;连续的页框来存放一个任务中所有的页&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑地址：指令&lt;/strong&gt;中的地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物理地址：&lt;strong&gt;实际&lt;/strong&gt;主存&lt;/strong&gt;地址&lt;/p&gt;
&lt;h1 id=&#34;虚拟存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#虚拟存储器&#34;&gt;#&lt;/a&gt; 虚拟存储器&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;请求分页&lt;/strong&gt;：仅将&lt;strong&gt;当前需要的的页&lt;/strong&gt;调入主存&lt;/p&gt;
&lt;p&gt;・通过硬件将&lt;strong&gt;逻辑地址&lt;/strong&gt;转换为&lt;strong&gt;物理地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;未命中时&lt;/strong&gt;在主存和硬盘之间交换信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;分页式&lt;/strong&gt;虚拟存储器&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;分段式&lt;/strong&gt;虚拟存储器&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;段页式&lt;/strong&gt;虚拟存储器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;映射算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;・全相联映射&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;・写回&lt;/p&gt;
&lt;h2 id=&#34;分页式虚拟存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分页式虚拟存储器&#34;&gt;#&lt;/a&gt; 分页式虚拟存储器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主存储器&lt;/strong&gt;和&lt;strong&gt;虚拟地址空间&lt;/strong&gt;都被划分为&lt;strong&gt;大小相等&lt;/strong&gt;的页面&lt;/p&gt;
&lt;p&gt;虚拟页（virtual page，VP）/ &lt;strong&gt;逻辑页&lt;/strong&gt;（logical page）：&lt;strong&gt;虚拟地址空间&lt;/strong&gt;中的页面&lt;/p&gt;
&lt;p&gt;物理页（physical page，PP）/ &lt;strong&gt;页框&lt;/strong&gt;（page frame）：&lt;strong&gt;主存空间&lt;/strong&gt;中的页面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;页表：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;页表中包含了&lt;strong&gt;所有虚拟页的信息&lt;/strong&gt;，包括虚拟页的存放位置、装入位（valid）、修改位（dirty）、存取权限位等等。保存在主存中。&lt;/p&gt;
&lt;p&gt;** 虚拟地址：** 虚拟页号 + 页内偏移量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快表（TLB）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;页表的使用增加了主存的访问次数&lt;/p&gt;
&lt;p&gt;为了减少访存次数，把页表中&lt;strong&gt;最活跃的几个页表项&lt;/strong&gt;复制到 ** 高速缓存（Cache）** 中&lt;/p&gt;
&lt;p&gt;** 映射：** 关联映射，组关联映射&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;替换&lt;/strong&gt;：随机替换&lt;/p&gt;
&lt;p&gt;主存中的页表相应地称之为 “慢表”&lt;/p&gt;
&lt;p&gt;注：现在的计算机中，TLB 和 Cache 在物理上是&lt;strong&gt;两个存储器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据页表中记录的物理页存放位置，可以&lt;strong&gt;将虚拟地址转化为物理地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA11/ca7e99a21a5250fba0cb9dca14197c50.png&#34; alt=&#34;ca7e99a21a5250fba0cb9dca14197c50.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;TLB：主存中比较活跃的页，TLB 命中，则主存中一定有这个页&lt;/p&gt;
&lt;p&gt;页表：主存中的所有页，页表命中，则主存中一定有这个页。&lt;/p&gt;
&lt;p&gt;那么实际上 TLB 和页表是包含关系&lt;/p&gt;
&lt;p&gt;cache 和主存是包含关系&lt;/p&gt;
&lt;p&gt;TLB 和页表是存虚拟页描述信息的，并没有实际 data&lt;/p&gt;
&lt;p&gt;TLB 相对于页表，有点像 cache 相对于主存&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA11/638ab0c03ef14a05b59373e47086aa64.png&#34; alt=&#34;638ab0c03ef14a05b59373e47086aa64.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA11/1e188f2705907faadae40f3c4e1be16e.png&#34; alt=&#34;1e188f2705907faadae40f3c4e1be16e.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;TLB 未命中但页表命中，需要更新 TLB&lt;/p&gt;
&lt;p&gt;TLB 和页表都未命中，两个都需要更新&lt;/p&gt;
&lt;h2 id=&#34;分段式虚拟存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分段式虚拟存储器&#34;&gt;#&lt;/a&gt; 分段式虚拟存储器&lt;/h2&gt;
&lt;p&gt;将程序和数据分成不同长度的段，将所需的段加载到主存中&lt;/p&gt;
&lt;p&gt;虚拟地址：段号 + 段内偏移量&lt;/p&gt;
&lt;h2 id=&#34;段页式虚拟存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#段页式虚拟存储器&#34;&gt;#&lt;/a&gt; 段页式虚拟存储器&lt;/h2&gt;
&lt;p&gt;将程序和数据分段，&lt;strong&gt;段内再进行分页&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个分段都有一个页表&lt;/p&gt;
&lt;p&gt;虚拟地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;段号 + 页号&lt;/strong&gt; + 页内偏移量&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/COA10/</guid>
            <title>计组期末复习第十讲 RAID</title>
            <link>https://erinwithbmq.github.io/2025/01/11/COA10/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="计算机组织结构" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 19:31:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;LaTeX 渲染有问题。将就着看吧。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;冗余磁盘阵列 / 独立磁盘冗余阵列：RedundantArraysofIndependent Disks (RAID)&lt;/p&gt;
&lt;p&gt;RAID（Redundant Array of Independent Disks，独立磁盘冗余阵列）是一种将&lt;strong&gt;多个物理硬盘组合成一个逻辑硬盘&lt;/strong&gt;的技术，以提升数据的性能、冗余性和可用性。通过 RAID，可以在数据存储时实现一定的容错能力，避免数据因某一硬盘的故障而丢失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由一组物理磁盘驱动器组成，被视为&lt;strong&gt;单个逻辑驱动器&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据是分布在多个物理磁盘上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;冗余磁盘&lt;/strong&gt;容量用于存储&lt;strong&gt;校验信息&lt;/strong&gt;，保证磁盘万一损坏时能恢复数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#分类&#34;&gt;#&lt;/a&gt; 分类：&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA10/bb7702e1aedb4121051ed4452e3757c2.png&#34; alt=&#34;bb7702e1aedb4121051ed4452e3757c2.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;raid-0&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#raid-0&#34;&gt;#&lt;/a&gt; RAID 0&lt;/h2&gt;
&lt;p&gt;数据以条带的形式在可用的磁盘上分布&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不采用&lt;/strong&gt;冗余来改善性能（不是 RAID 家族中的真正成员）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：读写速度提升，因为可以并行读取和写入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：没有数据冗余，任何一块硬盘故障都会导致所有数据丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适用场景：对速度要求较高的数据处理任务，不要求数据冗余。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用途：高数据传输率 ，高速响应 I/O 请求&lt;/p&gt;
&lt;h2 id=&#34;raid-1&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#raid-1&#34;&gt;#&lt;/a&gt; RAID 1&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA10/2dd0b04f89401dfb4f3c4ddf374a9879.png&#34; alt=&#34;2dd0b04f89401dfb4f3c4ddf374a9879.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;采用了数据条带&lt;/p&gt;
&lt;p&gt;采用简单地&lt;strong&gt;备份所有数据&lt;/strong&gt;的方法来实现冗余&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;高速响应 I/O 请求：即便是同一个磁盘上的数据块，也可以由两组硬盘分别响应&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读请求可以由包含请求数据的两个对应磁盘中的某一个提供服务，可以选择寻道 时间较小的那个&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写请求需要&lt;strong&gt;更新两个对应的条带&lt;/strong&gt;：可以并行完成，但受限于写入较慢的磁盘&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单个磁盘损坏时不会影响数据访问，恢复受损磁盘简单&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;** 缺点：** 价格昂贵&lt;/p&gt;
&lt;p&gt;** 用途：** 只限于用在存储系统软件、数据和其他关键文件的驱动器中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与 RAID 0 相比：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果有大批的读请求，则 RAID 1 能实现高速的 I/O 速率，性能可以达到 RAID 0 的两倍&lt;/p&gt;
&lt;p&gt;如果 I/O 请求有相当大的部分是写请求，则它不比 RAID 0 的性能好多少&lt;/p&gt;
&lt;h3 id=&#34;raid-01-vs-raid-10&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#raid-01-vs-raid-10&#34;&gt;#&lt;/a&gt; RAID 01 vs. RAID 10&lt;/h3&gt;
&lt;p&gt;RAID 01 =RAID 0+1：先做 RAID0，再做 RAID1&lt;/p&gt;
&lt;p&gt;RAID 10 =RAID 1+0：先做 RAID1，再做 RAID0&lt;/p&gt;
&lt;p&gt;两者在数据传输率和磁盘利用率上没有明显区别，主要区别是对磁盘损坏的&lt;strong&gt;容错能力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA10/1195195a2e56fec7eefc0d0d254e73f3.png&#34; alt=&#34;1195195a2e56fec7eefc0d0d254e73f3.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;RAID 01 会无法恢复，但 RAID 10 可以恢复。&lt;/p&gt;
&lt;h2 id=&#34;raid-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#raid-2&#34;&gt;#&lt;/a&gt; RAID 2&lt;/h2&gt;
&lt;p&gt;采用并行存取技术&lt;/p&gt;
&lt;p&gt;目标：&lt;/p&gt;
&lt;p&gt;所有磁盘都参与每个 I/O 请求的执行&lt;/p&gt;
&lt;p&gt;实际基本被弃用&lt;/p&gt;
&lt;h2 id=&#34;raid-3&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#raid-3&#34;&gt;#&lt;/a&gt; RAID 3&lt;/h2&gt;
&lt;p&gt;采用&lt;strong&gt;并行存取&lt;/strong&gt;技术&lt;/p&gt;
&lt;p&gt;各个驱动器的轴同步旋转&lt;/p&gt;
&lt;p&gt;采用非常小的数据条带，所有盘一起读写&lt;/p&gt;
&lt;p&gt;校验：对&lt;strong&gt;所有数据盘上同一位置的数据&lt;/strong&gt;计算奇偶校验码&lt;/p&gt;
&lt;p&gt;优点：能够获得非常高的数据传输率，对于大量读请求，性能改善特别明显&lt;/p&gt;
&lt;p&gt;缺点：一次只能执行一个 I/O 请求，在面向多个 IO 请求时，性能将受损&lt;/p&gt;
&lt;h2 id=&#34;raid-4&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#raid-4&#34;&gt;#&lt;/a&gt; RAID 4&lt;/h2&gt;
&lt;p&gt;采用&lt;strong&gt;独立存取&lt;/strong&gt;技术&lt;/p&gt;
&lt;p&gt;每个磁盘成员的操作是独立的，各个 I/O 请求能够&lt;strong&gt;并行处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用相对较大的数据条带&lt;/p&gt;
&lt;p&gt;根据各个数据盘上的数据来逐位计算奇偶校验条带，奇偶校验位存储在奇偶校验盘的对应条带上&lt;/p&gt;
&lt;h3 id=&#34;raid-4-的特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#raid-4-的特点&#34;&gt;#&lt;/a&gt; RAID 4 的特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;块级条带化&lt;/strong&gt;：RAID 4 将数据按块（通常是较大的数据块）条带化分布在多个磁盘上，而不是按字节。每个磁盘存储数据的不同块，并且会有一个独立的磁盘用于存储所有数据块的奇偶校验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;单一奇偶校验磁盘&lt;/strong&gt;：和 RAID 3 类似，RAID 4 使用一个单独的磁盘来存储所有的奇偶校验数据。如果数据磁盘之一发生故障，奇偶校验磁盘可以帮助恢复丢失的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;容错能力&lt;/strong&gt;：RAID 4 能够容忍一块磁盘的故障而不丢失数据，因为奇偶校验磁盘可以用来重建丢失的磁盘数据。但如果奇偶校验磁盘发生故障，数据将不可恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能瓶颈&lt;/strong&gt;：由于所有的奇偶校验数据都存储在一个单独的磁盘上，RAID 4 会受到写操作性能瓶颈的限制。每次写入数据时，都需要读取、计算并写入新的奇偶校验信息，这会导致奇偶校验磁盘的过载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;raid-4-的优缺点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#raid-4-的优缺点&#34;&gt;#&lt;/a&gt; RAID 4 的优缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;较高的顺序读取性能&lt;/strong&gt;：与 RAID 3 相比，由于块级条带化，RAID 4 在进行顺序读取时性能较好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;容错性&lt;/strong&gt;：RAID 4 可以容忍一块硬盘故障，能够通过奇偶校验数据恢复丢失的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写入性能瓶颈&lt;/strong&gt;：由于所有的奇偶校验操作都集中在单一磁盘上，写操作时必须读取该磁盘上的旧的奇偶校验信息，并进行更新，这会导致性能下降。尤其是在频繁写入的情况下，奇偶校验磁盘会成为性能瓶颈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;随机读取性能差&lt;/strong&gt;：尽管顺序读取性能较好，但在处理小文件或随机读取时，RAID 4 的性能不如其他 RAID 级别（如 RAID 5）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能&lt;/p&gt;
&lt;p&gt;当执行较小规模的 I/O 写请求时，RAID4 会遭遇写损失&lt;/p&gt;
&lt;p&gt;对于每一次写操作，阵列管理软件不仅要修改用户数据，而且&lt;strong&gt;要修改相应的校验位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA10/e13b2c5605f915d23cbd3f32f0398124.png&#34; alt=&#34;e13b2c5605f915d23cbd3f32f0398124.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;当涉及所有磁盘的数据条带的较大 I/O 写操作时，只要用新的数据位来进行简单的计算即可得到奇偶校验位&lt;/p&gt;
&lt;p&gt;每一次写操作必须涉及到唯一的校验盘，校验盘会成为瓶颈（实际基本弃用）&lt;/p&gt;
&lt;h2 id=&#34;raid-5&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#raid-5&#34;&gt;#&lt;/a&gt; RAID 5&lt;/h2&gt;
&lt;p&gt;与 RAID 4 组织方式相似（常用）&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;所有磁盘上&lt;/strong&gt;都分布了奇偶校验条带&lt;/p&gt;
&lt;p&gt;避免潜在的 I/O 瓶颈问题&lt;/p&gt;
&lt;p&gt;RAID 5 通过 &lt;strong&gt;块级条带化&lt;/strong&gt; 和 &lt;strong&gt;分布式奇偶校验&lt;/strong&gt; 来提供数据冗余和容错能力。这意味着数据被分割成块，并分布到多个磁盘上，同时奇偶校验信息也&lt;strong&gt;分布在所有磁盘上&lt;/strong&gt;，以便在某一磁盘发生故障时恢复数据。&lt;/p&gt;
&lt;p&gt;访问时的 “两读两写”：&lt;strong&gt;读在写前，读 / 写不需要并行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA10/f8014c6df3743515363dfd77662ed62c.png&#34; alt=&#34;f8014c6df3743515363dfd77662ed62c.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;raid-50&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#raid-50&#34;&gt;#&lt;/a&gt; RAID 50&lt;/h3&gt;
&lt;p&gt;RAID 5 与 RAID 0 的组合，先作 RAID 5，再作 RAID 0，也就是对多组 RAID 5 彼此构成条带访问&lt;/p&gt;
&lt;p&gt;RAID 50 在底层的任一组或多组 RAID5 中出现&lt;strong&gt; 1 颗硬盘损坏&lt;/strong&gt;时，&lt;strong&gt;仍能维持运作&lt;/strong&gt;；如果 任一组 RAID5 中出现&lt;strong&gt; 2 颗或 2 颗以上&lt;/strong&gt;硬盘损毁，整组 RAID50 就会&lt;strong&gt;失效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RAID 50 由于在上层把多组 RAID 5 进行条带化，性能比起单纯的 RAID 5 高，但&lt;strong&gt;容量 利用率比 RAID5 要低&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;raid-6&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#raid-6&#34;&gt;#&lt;/a&gt; RAID 6&lt;/h2&gt;
&lt;p&gt;采用&lt;strong&gt;两种不同的校验码&lt;/strong&gt;，并将校验码&lt;strong&gt;以分开的块存于不同的磁盘中&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;奇偶校验码 P（Parity Code P）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reed-Solomon 校验码 Q（RS Code Q）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;p&gt;提升数据可用性：只有在平均修复时间间隔内 3 个磁盘都出了故障，才会造成数据丢失&lt;/p&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;p&gt;写损失：每次写都要&lt;strong&gt;影响两个校验块&lt;/strong&gt;（读 3 个写 3 个磁盘）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA10/4fad03be52b6e9345a9ff9888c28f8cd.png&#34; alt=&#34;4fad03be52b6e9345a9ff9888c28f8cd.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;不同-raid-的比较&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#不同-raid-的比较&#34;&gt;#&lt;/a&gt; 不同 RAID 的比较&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA10/d0c5adeb15049237c207a782e0099837.png&#34; alt=&#34;d0c5adeb15049237c207a782e0099837.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA10/d0c04ebdcd5ae24c46a149742d41f1e8.png&#34; alt=&#34;d0c04ebdcd5ae24c46a149742d41f1e8.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA10/0e21bb90b9b8683cc9336b4fee11d884.png&#34; alt=&#34;0e21bb90b9b8683cc9336b4fee11d884.png&#34; /&gt;&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#总结&#34;&gt;#&lt;/a&gt; 总结&lt;/h1&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA10/8f4b9f3f22a1b4bfcb686a7bf45d8e8a.png&#34; alt=&#34;8f4b9f3f22a1b4bfcb686a7bf45d8e8a.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;0：I/O 快，但是数据可用性低&lt;/p&gt;
&lt;p&gt;1：数据可用性高但是容量可用性低&lt;/p&gt;
&lt;p&gt;2/3：不能并行处理，处理速度慢&lt;/p&gt;
&lt;p&gt;456：数据可用性高但是写速率收到影响&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/COA9/</guid>
            <title>计组期末复习第九讲 数据校验码</title>
            <link>https://erinwithbmq.github.io/2025/01/11/COA9/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="计算机组织结构" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 19:28:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;LaTeX 渲染有问题。将就着看吧。&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id=&#34;纠错&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#纠错&#34;&gt;#&lt;/a&gt; 纠错&lt;/h1&gt;
&lt;p&gt;两种&lt;strong&gt;存储错误&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;硬故障：永久性物理故障&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软故障：随机非破坏性，改变了某个或某些存储单元的内容，但没有损坏机器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基本思想&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基本思想&#34;&gt;#&lt;/a&gt; 基本思想&lt;/h2&gt;
&lt;p&gt;存储额外的信息以进行检错和校正&lt;/p&gt;
&lt;h2 id=&#34;处理过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#处理过程&#34;&gt;#&lt;/a&gt; 处理过程&lt;/h2&gt;
&lt;p&gt;使用函数在数据上生成校验码。传输完成后再生成一次，比较差错&lt;/p&gt;
&lt;h1 id=&#34;常用的数据校验码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常用的数据校验码&#34;&gt;#&lt;/a&gt; 常用的数据校验码&lt;/h1&gt;
&lt;h2 id=&#34;奇偶校验码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#奇偶校验码&#34;&gt;#&lt;/a&gt; 奇偶校验码&lt;/h2&gt;
&lt;p&gt;基本思想：&lt;strong&gt;增加 1 位校验码&lt;/strong&gt;来表示数据中 &lt;strong&gt;1 的数量&lt;/strong&gt;是奇数还是偶数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;奇校验&lt;/strong&gt;：使传输的数据 **（数据位 + 校验位）&lt;strong&gt;中有&lt;/strong&gt;奇数 ** 个 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;偶校验&lt;/strong&gt;：使传输的数据 **（数据位 + 校验位）&lt;strong&gt;中有&lt;/strong&gt;偶数 ** 个 1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传输完成后，根据校验类型生成校验码，比较是否相同。&lt;/p&gt;
&lt;p&gt;检错：S=𝐶′′⊕𝐶′&lt;/p&gt;
&lt;p&gt;𝑆=0：正确 / 数据中出错的位数为&lt;strong&gt;偶数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;𝑆=1：数据中出错的位数为奇数&lt;/p&gt;
&lt;p&gt;适用于对&lt;strong&gt;较短长度&lt;/strong&gt;（如 1 字节）的数据进行检错&lt;/p&gt;
&lt;h2 id=&#34;海明码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#海明码&#34;&gt;#&lt;/a&gt; 海明码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本思想：将数据分成几组，对&lt;strong&gt;每一组&lt;/strong&gt;都使用&lt;strong&gt;奇偶校验码&lt;/strong&gt;进行检错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分组：将𝑀位数据分成𝐾组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据输入：为数据𝐷中&lt;strong&gt;每组&lt;/strong&gt;生成 1 位校验码，&lt;strong&gt;合并&lt;/strong&gt;得到𝐾位校验码𝐶&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据输出：为数据𝐷′中&lt;strong&gt;每组&lt;/strong&gt;生成 1 位校验码，&lt;strong&gt;合并&lt;/strong&gt;得到新的𝐾位校验码𝐶′′&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检错：将校验码𝐶′′和取出的校验码 C’&lt;strong&gt;按位进行异或&lt;/strong&gt;，生成𝐾位&lt;strong&gt;故障字&lt;/strong&gt; （syndrome word）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;故障字的作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;故障字是两个校验码&lt;strong&gt;按位异或&lt;/strong&gt;生成的结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全部是 0：没有检测到错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有且仅有 1 位是 1：错误发生在&lt;strong&gt;校验码中的某一位&lt;/strong&gt;，&lt;strong&gt;不需要纠正&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有多位为 1：错误发生在数据中的某一位，将𝐷′中对应数据位&lt;strong&gt;取反&lt;/strong&gt;即可纠正&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;海明码通过在原始数据中插入额外的校验位，使得接收方可以检测并纠正 &lt;strong&gt;1 位错误&lt;/strong&gt;（单比特错误），并检测 &lt;strong&gt;2 位错误&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;构造过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#构造过程&#34;&gt;#&lt;/a&gt; 构造过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确定校验位的数量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给定数据位的长度为 k，校验位的数量为 r，总长度为 n=k+r。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;校验位 r 的数量需满足以下关系： &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;≥&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2^r≥n+1=k+r+1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.800362em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≥&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.77777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如：如果 k=4（数据位长度），则 r=3 满足条件（2^3=8≥4+3+1）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确定校验位的位置&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;校验位插入到数据位中，使其位于指数为 2 的幂的位置（即第 1、2、4、8... 位）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他位置存放数据位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;生成校验位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个校验位负责&lt;strong&gt;对特定位置的比特&lt;/strong&gt;进行校验，位置由 &lt;strong&gt;二进制表示&lt;/strong&gt;决定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如：校验位 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mtext&gt;​&lt;/mtext&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;P_i​&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 负责检查所有位置的二进制表示中第 i 位为 1 的数据位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般是偶校验&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;实例&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实例&#34;&gt;#&lt;/a&gt; 实例&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA9/e0c39b0342ecf9262187f370d5757785.png&#34; alt=&#34;e0c39b0342ecf9262187f370d5757785.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA9/09f7a02031fe96fb31fcfd0d8cfd3ce6.png&#34; alt=&#34;09f7a02031fe96fb31fcfd0d8cfd3ce6.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA9/d2274a2bd99359ac8b510780e11fef80.png&#34; alt=&#34;d2274a2bd99359ac8b510780e11fef80.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;码距和纠错理论&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#码距和纠错理论&#34;&gt;#&lt;/a&gt; 码距和纠错理论&lt;/h2&gt;
&lt;h3 id=&#34;码距&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#码距&#34;&gt;#&lt;/a&gt; 码距&lt;/h3&gt;
&lt;p&gt;同一编码中，任意两个&lt;strong&gt;合法编码&lt;/strong&gt;之间&lt;strong&gt;不同二进制数位数&lt;/strong&gt;的&lt;strong&gt;最小值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;{0000, 0001, 0010, 0011} 码距为 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;{0000, 0011} 码距为 2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;纠错理论&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#纠错理论&#34;&gt;#&lt;/a&gt; 纠错理论&lt;/h3&gt;
&lt;p&gt;𝑳−𝟏=𝑫+𝑪, 𝑫≥𝑪&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;𝐿是码距，𝐷是检错位数，𝐶是纠错位数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;奇偶校验的&lt;strong&gt;码距是 2&lt;/strong&gt;，1 位能检错，不能纠错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;海明码的&lt;strong&gt;码距是 3&lt;/strong&gt;，1 位能检错和纠错（海明码能 2 位检测 0 位纠错吗？&lt;strong&gt;可以&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;循环冗余校验-crc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#循环冗余校验-crc&#34;&gt;#&lt;/a&gt; 循环冗余校验 CRC&lt;/h2&gt;
&lt;p&gt;通过将数据看作一个二进制多项式，并对其进行特定的多项式除法运算来生成一个校验值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据视为二进制多项式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据位序列被视为一个二进制多项式。例如，数据 1101 对应多项式： &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x^3+x^2+1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，每个比特对应多项式的系数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生成多项式要求最低位和最高位为 1.&lt;/p&gt;
&lt;h3 id=&#34;计算过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#计算过程&#34;&gt;#&lt;/a&gt; 计算过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;确定生成多项式。如 1011（&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;G(x)=x^3+x+1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;G&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在数据后面添加 0，0 的个数为生成多项式的阶数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对新的数据进行模 2 除法，等价于依次进行异或运算。直到产生余数，即校验码。（余数应比生成多项式少一位）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将校验码加在原来的数据后面，发送。接收方再次进行模 2 除法，检验校验位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA9/3193335de6541ac6fd795ebd7d487295.png&#34; alt=&#34;3193335de6541ac6fd795ebd7d487295.png&#34; /&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/COA8/</guid>
            <title>计组期末复习第八讲 外部存储器</title>
            <link>https://erinwithbmq.github.io/2025/01/11/COA8/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="计算机组织结构" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 19:25:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;LaTeX 渲染有问题。将就着看吧。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;磁盘 / 磁带部分。&lt;/p&gt;
&lt;h1 id=&#34;外部存储设备&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#外部存储设备&#34;&gt;#&lt;/a&gt; 外部存储设备&lt;/h1&gt;
&lt;p&gt;用于存储不经常使用的、数据量较大的信息，非易失&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;磁盘存储器（magnetic disk）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;光存储器（optical memory）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁带（magnetic tape）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;U 盘（USB flash disk），固态硬盘（solid state disk，SSD）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;硬磁盘存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#硬磁盘存储器&#34;&gt;#&lt;/a&gt; 硬磁盘存储器&lt;/h1&gt;
&lt;h2 id=&#34;结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#结构&#34;&gt;#&lt;/a&gt; 结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;磁盘存储器每个盘片表面有一个&lt;strong&gt;读写磁头&lt;/strong&gt;，所有磁头通过机械方式固定在一起，&lt;strong&gt;同时移动&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在任何时候，所有磁头都位于距磁盘中心&lt;strong&gt;等距离的磁道&lt;/strong&gt;上&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA8/ad11beb08f503a90afcea51258bcb361.png&#34; alt=&#34;ad11beb08f503a90afcea51258bcb361.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对盘片进行读写操作的装置叫做&lt;strong&gt;磁头（head）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁头越窄，电磁感应能力&lt;strong&gt;越弱&lt;/strong&gt;，离盘片的&lt;strong&gt;距离就越近&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;读写机制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#读写机制&#34;&gt;#&lt;/a&gt; 读写机制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在&lt;strong&gt;读或写&lt;/strong&gt;操作期间，磁头&lt;strong&gt;静止&lt;/strong&gt;，而&lt;strong&gt;盘片在其下方旋转&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁头的数量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单磁头：读写共用同一个磁头（软盘、早期硬盘）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双磁头：使用一个单独的磁头进行读取（当代硬盘）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据组织&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据组织&#34;&gt;#&lt;/a&gt; 数据组织&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;磁道：&lt;strong&gt;盘片上的数据组织呈现为一组&lt;/strong&gt;同心圆环&lt;/strong&gt;，称为磁道（track）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;** 扇区：** 数据以扇区（sector）的形式传输到磁盘或从传出磁盘。默认值为 &lt;strong&gt;512B&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相邻磁道之间有&lt;strong&gt;间隙&lt;/strong&gt;（gap），相邻的扇区之间也留有间隙，否则磁场容易相互影响&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁道编号&lt;strong&gt;从外往里递增&lt;/strong&gt;（0~N），磁头静止时停在磁道 0 外侧&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA8/4b5d8546b05becb886bc673b354549b0.png&#34; alt=&#34;4b5d8546b05becb886bc673b354549b0.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;图上的一个圈应该就是磁道&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扇区划分&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;恒定角速度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;恒定的数据传输率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多带式记录 / 多重区域记录&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA8/f05924d72efda289d2c4c59c97ac1a37.png&#34; alt=&#34;f05924d72efda289d2c4c59c97ac1a37.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA8/ddc2b547215c7fce8a5c0613f115e905.png&#34; alt=&#34;ddc2b547215c7fce8a5c0613f115e905.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;柱面 (cylinder)&lt;/strong&gt;：所有盘片上处于&lt;strong&gt;相同的相对位置&lt;/strong&gt;的一组磁道被称为柱面 (cylinder)&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA8/a0310b1f399141ec0d5d3222e0a28a7d.png&#34; alt=&#34;a0310b1f399141ec0d5d3222e0a28a7d.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;io-访问时间&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#io-访问时间&#34;&gt;#&lt;/a&gt; I/O 访问时间&lt;/h2&gt;
&lt;p&gt;访问时间包含以下三个部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;** 寻道时间：** 磁头定位到所需移动到的磁道所花费的时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始启动时间，跨越若干磁道所用的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;旋转延迟&lt;/strong&gt;：等待响应扇区的起始处&lt;strong&gt;到达磁头&lt;/strong&gt;所需的时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常是磁道&lt;strong&gt;旋转半周&lt;/strong&gt;所需的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传送时间&lt;/strong&gt;：数据传输所需的时间&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA8/39378e04fe673a9b7aa846913174a2c0.png&#34; alt=&#34;39378e04fe673a9b7aa846913174a2c0.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;公式推导和解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;磁盘每旋转一圈，磁头能传输整个磁道的数据，每个磁道的数据量是 N（字节数）；磁盘每秒旋转 r 转，因此&lt;strong&gt;每秒传送的数据量&lt;/strong&gt;为 rN 字节 / 秒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果要传送的数据量是 b，而每秒能传送的数据量是 rN，那么总传送时间为：T = b/rN&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;平均访问时间&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#平均访问时间&#34;&gt;#&lt;/a&gt; 平均访问时间&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA8/9ea8d642d53577a3dcd8bc74c3023744.png&#34; alt=&#34;9ea8d642d53577a3dcd8bc74c3023744.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\frac{1}{2r}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.190108em;vertical-align:-0.345em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.845108em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathnormal mtight&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.345em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 是转半圈，为一个平均值（0 ~ &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\frac{1}{r}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.190108em;vertical-align:-0.345em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.845108em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.345em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的平均）&lt;/p&gt;
&lt;p&gt;当连续访问多个相邻的磁道时，&lt;strong&gt;跨越磁道&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于&lt;strong&gt;每个&lt;/strong&gt;磁道都需要考虑&lt;strong&gt;旋转延迟&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常只需要考虑&lt;strong&gt;第一个磁道的寻道时间&lt;/strong&gt;，但在&lt;strong&gt;明确知道&lt;/strong&gt;跨越每个磁道需要的时间时需要考虑。（因为磁道非常多，顺序移到下一个磁道的耗时是非常少的）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;实例&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#实例&#34;&gt;#&lt;/a&gt; 实例&lt;/h4&gt;
&lt;p&gt;假设某个硬盘的平均寻道时间为 4ms，转速为 15000rpm（每&lt;strong&gt;分钟&lt;/strong&gt; 15000 转），每磁道 500 扇区，每扇区 512B，现读取一个由 2500 个扇区组成的文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况 1：顺序组织&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该文件占据相邻 5 个磁道的全部扇区。因为相邻，后续不需要再计算寻道时间。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA8/0509740cda91b738a4db7800135c002c.png&#34; alt=&#34;0509740cda91b738a4db7800135c002c.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;b=500&lt;em&gt;512=256000，r = 15000 / 60 = 250 转 / 秒，N = 500&lt;/em&gt;512=256000&lt;/p&gt;
&lt;p&gt;T = 1/250=0.004s=4ms，即读 500 个扇区的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况 2：随机存取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该文件随机分布在磁盘上的各个扇区。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA8/d918328dea125c362157c032baa0d99e.png&#34; alt=&#34;d918328dea125c362157c032baa0d99e.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;计算了每次访问一个磁道再读扇区的单次时间，乘 2500 次（需要找 2500 次扇区）&lt;/p&gt;
&lt;p&gt;这个需要计算寻道时间，因为两次寻道不一定是相邻寻道了。而且扇区也不连续，不能再连续计算 500 个扇区。&lt;/p&gt;
&lt;h2 id=&#34;磁头寻道磁盘调度&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#磁头寻道磁盘调度&#34;&gt;#&lt;/a&gt; 磁头寻道 / 磁盘调度&lt;/h2&gt;
&lt;p&gt;目标：当有多个访问磁盘任务时，使得&lt;strong&gt;平均寻道时间最小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;六种调度算法。你应该都会了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;先来先服务&lt;/strong&gt;（First Come First Service，FCFS）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接按任务顺序依次寻道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最短寻道时间优先&lt;/strong&gt;（Shortest Seek Time First，SSTF）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理与当前磁头位置最近的读写任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;扫描 / 电梯&lt;/strong&gt;（SCAN）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照一个方向进行调度，直到撞上边缘才改变方向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LOOK&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCAN 优化，不会撞上边缘，只要磁头移动方向上不再有请求就立即改变磁头的方向&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;循环扫描&lt;/strong&gt;（C-SCAN）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按照一个方向（往大）进行调度，撞上最大边缘后返回到&lt;strong&gt;起点&lt;/strong&gt;，再调度。除了返回过程一直都是同一个方向移动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;C-LOOK&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSCAN 优化，只要在磁头移动方向上不再有请求，就立即让磁头返回起点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;光存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#光存储器&#34;&gt;#&lt;/a&gt; 光存储器&lt;/h1&gt;
&lt;p&gt;如光盘 CD&lt;/p&gt;
&lt;p&gt;CD 和 CD-ROM 采用类似的技术，但 CD-ROM 更加耐用且有纠错功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;存储有信息的光盘可以廉价地进行大规模复制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;光盘更换方便&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寿命长&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;它是只读的，不能更改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其存取时间比磁盘存储器慢得多&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CD-R（写一次）&lt;/p&gt;
&lt;p&gt;CD-RW（写多次）&lt;/p&gt;
&lt;h1 id=&#34;其他存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#其他存储器&#34;&gt;#&lt;/a&gt; 其他存储器&lt;/h1&gt;
&lt;h2 id=&#34;磁带&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#磁带&#34;&gt;#&lt;/a&gt; 磁带&lt;/h2&gt;
&lt;p&gt;使用与磁盘类似的记录和读取技术&lt;/p&gt;
&lt;p&gt;致命缺陷是顺序存取&lt;/p&gt;
&lt;h2 id=&#34;u盘和固态硬盘&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#u盘和固态硬盘&#34;&gt;#&lt;/a&gt; U 盘和固态硬盘&lt;/h2&gt;
&lt;p&gt;采用快闪存储器&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/COA7/</guid>
            <title>计组期末复习第七讲 Cache</title>
            <link>https://erinwithbmq.github.io/2025/01/11/COA7/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="计算机组织结构" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 19:21:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;LaTeX 渲染有问题。将就着看吧。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&#34;cache的基本思路&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cache的基本思路&#34;&gt;#&lt;/a&gt; Cache 的基本思路&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;存储器层次结构&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA7/ec942ba7d6f015987e548443fbb6dd8d.png&#34; alt=&#34;ec942ba7d6f015987e548443fbb6dd8d.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;解决&lt;strong&gt;内存墙&lt;/strong&gt;带来的 CPU 和主存协作问题&lt;/p&gt;
&lt;p&gt;在使用主存（相对大而慢）之余，添加一块&lt;strong&gt;小而快&lt;/strong&gt;的 cache&lt;/p&gt;
&lt;p&gt;Cache 位于 CPU 和主存之间，可以&lt;strong&gt;集成在 CPU 内部&lt;/strong&gt;或作为&lt;strong&gt;主板上的一个模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cache 中存放了主存中的部分信息的 “副本”&lt;/p&gt;
&lt;h2 id=&#34;cache的工作流程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cache的工作流程&#34;&gt;#&lt;/a&gt; Cache 的工作流程&lt;/h2&gt;
&lt;p&gt;主存中的一个块对应着 Cache 中的一个行&lt;/p&gt;
&lt;p&gt;检查（Check）：当 CPU 试图访问主存中的某个字时，首先检查这个字&lt;strong&gt;是否在 cache&lt;/strong&gt; 中&lt;/p&gt;
&lt;p&gt;检查后分两种情况处理：&lt;/p&gt;
&lt;p&gt;命中（Hit）：如果在 cache 中，则把&lt;strong&gt;这个字传送给 CPU&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;未命中（Miss）：如果不在 cache 中，则将主存中包含这个字&lt;strong&gt;固定大小&lt;/strong&gt;的块（block）&lt;strong&gt;读入 cache 中&lt;/strong&gt;，然后再&lt;strong&gt;从 cache 传送该字&lt;/strong&gt;给 CPU&lt;/p&gt;
&lt;h3 id=&#34;命中和未命中的判断&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#命中和未命中的判断&#34;&gt;#&lt;/a&gt; 命中和未命中的判断&lt;/h3&gt;
&lt;p&gt;Cache 通过&lt;strong&gt;标记（tags）&lt;strong&gt;来标识其内容在&lt;/strong&gt;主存&lt;/strong&gt;中的对应&lt;strong&gt;位置&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;程序访问的局部性原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#程序访问的局部性原理&#34;&gt;#&lt;/a&gt; 程序访问的局部性原理&lt;/h3&gt;
&lt;p&gt;类型：&lt;/p&gt;
&lt;p&gt;时间局部性：在相对较短的时间周期内，重复访问特定的信息（也就是问相同存储位置的信息）&lt;/p&gt;
&lt;p&gt;空间局部性：在相对较短的时间周期内，访问相邻存储位置的数据&lt;/p&gt;
&lt;p&gt;顺序局部性：当数据被&lt;strong&gt;线性排列和访问&lt;/strong&gt;时，出现的空间局部性的一种特殊情况（比如访问一维数组中的元素）&lt;/p&gt;
&lt;h3 id=&#34;向cache传送内容&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#向cache传送内容&#34;&gt;#&lt;/a&gt; 向 Cache 传送内容&lt;/h3&gt;
&lt;p&gt;利用 “时间局部性”&lt;/p&gt;
&lt;p&gt;将&lt;strong&gt;未命中&lt;/strong&gt;的数据在&lt;strong&gt;返回给 CPU&lt;/strong&gt; 的同时&lt;strong&gt;存放在 Cache&lt;/strong&gt; 中，以便再次访问时命中&lt;/p&gt;
&lt;h3 id=&#34;传送块而不是传送字&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#传送块而不是传送字&#34;&gt;#&lt;/a&gt; 传送块而不是传送字&lt;/h3&gt;
&lt;p&gt;利用 “空间局部性”&lt;/p&gt;
&lt;p&gt;将&lt;strong&gt;包含所访问的字&lt;/strong&gt;的块存储到 Cache 中，以便在访问相邻数据时命中&lt;/p&gt;
&lt;h3 id=&#34;平均访问时间&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#平均访问时间&#34;&gt;#&lt;/a&gt; 平均访问时间&lt;/h3&gt;
&lt;h3 id=&#34;cache未命中原因&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cache未命中原因&#34;&gt;#&lt;/a&gt; Cache 未命中原因&lt;/h3&gt;
&lt;h4 id=&#34;义务失效compulsory-miss-冷启动失效cold-start-miss&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#义务失效compulsory-miss-冷启动失效cold-start-miss&#34;&gt;#&lt;/a&gt; 义务失效（Compulsory Miss）/ 冷启动失效（Cold Start Miss）&lt;/h4&gt;
&lt;p&gt;第一次访问一个块时&lt;/p&gt;
&lt;h4 id=&#34;容量失效-capacity-miss&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#容量失效-capacity-miss&#34;&gt;#&lt;/a&gt; 容量失效 （Capacity Miss）&lt;/h4&gt;
&lt;p&gt;Cache 无法保存程序访问&lt;strong&gt;所需的所有数据块&lt;/strong&gt;，则当某数据块被替换后，又重新被访问，则发生失效&lt;/p&gt;
&lt;h4 id=&#34;冲突失效conflict-miss&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#冲突失效conflict-miss&#34;&gt;#&lt;/a&gt; 冲突失效（Conflict Miss）&lt;/h4&gt;
&lt;p&gt;多个存储器位置映射到&lt;strong&gt;同一 Cache 位置&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;cache的设计要素&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cache的设计要素&#34;&gt;#&lt;/a&gt; Cache 的设计要素&lt;/h1&gt;
&lt;h2 id=&#34;映射功能mapping-function&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#映射功能mapping-function&#34;&gt;#&lt;/a&gt; 映射功能（Mapping Function）&lt;/h2&gt;
&lt;h3 id=&#34;直接映射&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#直接映射&#34;&gt;#&lt;/a&gt; 直接映射&lt;/h3&gt;
&lt;p&gt;将主存中的每个块映射到一个&lt;strong&gt;固定可用&lt;/strong&gt;的 cache 行中&lt;/p&gt;
&lt;p&gt;假设 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.65952em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 是 cache 行号，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 是主存储器的块号，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;c&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 是 cache 的行数&lt;/p&gt;
&lt;p&gt;$ i = j $ &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mod&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;c&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&#34;块标记&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#块标记&#34;&gt;#&lt;/a&gt; （块）标记&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA7/70766a26a2bd5884b81762d09447c246.png&#34; alt=&#34;70766a26a2bd5884b81762d09447c246.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;假设 cache 有 4 行，每行包含 8 个字；主存中包含 128 个字。访问主存的地址长度为 7 位，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最低的 3 位：块内地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中间的 2 位：映射时所对应的 Cache 行号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最高的 2 位：区分映射到同一行的不同块，记录为 Cache 标记（一行分配 4 个块，共四行 16 个块）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;标记代表了你是这一行 / 组的第几个块，通过标记判断是否命中。&lt;/p&gt;
&lt;p&gt;tag = j /c （块号整除以行数）（组相联那就除以组数）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;gpt 的解释&lt;/p&gt;
&lt;p&gt;在计算机体系结构中，** 缓存（cache）** 是一种用于加速数据访问的小型高速存储器，主要用于减少从主存中读取数据的延迟。直接映射（Direct Mapping）是缓存中一种简单且常用的映射机制。它将主存中的每一个内存块映射到缓存中唯一的一个缓存行位置。这种固定的映射关系使得直接映射缓存的实现简单且高效。&lt;/p&gt;
&lt;h3 id=&#34;1-直接映射的原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-直接映射的原理&#34;&gt;#&lt;/a&gt; 1. 直接映射的原理&lt;/h3&gt;
&lt;p&gt;在直接映射缓存中，主存中的每一个块都可以映射到缓存中的一个固定位置。假设有一块主存和一个较小的缓存，主存中的每个块会根据其地址被映射到缓存中的一个特定行。具体映射方法如下：&lt;/p&gt;
&lt;p&gt;[缓存行号 = （内存块地址） \bmod （缓存行数）]&lt;/p&gt;
&lt;h3 id=&#34;2-地址分解&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-地址分解&#34;&gt;#&lt;/a&gt; 2. 地址分解&lt;/h3&gt;
&lt;p&gt;为了确定主存中的地址应该映射到缓存的哪个位置，内存地址通常会分为以下三部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标记位（Tag）：&lt;/strong&gt; 用于标识数据块的&lt;strong&gt;唯一性&lt;/strong&gt;，确保找到的数据块是正确的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;索引位（Index）：&lt;/strong&gt; 用于指定数据在缓存中的&lt;strong&gt;行位置&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;块内偏移（Block Offset）：&lt;/strong&gt; 用于找到数据&lt;strong&gt;块内&lt;/strong&gt;的具体字节。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这种分解，缓存可以快速判断主存地址是否在缓存中。&lt;/p&gt;
&lt;h3 id=&#34;3-直接映射的优缺点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-直接映射的优缺点&#34;&gt;#&lt;/a&gt; 3. 直接映射的优缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 实现简单，访问速度快，开销小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 由于每个内存块都只能映射到缓存中的一个位置，可能会出现冲突导致频繁的&lt;strong&gt;缓存替换&lt;/strong&gt;（Cache Miss）。例如，当多个内存块被映射到同一行时，它们会不断替换，从而降低缓存命中率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-例子&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-例子&#34;&gt;#&lt;/a&gt; 4. 例子&lt;/h3&gt;
&lt;p&gt;假设有 4 行缓存（行号为 0 到 3），主存块会按照如下方式映射：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主存块 0、4、8... 都映射到缓存行 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主存块 1、5、9... 都映射到缓存行 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主存块 2、6、10... 都映射到缓存行 2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主存块 3、7、11... 都映射到缓存行 3&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当访问主存中块 4 的数据时，数据会被加载到缓存行 0。如果接下来访问块 0 或块 8，数据依然在缓存行 0，这可能导致缓存命中失败（Cache Miss）。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#总结&#34;&gt;#&lt;/a&gt; 总结&lt;/h3&gt;
&lt;p&gt;直接映射是一种效率较高的缓存映射方式，适合对实现复杂度要求不高的系统。但由于映射固定，容易产生冲突失效（Conflict Miss），对程序的访问模式敏感。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;举例&lt;/p&gt;
&lt;p&gt;好，下面我们通过一个简单的例子来说明直接映射缓存的读取数据过程。&lt;/p&gt;
&lt;h3 id=&#34;假设条件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#假设条件&#34;&gt;#&lt;/a&gt; 假设条件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主存和缓存参数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主存有 32 个块（Block），每个块 1 字节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存有 8 行（Cache Lines），每行 1 字节，因此只能缓存 8 个块的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;映射规则：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;strong&gt;直接映射&lt;/strong&gt;，即  &lt;code&gt;缓存行号 = （主存块地址）mod（缓存行数）&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主存地址分为&lt;strong&gt;标记位&lt;/strong&gt;和&lt;strong&gt;索引位&lt;/strong&gt;两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;索引位：用来找到缓存行的位置（这里需要 (\log_2 (8) = 3 ) 位）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记位：用于区分属于同一个缓存行的不同主存块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;示例&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#示例&#34;&gt;#&lt;/a&gt; 示例&lt;/h3&gt;
&lt;p&gt;假设我们需要访问主存地址  &lt;code&gt;12&lt;/code&gt;  和  &lt;code&gt;28&lt;/code&gt; ，来看在直接映射缓存中的情况。&lt;/p&gt;
&lt;h4 id=&#34;步骤-1访问主存地址-12&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#步骤-1访问主存地址-12&#34;&gt;#&lt;/a&gt; 步骤 1：访问主存地址  &lt;code&gt;12&lt;/code&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确定索引和标记位：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;地址  &lt;code&gt;12&lt;/code&gt;  的二进制表示为  &lt;code&gt;1100&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低 3 位  &lt;code&gt;100&lt;/code&gt;  为索引位，对应的是缓存中的第  &lt;code&gt;4&lt;/code&gt;  行（ &lt;code&gt;100&lt;/code&gt;  二进制即  &lt;code&gt;4&lt;/code&gt; ）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;剩下的高位  &lt;code&gt;1&lt;/code&gt;  是标记位，用来确认数据块来源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缓存操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果缓存行  &lt;code&gt;4&lt;/code&gt;  里已经存有标记  &lt;code&gt;1&lt;/code&gt;  的数据，表示数据命中，可以直接从缓存中读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果缓存行  &lt;code&gt;4&lt;/code&gt;  的标记位不同，表示数据不在缓存中（缓存未命中）。此时，需要从主存中加载地址  &lt;code&gt;12&lt;/code&gt;  的数据到缓存的第  &lt;code&gt;4&lt;/code&gt;  行，并将标记位更新为  &lt;code&gt;1&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;步骤-2访问主存地址-28&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#步骤-2访问主存地址-28&#34;&gt;#&lt;/a&gt; 步骤 2：访问主存地址  &lt;code&gt;28&lt;/code&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确定索引和标记位：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;地址  &lt;code&gt;28&lt;/code&gt;  的二进制表示为  &lt;code&gt;11100&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低 3 位  &lt;code&gt;100&lt;/code&gt;  为索引位，对应的仍然是缓存中的第  &lt;code&gt;4&lt;/code&gt;  行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高位  &lt;code&gt;11&lt;/code&gt;  是标记位，用于区分不同的数据块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缓存操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缓存行  &lt;code&gt;4&lt;/code&gt;  目前存的是标记为  &lt;code&gt;1&lt;/code&gt;  的数据块（即主存地址  &lt;code&gt;12&lt;/code&gt;  的数据）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为标记位不匹配（ &lt;code&gt;1&lt;/code&gt;  不等于  &lt;code&gt;11&lt;/code&gt; ），发生&lt;strong&gt;冲突未命中&lt;/strong&gt;（Conflict Miss）。此时，需要将主存地址  &lt;code&gt;28&lt;/code&gt;  的数据块加载到缓存行  &lt;code&gt;4&lt;/code&gt; ，并更新标记为  &lt;code&gt;11&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总结-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#总结-2&#34;&gt;#&lt;/a&gt; 总结&lt;/h3&gt;
&lt;p&gt;在这个例子中，访问主存地址  &lt;code&gt;12&lt;/code&gt;  和  &lt;code&gt;28&lt;/code&gt;  都映射到了缓存的第  &lt;code&gt;4&lt;/code&gt;  行，但由于它们有不同的标记位，在访问  &lt;code&gt;28&lt;/code&gt;  时导致了缓存替换。直接映射缓存的这种特性，使得某些相邻的内存块可能频繁发生缓存未命中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关联映射全相联映射&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关联映射全相联映射&#34;&gt;#&lt;/a&gt; 关联映射（全相联映射）&lt;/h3&gt;
&lt;p&gt;一个主存块可以装入 cache&lt;strong&gt; 任意一行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA7/3b009c490945c3a4350c32b6af171223.png&#34; alt=&#34;3b009c490945c3a4350c32b6af171223.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设 cache 有 4 行，每行包含 8 个字；主存中包含 128 个字。访问主存的地址长度为 7 位，则：&lt;/p&gt;
&lt;p&gt;最低的 3 位：块内地址（1 个块里 8 个字）&lt;/p&gt;
&lt;p&gt;最高的 4 位：块号，记录为 Cache 标记 （16 个块，随机放到行中）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;gpt 的解释&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全相联映射&lt;/strong&gt;（Fully Associative Mapping）是一种缓存映射机制，与直接映射不同，它不限制每个主存块固定映射到特定缓存行，而是允许主存中的任意块加载到缓存的任何行。这种灵活的映射方式消除了缓存行冲突，能够更有效地利用缓存空间，但也需要更复杂的查找机制。&lt;/p&gt;
&lt;h3 id=&#34;全相联映射的基本原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#全相联映射的基本原理&#34;&gt;#&lt;/a&gt; 全相联映射的基本原理&lt;/h3&gt;
&lt;p&gt;在全相联映射中，主存中的任何一个数据块都可以存放在缓存的任意行中。因此，不需要像直接映射那样有固定的缓存行位置，而是通过标记位来判断主存块是否在缓存中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标记位（Tag）：&lt;/strong&gt; &lt;strong&gt;唯一标识主存块&lt;/strong&gt;，和缓存中的每一行&lt;strong&gt;比较标记位&lt;/strong&gt;来判断缓存命中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;块内偏移（Block Offset）：&lt;/strong&gt; 指定数据块&lt;strong&gt;内部&lt;/strong&gt;的具体字节位置（用于确定具体的字节偏移）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;访问过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#访问过程&#34;&gt;#&lt;/a&gt; 访问过程&lt;/h3&gt;
&lt;p&gt;当处理器需要访问某个内存地址时，全相联映射的访问过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从主存地址中&lt;strong&gt;提取标记位&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将这个标记位与缓存中所有行的标记位&lt;strong&gt;逐一比较&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果找到一个匹配的标记位，则表示缓存&lt;strong&gt;命中&lt;/strong&gt;，可以直接从缓存中读取数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有找到匹配项，则表示缓存&lt;strong&gt;未命中&lt;/strong&gt;，需要从主存中加载数据到缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缓存替换策略&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#缓存替换策略&#34;&gt;#&lt;/a&gt; 缓存替换策略&lt;/h3&gt;
&lt;p&gt;因为全相联映射允许任意数据块存放到任意缓存行，所以当缓存已满且需要加载新数据时，必须选择一个缓存行进行替换。常用的替换策略包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FIFO（先进先出）：&lt;/strong&gt; &lt;strong&gt;最早进入&lt;/strong&gt;缓存的块最先被替换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LRU（最近最少使用）：&lt;/strong&gt; 替换&lt;strong&gt;最长时间未被访问&lt;/strong&gt;的块，适用于大部分程序的访问模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LFU（最少使用频率）：&lt;/strong&gt; 替换访问&lt;strong&gt;次数最少&lt;/strong&gt;的块，适用于频繁访问相对固定数据的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优缺点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#优缺点&#34;&gt;#&lt;/a&gt; 优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;没有缓存行冲突，因为任何数据块可以存放到缓存的任意位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在某些访问模式下，命中率可能比直接映射和组相联映射更高。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;需要比较所有缓存行的标记位，硬件实现复杂。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;替换策略的管理需要更多的硬件资源和复杂的算法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#示例-2&#34;&gt;#&lt;/a&gt; 示例&lt;/h3&gt;
&lt;p&gt;假设我们有一个小缓存，包含 4 行，可以存放 4 个字节的数据，每行可存放主存中的任意数据块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问主存地址 5&lt;/strong&gt;：缓存为空，将主存地址 5 的数据块加载到缓存行 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问主存地址 9&lt;/strong&gt;：缓存中没有地址 9 对应的数据，将它加载到缓存行 2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;再次访问主存地址 5&lt;/strong&gt;：缓存中找到标记匹配的缓存行 1，所以直接命中，读取数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问主存地址 12&lt;/strong&gt;：如果缓存已满，选择一行替换。例如，使用 LRU 替换最近未访问的行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总结-3&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#总结-3&#34;&gt;#&lt;/a&gt; 总结&lt;/h3&gt;
&lt;p&gt;全相联映射通过允许任意主存块存放到任意缓存行，消除了缓存行冲突，适用于对命中率要求高的应用。然而，它实现复杂且需要替换策略，在硬件上更难实现，因此常用于小型缓存或与其他映射方式（如组相联映射）结合使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;组关联映射组相联映射&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#组关联映射组相联映射&#34;&gt;#&lt;/a&gt; 组关联映射（组相联映射）&lt;/h3&gt;
&lt;p&gt;Cache&lt;strong&gt; 分为若干组&lt;/strong&gt;，每一组包含相同数量的行，每个主存块被映射到&lt;strong&gt;固定组的任意一行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分组是连续分组，即第 01 行是第 0 组，第 23 行是第 1 组……&lt;/p&gt;
&lt;p&gt;假设 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;s&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 是 cache 组号，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 是主存块号，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;S&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 是组数&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;s&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; $= $ &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mod&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;S&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;S&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.05764em;&#34;&gt;S&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;K - 路组关联映射：&lt;/p&gt;
&lt;p&gt;K = C / S（C 为行数，S 为组数）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA7/c3f60e48b12c5f8a8612769a5465e041.png&#34; alt=&#34;c3f60e48b12c5f8a8612769a5465e041.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;假设 cache 有 4 行，每行包含 8 个字（即块大小为 8 个字，cache 里的一行对应着内存里的一个块），分成 2 个组；主存中包含 128 个字。访问主存的地址长度为 7 位，则：&lt;/p&gt;
&lt;p&gt;最低的 3 位：块内地址（一个块内有 8 个字）&lt;/p&gt;
&lt;p&gt;中间的 1 位：映射时所对应的 Cache 中的组（2 个组）&lt;/p&gt;
&lt;p&gt;最高的 3 位：区分映射到同一组的不同块，记录为 Cache 标记（一个组内分了 8 个块）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;gpt 的解释&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组相联映射&lt;/strong&gt;（Set Associative Mapping）是缓存映射的一种折中方式，结合了直接映射和全相联映射的优点。它将缓存分成多个&lt;strong&gt;组&lt;/strong&gt;（Set），每组包含若干个缓存行，每个内存块可以映射到一个特定的组，但可以存放在组中的任何缓存行。这种映射方式能够有效减少缓存冲突，同时又避免了全相联映射的高复杂度。&lt;/p&gt;
&lt;h3 id=&#34;组相联映射的基本原理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#组相联映射的基本原理&#34;&gt;#&lt;/a&gt; 组相联映射的基本原理&lt;/h3&gt;
&lt;p&gt;在组相联映射中，缓存分为  &lt;code&gt;N&lt;/code&gt;  个组，每组包含  &lt;code&gt;k&lt;/code&gt;  个缓存行（这种缓存通常称为&lt;strong&gt; k 路组相联缓存&lt;/strong&gt;）。主存中的每个块只能映射到缓存中的一个组，但在组内的  &lt;code&gt;k&lt;/code&gt;  个缓存行中可以任选一个来存放。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;映射方式&lt;/strong&gt;：通过主存地址找到数据所在的组（类似直接映射），然后在组内的所有缓存行中查找对应的标记位（类似全相联映射）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标记位（Tag）：&lt;/strong&gt; 用于区分同一组中不同内存块的标记，确保是正确的数据块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;组索引位（Set Index）：&lt;/strong&gt; 用于找到特定的数据组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;块内偏移（Block Offset）：&lt;/strong&gt; 用于定位块内的具体字节。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;地址分解&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#地址分解&#34;&gt;#&lt;/a&gt; 地址分解&lt;/h3&gt;
&lt;p&gt;假设有一个 (2^m) 大小的缓存，分为 ( 2^s ) 个组，每组有  &lt;code&gt;k&lt;/code&gt;  个缓存行。主存地址分为以下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标记位（Tag）：&lt;/strong&gt; 用来确认数据块的唯一性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;组索引位（Set Index）：&lt;/strong&gt; 用于定位缓存中的特定组，组数为 (2^s)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;块内偏移（Block Offset）：&lt;/strong&gt; 用于在数据块内找到具体的字节。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;访问过程-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#访问过程-2&#34;&gt;#&lt;/a&gt; 访问过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从主存地址中提取组索引位，找到数据块映射到的组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在该组中，依次检查  &lt;code&gt;k&lt;/code&gt;  个缓存行的标记位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果找到匹配的标记位，则缓存&lt;strong&gt;命中&lt;/strong&gt;，可以直接读取数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有找到匹配项，则缓存&lt;strong&gt;未命中&lt;/strong&gt;，需要从主存中加载数据块到缓存的该组中一个空闲或替换的行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;替换策略&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#替换策略&#34;&gt;#&lt;/a&gt; 替换策略&lt;/h3&gt;
&lt;p&gt;如果目标组中的缓存行已满且需要加载新数据，则需要选择一个行进行替换。常用的替换策略与全相联映射类似，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LRU（最近最少使用）：&lt;/strong&gt; 替换组内最近最少被访问的缓存行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;随机替换&lt;/strong&gt;：随机替换一个缓存行，简单且快速。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示例-3&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#示例-3&#34;&gt;#&lt;/a&gt; 示例&lt;/h3&gt;
&lt;p&gt;假设有一个&lt;strong&gt; 4 路组相联缓存&lt;/strong&gt;，总共 8 行，即缓存分成 2 个组，每组 4 行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问主存地址 4&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算组索引，找到主存地址 4 映射到缓存的第 0 组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查第 0 组的所有缓存行，发现没有匹配的标记位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将主存地址 4 的数据块加载到第 0 组的一个空闲行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问主存地址 12&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算组索引，发现地址 12 也映射到第 0 组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查第 0 组中的缓存行，发现没有匹配的标记位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将主存地址 12 的数据块加载到第 0 组的一个空闲行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;再次访问主存地址 4&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算组索引，找到第 0 组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现标记位匹配，因此&lt;strong&gt;命中&lt;/strong&gt;，可以直接读取数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;访问主存地址 20&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算组索引，地址 20 映射到第 1 组。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组内没有匹配的标记位，将地址 20 的数据块加载到第 1 组的一个空闲行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;优缺点-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#优缺点-2&#34;&gt;#&lt;/a&gt; 优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过将缓存分成多组，减少了直接映射中的缓存冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查找过程比全相联映射简单，硬件开销相对较低。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比直接映射复杂度略高，硬件上需要实现组内的部分相联查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;总结-4&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#总结-4&#34;&gt;#&lt;/a&gt; 总结&lt;/h3&gt;
&lt;p&gt;组相联映射通过折中策略，将缓存划分成多个组，每个主存块只能映射到特定组，组内缓存行可以灵活存放数据。它在减少缓存冲突的同时，不需要全相联映射的复杂硬件支持，因此被广泛应用于现代处理器的缓存设计中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三种映射方式比较&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#三种映射方式比较&#34;&gt;#&lt;/a&gt; 三种映射方式比较&lt;/h3&gt;
&lt;p&gt;三种方式的相关性&lt;/p&gt;
&lt;p&gt;如果 K = 1，组关联映射等同于直接映射&lt;/p&gt;
&lt;p&gt;如果 K = C，组关联映射等同于关联映射&lt;/p&gt;
&lt;p&gt;K 是一组中行的数目，C 是 Cache 的行数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关联度&lt;/strong&gt;：一个主存块映射到 cache 中&lt;strong&gt;可能存放的位置个数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接映射：1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关联映射：C&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组关联映射：K&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关联度&lt;strong&gt;越低&lt;/strong&gt;，命中率越低，判断是否命中的时间越短，标记所占额外空间开销越小&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接映射的命中率最低，命中时间最短，标记最短。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关联映射的命中率最高，命中时间最长，标记最长。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;替换算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#替换算法&#34;&gt;#&lt;/a&gt; 替换算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最近最少使用算法（Least Recently Used, LRU）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先进先出算法（First In First Out, FIFO）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最不经常使用算法（Least Frequently Used, LFU）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随机替换算法（Random）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;最近最少使用算法-lru&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#最近最少使用算法-lru&#34;&gt;#&lt;/a&gt; 最近最少使用算法 LRU&lt;/h3&gt;
&lt;p&gt;替换掉在 cache 中&lt;strong&gt;最长时间未被访问&lt;/strong&gt;的数据块&lt;/p&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加 LRU 位，来标记访问时间（01234…… 数字越小表示越久没被访问）每次替换为 0 的块。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LRU 位需要额外的硬件实现，会增加 cache 访问时间&lt;/p&gt;
&lt;h3 id=&#34;先进先出算法-fifo&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#先进先出算法-fifo&#34;&gt;#&lt;/a&gt; 先进先出算法 FIFO&lt;/h3&gt;
&lt;p&gt;替换掉在 Cache 中&lt;strong&gt;停留时间最长&lt;/strong&gt;的块&lt;/p&gt;
&lt;p&gt;实现：时间片轮转法或环形缓冲技术&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每行包含一个标识位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当同一组中的某行被替换时，将其标识位设为 1，同时将&lt;strong&gt;下一行&lt;/strong&gt;的标识位设为 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果被替换的是该组中的最后一行，则将该组中的第一行的标识位设为 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;替换掉标识位为 0 的行中的数据块&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;标识位需要额外的硬件实现&lt;/p&gt;
&lt;h3 id=&#34;最不经常使用算法-lfu&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#最不经常使用算法-lfu&#34;&gt;#&lt;/a&gt; 最不经常使用算法 LFU&lt;/h3&gt;
&lt;p&gt;替换掉 cache 中被访问次数最少的数据块&lt;/p&gt;
&lt;p&gt;实现：为每一行设置&lt;strong&gt;计数器&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;随机替换算法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#随机替换算法&#34;&gt;#&lt;/a&gt; 随机替换算法&lt;/h3&gt;
&lt;p&gt;随机替换&lt;/p&gt;
&lt;h2 id=&#34;写策略&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#写策略&#34;&gt;#&lt;/a&gt; 写策略&lt;/h2&gt;
&lt;p&gt;考虑到主存和 Cache 的一致性，当 Cache 中某个数据块被修改时，需要考虑该数据块是否被修改。若被修改了，则在替换之前，需要将修改后的数据块写回主存。&lt;/p&gt;
&lt;h3 id=&#34;写直达-write-through&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#写直达-write-through&#34;&gt;#&lt;/a&gt; 写直达 Write Through&lt;/h3&gt;
&lt;p&gt;所有写操作都&lt;strong&gt;同时&lt;/strong&gt;对 cache 和主存进行&lt;/p&gt;
&lt;p&gt;会产生大量主存访问。&lt;/p&gt;
&lt;h3 id=&#34;写回-write-back&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#写回-write-back&#34;&gt;#&lt;/a&gt; 写回 Write Back&lt;/h3&gt;
&lt;p&gt;先更新 cache 中的数据，当 cache 中某个数据块被替换时，如果它被修改了，才被写回主存&lt;/p&gt;
&lt;p&gt;利用一个 ** 脏位（dirty bit）** 或者使用位（use bit）来表示块是否被修改&lt;/p&gt;
&lt;h3 id=&#34;缓存未命中时的写策略&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#缓存未命中时的写策略&#34;&gt;#&lt;/a&gt; 缓存未命中时的写策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写不分配&lt;/strong&gt;（Write Non-Allocate）：&lt;strong&gt;直接将数据写入主存&lt;/strong&gt;，无需读入 cache&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：避免 cache 和主存中的数据不一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常搭配：&lt;strong&gt;写直达&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写分配&lt;/strong&gt;（Write Allocate）：将数据所在的块&lt;strong&gt;读入 cache 后&lt;/strong&gt;，在 cache 中更新内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：利用了 cache 的高速特性，&lt;strong&gt;减少写内存次数&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常搭配：&lt;strong&gt;写回法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;行大小&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#行大小&#34;&gt;#&lt;/a&gt; 行大小&lt;/h2&gt;
&lt;p&gt;假设从行的大小为一个字开始，随着行大小的逐步增大，则 Cache 命中率会增加&lt;/p&gt;
&lt;p&gt;当行大小变得较大之后，继续增加行大小，则 Cache 命中率会下降&lt;/p&gt;
&lt;h2 id=&#34;cache-数目&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cache-数目&#34;&gt;#&lt;/a&gt; Cache 数目&lt;/h2&gt;
&lt;p&gt;略&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/COA/</guid>
            <title>计组期末复习 1~6讲</title>
            <link>https://erinwithbmq.github.io/2025/01/11/COA/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="计算机组织结构" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 19:09:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;LaTeX 渲染有问题。将就着看吧。&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id=&#34;第一讲-计算机系统概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一讲-计算机系统概述&#34;&gt;#&lt;/a&gt; 第一讲 计算机系统概述&lt;/h1&gt;
&lt;h2 id=&#34;组织与结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#组织与结构&#34;&gt;#&lt;/a&gt; 组织与结构&lt;/h2&gt;
&lt;p&gt;许多计算机制造商提供了一系列的计算机模型，它们都具有相同的体系结构，但组成不同。&lt;/p&gt;
&lt;p&gt;一台机器是否具备乘法指令的功能，这是计算机体系&lt;strong&gt;结构&lt;/strong&gt;的问题&lt;/p&gt;
&lt;p&gt;如何实现这个乘法指令的，使用专门的乘法电路还是采用连续相加的加法电路等，这是计算机&lt;strong&gt;组成&lt;/strong&gt;的问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组织&lt;/strong&gt;：对编程人员不可见。可以理解为具体功能实现的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构&lt;/strong&gt;：对编程人员可见。理解为有哪些功能、指令等。&lt;/p&gt;
&lt;h2 id=&#34;指令集体系结构-isa&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指令集体系结构-isa&#34;&gt;#&lt;/a&gt; 指令集体系结构 ISA&lt;/h2&gt;
&lt;p&gt;ISA 是一种规约（Specification），它规定了如何使用硬件。&lt;/p&gt;
&lt;p&gt;在通用计算机系统是必不可少的一个抽象层。&lt;/p&gt;
&lt;h2 id=&#34;摩尔定律&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#摩尔定律&#34;&gt;#&lt;/a&gt; 摩尔定律&lt;/h2&gt;
&lt;p&gt;当&lt;strong&gt;价格&lt;/strong&gt;不变时，单芯片上所能包含的晶体管数量&lt;strong&gt;每年翻一番&lt;/strong&gt;（后来变成每 18 个月翻一番）&lt;/p&gt;
&lt;h2 id=&#34;冯诺依曼结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#冯诺依曼结构&#34;&gt;#&lt;/a&gt; 冯诺依曼结构&lt;/h2&gt;
&lt;p&gt;三个基本原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;二进制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5 个组成部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主存储器&lt;/strong&gt;：地址和存储的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;算术逻辑单元 / 处理单元 ALU&lt;/strong&gt;：执行信息的实际处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;程序控制单元 / 控制单元 PC&lt;/strong&gt;：指挥信息的处理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入设备&lt;/strong&gt;：将信息送入计算机中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出设备&lt;/strong&gt;：将处理结果以某种形式显示在计算机外&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/image.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内存是存储器；硬盘是输入输出设备&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;冯・诺伊曼的最重要的思想是 “&lt;strong&gt;存储程序（Stored-program）&lt;/strong&gt;”&lt;/p&gt;
&lt;h2 id=&#34;计算机性能&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#计算机性能&#34;&gt;#&lt;/a&gt; 计算机性能&lt;/h2&gt;
&lt;p&gt;计算机设计的主要目标是：提高 CPU 性能&lt;/p&gt;
&lt;h3 id=&#34;cpu-性能&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cpu-性能&#34;&gt;#&lt;/a&gt; CPU 性能&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;时钟频率 f&lt;/strong&gt; / 时钟速度（单位：Hz）&lt;/p&gt;
&lt;p&gt;计算机&lt;strong&gt;在单位时间内&lt;/strong&gt;（例如 1 秒钟）执行最基本操作的&lt;strong&gt;次数&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;时钟周期 t&lt;/strong&gt; / 周期时间（单位：s）&lt;/p&gt;
&lt;p&gt;执行每次最基本操作的时间&lt;/p&gt;
&lt;ul&gt;
&lt;li f=&#34;&#34;&gt;
&lt;p&gt;时钟周期是时钟频率的倒数。t = \frac{1}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;周期时间即为两个电子脉冲之间的时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/5cdbdfaa3d2dd5de4fc26e60ddfa85da.png&#34; alt=&#34;5cdbdfaa3d2dd5de4fc26e60ddfa85da.png&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPI&lt;/strong&gt;（Cycles Per Instruction）&lt;strong&gt;每条指令所要的时钟周期数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也可以理解为&lt;strong&gt;每条指令所需要的基本操作的次数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/a34a2ef067e6aa328287a4b89b208c61.png&#34; alt=&#34;a34a2ef067e6aa328287a4b89b208c61.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;整个 CPI，即平均每条指令所需要的时钟周期数，用&lt;strong&gt;总时钟周期数除以总指令数&lt;/strong&gt;即可。总时钟周期数，通过把不同种指令总时钟周期数相加得到。&lt;/p&gt;
&lt;p&gt;一个程序的处理时间：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T = I_c*CPI*t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，即总时钟周期数乘以单个时钟周期的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MIPS&lt;/strong&gt; （Million Instructions Per Second）&lt;strong&gt;每秒百万条指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MIPS 表示 CPU &lt;strong&gt;每秒钟可以执行多少百万条指令&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/e442eb966ae7e0a184cde9e08b6250f4.png&#34; alt=&#34;e442eb966ae7e0a184cde9e08b6250f4.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;首先计算每秒执行多少条指令。即用&lt;strong&gt;总指令条数除以总时间&lt;/strong&gt;（单位 s）。接着换算成每秒执行多少百万条指令。即再除以 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;10^6&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;由于 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;T = I_c*CPI*t&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.61508em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，因此公式也可换成后面那种形式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MFLOPS&lt;/strong&gt;（Million Floating Point Operations Per Second）&lt;strong&gt;百万浮点运算每秒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/f8ae9a6c07156135f3e565d5c22d74f9.png&#34; alt=&#34;f8ae9a6c07156135f3e565d5c22d74f9.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/5151377bbc7473a7a335e883b1771980.png&#34; alt=&#34;5151377bbc7473a7a335e883b1771980.png&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU 性能的基准程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用一系列基准程序来测量系统的性能&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/f3f2daeb6b07bfa5c36457a5515d3df9.png&#34; alt=&#34;f3f2daeb6b07bfa5c36457a5515d3df9.png&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;性能设计的基本原则&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#性能设计的基本原则&#34;&gt;#&lt;/a&gt; 性能设计的基本原则&lt;/h3&gt;
&lt;p&gt;Amdahl 定律&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的重要性比例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能增加的递减规则：如果仅仅对计算机中的一部分做性能改进，改进越多，系统获得的效果越小。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算机顶层结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#计算机顶层结构&#34;&gt;#&lt;/a&gt; 计算机顶层结构&lt;/h2&gt;
&lt;h3 id=&#34;cpu&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cpu&#34;&gt;#&lt;/a&gt; CPU&lt;/h3&gt;
&lt;p&gt;中央处理单元（Central Processing Unit, CPU）: 获取并执行指令的计算机组成部分，它由 ** 一个 ALU、一个控制单元（PC）和多个寄存器（Reg）** 构成。在单处理单元系统中，它通常简称为处理器。&lt;/p&gt;
&lt;h3 id=&#34;存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#存储器&#34;&gt;#&lt;/a&gt; 存储器&lt;/h3&gt;
&lt;p&gt;在本门课及相关作业中，主存不等同于内存，因为准确来说，内部存储器确实不止包括主存。另外，从两本教材的整体术语使用情况来看，通常还是采用更准确的表述，即 “主存”。&lt;/p&gt;
&lt;p&gt;主存（主存储器）是内存（内部存储器）的一部分。&lt;/p&gt;
&lt;p&gt;内部存储器（内存）包含寄存器、高速缓存和主存。&lt;/p&gt;
&lt;h1 id=&#34;第二讲-数据的机器级表示&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第二讲-数据的机器级表示&#34;&gt;#&lt;/a&gt; 第二讲 数据的机器级表示&lt;/h1&gt;
&lt;h2 id=&#34;整数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#整数&#34;&gt;#&lt;/a&gt; 整数&lt;/h2&gt;
&lt;p&gt;正数原码反码补码都一样。&lt;/p&gt;
&lt;p&gt;负数：以 -8 为例&lt;/p&gt;
&lt;p&gt;原码：10001000 最高位代表是负数。其余正常&lt;/p&gt;
&lt;p&gt;反码：11110111 除了最高位外其他位取反&lt;/p&gt;
&lt;p&gt;补码：11111000 反码＋1&lt;/p&gt;
&lt;p&gt;一个负数的补码等于将对应正数补码 &lt;strong&gt;各位取反、末位加一&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;移码表示&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#移码表示&#34;&gt;#&lt;/a&gt; 移码表示&lt;/h3&gt;
&lt;p&gt;将每一个数值加上一个偏置常数（excess/bias）&lt;/p&gt;
&lt;p&gt;通常当编码位数为 n 时，bias 取 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;𝟐&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt;−&lt;/mtext&gt;&lt;mi&gt;𝟏&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;𝟐^{n−𝟏}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathbf&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathbf mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 或 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;𝟐&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mtext&gt;−&lt;/mtext&gt;&lt;mi&gt;𝟏&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mtext&gt;−&lt;/mtext&gt;&lt;mi&gt;𝟏&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;𝟐^{n−𝟏}−𝟏&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.897438em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathbf&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathbf mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathbf&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/e0426457488c752c26b313852ea24f31.png&#34; alt=&#34;e0426457488c752c26b313852ea24f31.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/0ff0b17b7048512c99c95c38186dc62f.png&#34; alt=&#34;0ff0b17b7048512c99c95c38186dc62f.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;差别在于原码里 0 有两种表示方式，因此范围少了 1.&lt;/p&gt;
&lt;h2 id=&#34;浮点数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#浮点数&#34;&gt;#&lt;/a&gt; 浮点数&lt;/h2&gt;
&lt;h3 id=&#34;规格化数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#规格化数&#34;&gt;#&lt;/a&gt; 规格化数&lt;/h3&gt;
&lt;p&gt;顺序：SEM（&lt;em&gt;因为比较大小，按这个顺序最快&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/c34977f7357bacdf73b2632bcbca4ccc.png&#34; alt=&#34;c34977f7357bacdf73b2632bcbca4ccc.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;ieee-754-标准&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ieee-754-标准&#34;&gt;#&lt;/a&gt; IEEE 754 标准&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/0b43ada42bf4fdc23e371f4246b56cab.png&#34; alt=&#34;0b43ada42bf4fdc23e371f4246b56cab.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;E 为无符号，计算出的值减去 127 得到阶码（规格化情况）。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/85b005e3d6f2a140acaf60d7ab17d329.png&#34; alt=&#34;85b005e3d6f2a140acaf60d7ab17d329.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/659939a3329173795ff64282091978ab.png&#34; alt=&#34;659939a3329173795ff64282091978ab.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;非规格化数，隐藏位为 0，阶码设为 - 126.&lt;/p&gt;
&lt;h2 id=&#34;nbcd-码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nbcd-码&#34;&gt;#&lt;/a&gt; NBCD 码&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/c80e895027d637e150c7a34ba150859c.png&#34; alt=&#34;c80e895027d637e150c7a34ba150859c.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;前四位为符号位。1100 为正，1101 为负。&lt;/p&gt;
&lt;h2 id=&#34;补充int-与-float-精度&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#补充int-与-float-精度&#34;&gt;#&lt;/a&gt; 补充：int 与 float 精度&lt;/h2&gt;
&lt;p&gt;float 能表示更大的数&lt;/p&gt;
&lt;p&gt;靠近 0，float 精度更大&lt;/p&gt;
&lt;p&gt;数字越大，int 精度越大&lt;/p&gt;
&lt;p&gt;当 e = 23 时，int 与 float 精度相似。大于 23 后，int 精度更大。&lt;/p&gt;
&lt;h1 id=&#34;第三讲-整数运算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第三讲-整数运算&#34;&gt;#&lt;/a&gt; 第三讲 整数运算&lt;/h1&gt;
&lt;h2 id=&#34;加法器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#加法器&#34;&gt;#&lt;/a&gt; 加法器&lt;/h2&gt;
&lt;p&gt;与门延迟: 1 级门延迟 (1ty)&lt;/p&gt;
&lt;p&gt;或门延迟: 1 级门延迟 (1ty)&lt;/p&gt;
&lt;p&gt;异或门延迟: 3 级门延迟 (3ty)&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/c48b18d1072e007164d56c395c2ff9e1.png&#34; alt=&#34;c48b18d1072e007164d56c395c2ff9e1.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;F：6ty，Cout：5ty（上面那个带一个弧的是异或门）&lt;/p&gt;
&lt;p&gt;F 是和，C 是进位&lt;/p&gt;
&lt;h3 id=&#34;全先行进位加法器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#全先行进位加法器&#34;&gt;#&lt;/a&gt; 全先行进位加法器&lt;/h3&gt;
&lt;p&gt;高位的运算必须等待低位的 “进位输出信号” 能否提前计算出 “进位输出信号”？—— 使用全先行进位加法器&lt;/p&gt;
&lt;p&gt;延迟：1ty + 2ty + 3ty = 6ty&lt;/p&gt;
&lt;p&gt;延迟和加法器的位数无关&lt;/p&gt;
&lt;h2 id=&#34;补码表示的整数运算加法减法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#补码表示的整数运算加法减法&#34;&gt;#&lt;/a&gt; 补码表示的整数运算：加法，减法&lt;/h2&gt;
&lt;p&gt;如何判断溢出？若两个符号不同的数字相加，不会溢出。&lt;/p&gt;
&lt;p&gt;若同号数字相加后变号，则溢出。&lt;/p&gt;
&lt;p&gt;减法：将一方变为相反数后进行加法。溢出同理判断。&lt;/p&gt;
&lt;h2 id=&#34;补码表示的整数运算乘法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#补码表示的整数运算乘法&#34;&gt;#&lt;/a&gt; 补码表示的整数运算：乘法&lt;/h2&gt;
&lt;p&gt;布斯乘法略&lt;/p&gt;
&lt;p&gt;溢出：&lt;/p&gt;
&lt;p&gt;硬件不判断溢出：寄存器会&lt;strong&gt;存 2n 位乘积&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件判断溢出：1）编译器判断溢出；2）程序员通过高级语言判断溢出&lt;/p&gt;
&lt;h2 id=&#34;补码表示的整数运算除法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#补码表示的整数运算除法&#34;&gt;#&lt;/a&gt; 补码表示的整数运算：除法&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/77e1d15d7edfcf490624205c87b0b5d6.png&#34; alt=&#34;77e1d15d7edfcf490624205c87b0b5d6.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;恢复余数除法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#恢复余数除法&#34;&gt;#&lt;/a&gt; 恢复余数除法&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/d9a6a25979642cdfa474b902ddaefce7.png&#34; alt=&#34;d9a6a25979642cdfa474b902ddaefce7.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;不恢复余数除法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#不恢复余数除法&#34;&gt;#&lt;/a&gt; 不恢复余数除法&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/4025536b2f6079c564778ed955f0f6d8.png&#34; alt=&#34;4025536b2f6079c564778ed955f0f6d8.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/01ca87484032c3b283836c7d490afa18.png&#34; alt=&#34;01ca87484032c3b283836c7d490afa18.png&#34; /&gt;&lt;/p&gt;
&lt;h1 id=&#34;第四讲-浮点数运算&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第四讲-浮点数运算&#34;&gt;#&lt;/a&gt; 第四讲 浮点数运算&lt;/h1&gt;
&lt;h2 id=&#34;加法和减法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#加法和减法&#34;&gt;#&lt;/a&gt; 加法和减法&lt;/h2&gt;
&lt;p&gt;必须确保两个操作数具有相同的&lt;strong&gt;指数值（阶）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;低阶向高阶对齐。&lt;/p&gt;
&lt;p&gt;最后规格化&lt;/p&gt;
&lt;h2 id=&#34;乘法和除法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#乘法和除法&#34;&gt;#&lt;/a&gt; 乘法和除法&lt;/h2&gt;
&lt;p&gt;阶码相加减&lt;/p&gt;
&lt;p&gt;尾数相乘除&lt;/p&gt;
&lt;p&gt;最后规格化结果&lt;/p&gt;
&lt;h2 id=&#34;精度考虑数据类型&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#精度考虑数据类型&#34;&gt;#&lt;/a&gt; 精度考虑：数据类型&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/65baa900bd7a110f58cf0126e8c3631d.png&#34; alt=&#34;65baa900bd7a110f58cf0126e8c3631d.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GPT 解释&lt;/p&gt;
&lt;p&gt;下面逐条解释图中的判断及其恒真性：&lt;/p&gt;
&lt;h3 id=&#34;1-x-intfloatx-恒假&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-x-intfloatx-恒假&#34;&gt;#&lt;/a&gt; 1. &lt;strong&gt; &lt;code&gt;X == (int)(float)X&lt;/code&gt; &lt;/strong&gt; （恒假）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;X&lt;/code&gt;  是  &lt;code&gt;int&lt;/code&gt;  类型， &lt;code&gt;(float)X&lt;/code&gt;  将  &lt;code&gt;X&lt;/code&gt;  转换为  &lt;code&gt;float&lt;/code&gt;  类型，可能会引入精度损失（例如，对于某些较大的  &lt;code&gt;int&lt;/code&gt;  值， &lt;code&gt;float&lt;/code&gt;  无法精确表示它们）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再将  &lt;code&gt;(float)X&lt;/code&gt;  转换回  &lt;code&gt;int&lt;/code&gt;  时，如果由于精度损失导致值变化，则恒假。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;X = 2147483647&lt;/code&gt; （ &lt;code&gt;int&lt;/code&gt;  的最大值），转换为  &lt;code&gt;float&lt;/code&gt;  会失去精度，导致最终结果不等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;2-x-intdoublex-恒真&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-x-intdoublex-恒真&#34;&gt;#&lt;/a&gt; 2. &lt;strong&gt; &lt;code&gt;X == (int)(double)X&lt;/code&gt; &lt;/strong&gt; （恒真）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;X&lt;/code&gt;  是  &lt;code&gt;int&lt;/code&gt;  类型， &lt;code&gt;(double)X&lt;/code&gt;  将  &lt;code&gt;X&lt;/code&gt;  转换为更高精度的  &lt;code&gt;double&lt;/code&gt;  类型， &lt;code&gt;double&lt;/code&gt;  能精确表示  &lt;code&gt;int&lt;/code&gt;  范围内的所有值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再将  &lt;code&gt;(double)X&lt;/code&gt;  转回  &lt;code&gt;int&lt;/code&gt;  时，值不会发生变化，因此恒真。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;3-f-floatdoublef-恒真&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-f-floatdoublef-恒真&#34;&gt;#&lt;/a&gt; 3. &lt;strong&gt; &lt;code&gt;F == (float)(double)F&lt;/code&gt; &lt;/strong&gt; （恒真）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;F&lt;/code&gt;  是  &lt;code&gt;float&lt;/code&gt;  类型， &lt;code&gt;(double)F&lt;/code&gt;  将其转换为更高精度的  &lt;code&gt;double&lt;/code&gt;  类型，再将其转换回  &lt;code&gt;float&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然  &lt;code&gt;double&lt;/code&gt;  有更高精度，但转换为  &lt;code&gt;double&lt;/code&gt;  并不会改变  &lt;code&gt;float&lt;/code&gt;  原本的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后转换回  &lt;code&gt;float&lt;/code&gt;  时，值也不会发生变化，因此恒真。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;4-d-floatd-恒假&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-d-floatd-恒假&#34;&gt;#&lt;/a&gt; 4. &lt;strong&gt; &lt;code&gt;D == (float)D&lt;/code&gt; &lt;/strong&gt; （恒假）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;D&lt;/code&gt;  是  &lt;code&gt;double&lt;/code&gt;  类型， &lt;code&gt;(float)D&lt;/code&gt;  将其转换为精度较低的  &lt;code&gt;float&lt;/code&gt;  类型，可能导致精度损失。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果  &lt;code&gt;D&lt;/code&gt;  中包含无法用  &lt;code&gt;float&lt;/code&gt;  精确表示的值（如小数点后的更多有效数字或较大的数值），则转换后会产生误差，导致不相等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;5-x-floatx-恒假&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-x-floatx-恒假&#34;&gt;#&lt;/a&gt; 5. &lt;strong&gt; &lt;code&gt;X == (float)X&lt;/code&gt; &lt;/strong&gt; （恒假）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;X&lt;/code&gt;  是  &lt;code&gt;int&lt;/code&gt;  类型， &lt;code&gt;(float)X&lt;/code&gt;  将其转换为浮点数类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;float&lt;/code&gt;  表示的整数值可能因精度限制出现误差，特别是在较大的整数时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;X = 16777217&lt;/code&gt; （ &lt;code&gt;float&lt;/code&gt;  的精度极限之外的值），此时  &lt;code&gt;(float)X&lt;/code&gt;  将近似为  &lt;code&gt;16777216&lt;/code&gt; ，导致不相等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;6-x-x-0-恒假&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#6-x-x-0-恒假&#34;&gt;#&lt;/a&gt; 6. &lt;strong&gt; &lt;code&gt;X * X &amp;gt;= 0&lt;/code&gt; &lt;/strong&gt; （恒假）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于  &lt;code&gt;int&lt;/code&gt;  类型， &lt;code&gt;X * X&lt;/code&gt;  的结果应该始终非负。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然而， &lt;code&gt;int&lt;/code&gt;  的乘法可能溢出，导致结果变为负数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;X = 46341&lt;/code&gt; ，则  &lt;code&gt;X * X = 2147488281&lt;/code&gt; （溢出为负数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;7-f-f-0-恒真&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#7-f-f-0-恒真&#34;&gt;#&lt;/a&gt; 7. &lt;strong&gt; &lt;code&gt;F * F &amp;gt;= 0&lt;/code&gt; &lt;/strong&gt; （恒真）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浮点数  &lt;code&gt;F&lt;/code&gt;  的平方恒为非负，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若  &lt;code&gt;F&lt;/code&gt;  为正或零， &lt;code&gt;F * F&lt;/code&gt;  结果为正或零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若  &lt;code&gt;F&lt;/code&gt;  为负， &lt;code&gt;F * F&lt;/code&gt;  结果仍为正。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;唯一特殊值是  &lt;code&gt;NaN&lt;/code&gt; （Not-a-Number），但在比较中不会返回  &lt;code&gt;true&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;8-d-f-d-f-恒假&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#8-d-f-d-f-恒假&#34;&gt;#&lt;/a&gt; 8. &lt;strong&gt; &lt;code&gt;(D + F) - D == F&lt;/code&gt; &lt;/strong&gt; （恒假）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;D&lt;/code&gt;  是  &lt;code&gt;double&lt;/code&gt;  类型， &lt;code&gt;F&lt;/code&gt;  是  &lt;code&gt;float&lt;/code&gt;  类型， &lt;code&gt;D + F&lt;/code&gt;  会将  &lt;code&gt;F&lt;/code&gt;  转换为  &lt;code&gt;double&lt;/code&gt;  后再计算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于  &lt;code&gt;F&lt;/code&gt;  转换为  &lt;code&gt;double&lt;/code&gt;  可能存在精度误差，结果中的  &lt;code&gt;(D + F) - D&lt;/code&gt;  可能与  &lt;code&gt;F&lt;/code&gt;  不完全相等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;D = 1.000000000000001&lt;/code&gt; ， &lt;code&gt;F = 1.0&lt;/code&gt; ，此时  &lt;code&gt;D + F&lt;/code&gt;  会有误差。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;9-d-f-f-d-恒假&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#9-d-f-f-d-恒假&#34;&gt;#&lt;/a&gt; 9. &lt;strong&gt; &lt;code&gt;(D + F) - F == D&lt;/code&gt; &lt;/strong&gt; （恒假）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类似于第 8 条， &lt;code&gt;F&lt;/code&gt;  转换为  &lt;code&gt;double&lt;/code&gt;  后可能失去部分精度，因此  &lt;code&gt;(D + F) - F&lt;/code&gt;  可能与  &lt;code&gt;D&lt;/code&gt;  不完全相等。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;10-13-130-恒假&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#10-13-130-恒假&#34;&gt;#&lt;/a&gt; 10. &lt;strong&gt; &lt;code&gt;1/3 == 1/3.0&lt;/code&gt; &lt;/strong&gt; （恒假）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;1/3&lt;/code&gt;  是整除操作，结果为  &lt;code&gt;0&lt;/code&gt; （因为两个整数相除，结果仍为整数）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;1/3.0&lt;/code&gt;  是浮点数除法，结果为  &lt;code&gt;0.3333...&lt;/code&gt; （近似值）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为  &lt;code&gt;0&lt;/code&gt;  不等于  &lt;code&gt;0.3333...&lt;/code&gt; ，所以恒假。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&#34;总结&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#总结&#34;&gt;#&lt;/a&gt; 总结&lt;/h3&gt;
&lt;p&gt;这张图主要考察了&lt;strong&gt;类型转换&lt;/strong&gt;和&lt;strong&gt;数值精度&lt;/strong&gt;的问题，包括整数与浮点数之间的转换、浮点数的精度损失、以及溢出等特性。理解这些需要熟悉数据类型的表示和计算机的浮点数运算规则。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;精度考虑附加位与舍入&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#精度考虑附加位与舍入&#34;&gt;#&lt;/a&gt; 精度考虑：附加位与舍入&lt;/h2&gt;
&lt;p&gt;两位附加位&lt;/p&gt;
&lt;p&gt;IEEE754 规定：中间结果须在右边加 2 个附加位（Guard &amp;amp; Round）&lt;/p&gt;
&lt;p&gt;・保护位（Guard）：在尾数右边的位，左规时被移到尾数中&lt;/p&gt;
&lt;p&gt;・舍入位（Round）：在保护位右边的位，作为舍入的依据&lt;/p&gt;
&lt;p&gt;舍入方法（四种）：&lt;/p&gt;
&lt;p&gt;向最近 (看保护位首位是 0 还是 1 各占一半 1 进 0 舍)&lt;/p&gt;
&lt;p&gt;向正无穷&lt;/p&gt;
&lt;p&gt;向负无穷&lt;/p&gt;
&lt;p&gt;向 0&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/2e974ef2e1df6caca99a8a32cc303978.png&#34; alt=&#34;2e974ef2e1df6caca99a8a32cc303978.png&#34; /&gt;&lt;/p&gt;
&lt;h1 id=&#34;第六讲-内部存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第六讲-内部存储器&#34;&gt;#&lt;/a&gt; 第六讲 内部存储器&lt;/h1&gt;
&lt;p&gt;存储器（Memory）由一定数量的单元构成，每个单元可以被唯一标识，每个单元都 有存储一个数值的能力&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;地址&lt;/strong&gt;：单元的唯一标识符（采用二进制）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;地址空间：&lt;strong&gt;可唯一标识的&lt;/strong&gt;单元总数&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;寻址能力：&lt;strong&gt;存储在&lt;/strong&gt;每个单元中的信息的位数&lt;/strong&gt;，即内存中能被单独识别并独立存放一个数据的&lt;strong&gt;最小内存空间&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大多数存储器是字节（8bit）寻址的，32 位计算机的最大寻址空间（地址空间）为 4GB （$ 2^&lt;ruby&gt;32} B = 2&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;{22&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;KB = 2^{12}MB = 4GB$)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;层次结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#层次结构&#34;&gt;#&lt;/a&gt; 层次结构&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/783ac71cfbade18661ef0dbeac699634.png&#34; alt=&#34;783ac71cfbade18661ef0dbeac699634.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;越上面的越靠近 cpu，存储空间越小，但速度越快&lt;/p&gt;
&lt;h2 id=&#34;半导体存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#半导体存储器&#34;&gt;#&lt;/a&gt; 半导体存储器&lt;/h2&gt;
&lt;p&gt;用&lt;strong&gt;半导体芯片&lt;/strong&gt;作主存储器是目前的主流做法&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/0264bfc4f4884c82f7508a59267084ad.png&#34; alt=&#34;0264bfc4f4884c82f7508a59267084ad.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;ram-随机存取存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ram-随机存取存储器&#34;&gt;#&lt;/a&gt; RAM 随机存取存储器&lt;/h3&gt;
&lt;p&gt;随机访问：对存储器中任意数据的访问所花费的时间与数据所在位置无关&lt;/p&gt;
&lt;p&gt;可以简单快速地进行读 / 写操作&lt;/p&gt;
&lt;p&gt;易失的（Volatile）&lt;/p&gt;
&lt;p&gt;类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SRAM 静态 RAM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRAM 动态 RAM&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SRAM 比 DRAM 更快，但加价格也更高&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/bc29e5e7d8daffd937120526d1f3b06e.png&#34; alt=&#34;bc29e5e7d8daffd937120526d1f3b06e.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;rom-只读存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rom-只读存储器&#34;&gt;#&lt;/a&gt; ROM 只读存储器&lt;/h3&gt;
&lt;p&gt;一种可以长期保存信息的存储器，具有断电后信息仍可继续保存的特点，在正常工作时只可读取数据，而&lt;strong&gt;不能写入数据&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;prom-可编程rom&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#prom-可编程rom&#34;&gt;#&lt;/a&gt; PROM 可编程 ROM&lt;/h4&gt;
&lt;p&gt;只能被写入一次，其他和 ROM 相同&lt;/p&gt;
&lt;p&gt;写过程是用电信号执行&lt;/p&gt;
&lt;p&gt;以下是主要进行读操作的存储器：&lt;/p&gt;
&lt;h3 id=&#34;eprom-光可擦除可编程只读存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#eprom-光可擦除可编程只读存储器&#34;&gt;#&lt;/a&gt; EPROM 光可擦除 / 可编程只读存储器&lt;/h3&gt;
&lt;p&gt;电写入（1-&amp;gt;0）&lt;/p&gt;
&lt;p&gt;光擦除（0-&amp;gt;1）在写操作前将封装芯片暴露在紫外线下&lt;/p&gt;
&lt;h3 id=&#34;eeprom-电可擦除可编程只读存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#eeprom-电可擦除可编程只读存储器&#34;&gt;#&lt;/a&gt; EEPROM 电可擦除 / 可编程只读存储器&lt;/h3&gt;
&lt;p&gt;电写入（1-&amp;gt;0）&lt;/p&gt;
&lt;p&gt;电擦除（0-&amp;gt;1）&lt;/p&gt;
&lt;p&gt;最贵&lt;/p&gt;
&lt;h3 id=&#34;flash-memory-快闪存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#flash-memory-快闪存储器&#34;&gt;#&lt;/a&gt; Flash memory 快闪存储器&lt;/h3&gt;
&lt;p&gt;电可擦除：与 EEPROM 原理类似，优于 EPROM&lt;/p&gt;
&lt;p&gt;可以在块级擦除，不能在字节级擦除：优于 EPROM，不如 EEPROM&lt;/p&gt;
&lt;p&gt;需要先擦除再写入&lt;/p&gt;
&lt;h2 id=&#34;寻址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#寻址&#34;&gt;#&lt;/a&gt; 寻址&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;位元（memory cell）&lt;/strong&gt;：半导体存储器的基本元件，用于存储 1 位数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寻址单元&lt;/strong&gt;：由若干相同地址的位元组成&lt;/p&gt;
&lt;h3 id=&#34;地址译码器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#地址译码器&#34;&gt;#&lt;/a&gt; 地址译码器&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/3c2a88fbaecab06ded46108ecd2546e7.png&#34; alt=&#34;3c2a88fbaecab06ded46108ecd2546e7.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;如何寻址：行访问，列访问&lt;/p&gt;
&lt;h2 id=&#34;刷新&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#刷新&#34;&gt;#&lt;/a&gt; 刷新&lt;/h2&gt;
&lt;p&gt;约束：刷新会占用&lt;strong&gt;片选线、地址线、地址译码器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;集中式刷新&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;停止&lt;/strong&gt;读写操作，并&lt;strong&gt;逐行刷新&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;刷新时&lt;strong&gt;无法操作内存&lt;/strong&gt;（死区）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分散式刷新&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在每个存储周期中，当&lt;strong&gt;读写操作完成时&lt;/strong&gt;进行刷新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一次读写刷新一行，&lt;strong&gt;逐行刷新&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会&lt;strong&gt;增加&lt;/strong&gt;每个存储周期的时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;异步刷新&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每一行各自以&lt;strong&gt;固定间隔&lt;/strong&gt;（小于最大刷新周期，毫秒级）刷新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 DRAM 的刷新安排在&lt;strong&gt; CPU 对指令的译码阶段&lt;/strong&gt;，可有效避免死区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;效率高&lt;/strong&gt;：常用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dram架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dram架构&#34;&gt;#&lt;/a&gt; DRAM 架构&lt;/h2&gt;
&lt;p&gt;传统 DRAM 是&lt;strong&gt;异步&lt;/strong&gt;的。频率通常&lt;strong&gt;不超过 66MHz&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高级 DRAM 架构是&lt;strong&gt;同步&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;同步 DRAM（Synchronous DRAM, &lt;strong&gt;SDRAM&lt;/strong&gt;）：频率通常&lt;strong&gt;不超过 133MHz&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;双速率 SDRAM（Double-Data-Rate SDRAM，&lt;strong&gt;DDR SDRAM / DDR&lt;/strong&gt;）：&lt;/p&gt;
&lt;p&gt;DDR5 频率&lt;strong&gt;可达 4800MHz&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;ddr-sdram&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ddr-sdram&#34;&gt;#&lt;/a&gt; DDR SDRAM&lt;/h3&gt;
&lt;p&gt;实际上也是动态 RAM 的一种吧。&lt;/p&gt;
&lt;p&gt;Double Data Rate：每个时钟周期&lt;strong&gt;发送两次数据&lt;/strong&gt;，一次在时钟脉冲的上升沿，一次在下降沿&lt;/p&gt;
&lt;h2 id=&#34;从位元到主存&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#从位元到主存&#34;&gt;#&lt;/a&gt; 从位元到主存&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;位元→寻址单元→存储阵列→芯片→模块组织→主存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/64ebd2f1b6d941ae7106e2837ddffef8.png&#34; alt=&#34;64ebd2f1b6d941ae7106e2837ddffef8.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/COA/2b24ac4c2a179776d358d2aeb9944cc8.png&#34; alt=&#34;2b24ac4c2a179776d358d2aeb9944cc8.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块组织&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;位扩展&lt;/strong&gt;：地址线不变，&lt;strong&gt;数据线增加&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 8 块 4K×1 bit 的芯片组成 4K×&lt;strong&gt;8&lt;/strong&gt; bit 的存储器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即一个单元内存储数增加了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字扩展&lt;/strong&gt;：&lt;strong&gt;地址线增加&lt;/strong&gt;，数据线不变&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 4 个 16K×8 bit 的芯片组成 &lt;strong&gt;64K&lt;/strong&gt;×8 bit 的存储器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即增加了单元数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字、位同时扩展&lt;/strong&gt;：地址线增加，数据线增加&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 8 个 16K×4 bit 的芯片组成 64K×8 bit 的存储器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/CN12/</guid>
            <title>计网 名词解释整理</title>
            <link>https://erinwithbmq.github.io/2025/01/11/CN12/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="互联网计算" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 19:01:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note danger&#34;&gt;
&lt;p&gt;&lt;strong&gt;注意，也可能不全！！！！！！&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;1 为闲着无聊统计考过的次数，数据不全，比如刚考的就没加进去。&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id=&#34;第一章&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第一章&#34;&gt;#&lt;/a&gt; 第一章&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LAN&lt;/strong&gt;（Local Area Networks）局域网&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;WAN&lt;/strong&gt;（Wide Area Networks）广域网&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ISP，Internet Service Providers&lt;/strong&gt;：互联网服务提供商 11&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ISO，International Organization for Standardization，国际标准化组织&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;OSI（开放系统互联参考模型，Open Systems Interconnection Model）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是由国际标准化组织（ISO）于 1984 年发布的一个标准化网络通信模型。OSI 模型将网络通信分为七个层次：......1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TCP/IP&lt;/strong&gt;（传输控制协议 / 互联网协议模型），包含四个层次：....&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通信方式的三种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单工通信（&lt;strong&gt;Simplex&lt;/strong&gt;）：数据只能在一个方向上传输，无法实现双向通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;半双工通信（&lt;strong&gt;Half-Duplex&lt;/strong&gt;）：数据可以在两个方向上传输，但在某一时刻只能在一个方向上传输。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全双工通信（&lt;strong&gt;Full-Duplex&lt;/strong&gt;）：数据可以在两个方向同时传输，发送和接收可以同时进行。&lt;strong&gt;11&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PDU（Protocol Data Unit）协议数据单元&lt;/strong&gt;：协议数据单元，是指在分层网络结构，例如在开放式系统互联（OSI）模型中，在传输系统的每一层都将建立协议数据单元（PDU）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;物理层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#物理层&#34;&gt;#&lt;/a&gt; 物理层&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无屏蔽双绞线（Unshielded Twisted Pair，UTP）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;易于安装且成本较低，线薄接口小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;直通线 Straight Cable&lt;/strong&gt;：连接不同类型的设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;反转线 Rollover Cable&lt;/strong&gt;：配置路由器 / 交换机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;交叉线 Crossover Cable&lt;/strong&gt;：连接相同的设备&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有屏蔽双绞线 STP&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同轴电缆 Coaxial Cable&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Collision Domains 冲突域&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指在同一个网络环境中，多个设备在同一时间发送数据时，可能会发生 &lt;strong&gt;数据冲突&lt;/strong&gt;（Collision）的区域&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Broadcast Domain 广播域&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指在一个局域网内，通过 &lt;strong&gt;广播&lt;/strong&gt;（Broadcast）方式发送的数据包可以被所有设备接收到的区域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;code 码元&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在使用&lt;strong&gt;时间域&lt;/strong&gt;的波形表示数字信号时，代表不同离散数值的基本波形&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NRZ&lt;/strong&gt; 不归零编码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RZ&lt;/strong&gt; 归零编码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;时分复用 TDM（ Time Division Multiplexing）111111&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时分复用（Time Division Multiplexing，TDM）是将时间划分为一段段等长的时分复用（TDM）帧， 每个时分复用的用户在每个 TDM 帧中占用固定序号的时隙。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STDM： 统计时分复用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;频分复用 FDM（ Frequency Division Multiplexing）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;波分复用 WDM（ Wavelength Division Multiplexing）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就是&lt;strong&gt;光的频分复用&lt;/strong&gt;：频率和波长是成倒数关系的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;码分复用 CDM（Code Division Multiplexing）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常用的名词是&lt;strong&gt;码分多址 CDMA (Code Division Multiple Access)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各用户使用经过特殊挑选的不同码型，彼此不会造成干扰。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;数据链路层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数据链路层&#34;&gt;#&lt;/a&gt; 数据链路层&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MAC&lt;/strong&gt; &lt;strong&gt;Media Access Control 介质访问控制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;介质访问控制&lt;/strong&gt;是计算机网络中 &lt;strong&gt;数据链路层&lt;/strong&gt; 的一个子层，专门负责管理多个设备如何共享通信介质。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LLC Logical Link Control 逻辑链路控制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;逻辑链路控制&lt;/strong&gt;是 &lt;strong&gt;数据链路层（Data Link Layer）&lt;/strong&gt; 的一部分，用于提供 &lt;strong&gt;数据链路层服务&lt;/strong&gt;，并在不同类型的网络协议之间提供统一的接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CSMA/CD&lt;/strong&gt; &lt;strong&gt;Carrier Sense Multiple Access with Collision Detection）带冲突检测的载波侦听多路访问 11111&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配器边发送数据边检&lt;strong&gt;测信道上的信号电压的变化情况&lt;/strong&gt;，以便判断⾃⼰在发送数据时&lt;strong&gt;其他站是否也在发送数据。&lt;strong&gt;若&lt;/strong&gt;发现碰撞&lt;/strong&gt;，⽴即&lt;strong&gt;停⽌发送&lt;/strong&gt;，按退避算法&lt;strong&gt;等待⼀段随机时间&lt;/strong&gt;后再次发送。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CSMA/CA (Carrier Sense Multiple Access with Collision Avoidance) 避免冲突的载波侦听多路访问 1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送站点&lt;strong&gt;在发送数据前&lt;/strong&gt;，以控制短帧刺激接收站点&lt;strong&gt;发送应答短帧&lt;/strong&gt;，使接收站点周围的站点&lt;strong&gt;监听到该帧&lt;/strong&gt;，从而在一定时间内&lt;strong&gt;避免数据发送&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NIC&lt;/strong&gt; &lt;strong&gt;Network Interface Controller 网卡&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;网络层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#网络层&#34;&gt;#&lt;/a&gt; 网络层&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ARP Address Resolution Protocol 地址解析协议 11&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使计算机能够查找与 IP 地址关联的计算机的 MAC 地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RARP（Reverse Address Resolution Protocol，反向地址解析协议）11111&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将&lt;strong&gt; MAC 地址&lt;/strong&gt;解析为对应的&lt;strong&gt; IP 地址&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IGP （Interior Gateway Protocols）内部网关协议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在自治系统中使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;又分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;距离矢量协议 DVP（Distance-Vector Protocols）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;strong&gt;邻居&lt;/strong&gt;的角度查看网络拓扑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;链路状态协议 LSP（Link State Protocols）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取整个网络拓扑的通用视图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;EGP（Exterior Gateway Protocols）外部网关协议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于在自治系统之间路由数据包。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RIP（Routing Information Protocol）路由信息协议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于距离矢量的内部网关协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IGRP（Interior Gateway Routing Protocol）内部网关路由协议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于距离矢量的内部网关协议。**EIGRP（Enhanced IGRP）** 是它的升级版。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;OSPF（Open Shortest Path First）最短路径优先协议 1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于链路状态的内部网关协议，消耗 CPU 和内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;VLSM&lt;/strong&gt; &lt;strong&gt;Variable Length Subnet Mask 可变长度子网掩码 1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许单个自治系统的网络具有不同的子网掩码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CIDR Classless InterDomain Routing 无类域间路由 11&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种用于 IP 地址分配和路由的机制。核心特点是无类别，采用斜杠表示法，可以聚合路由。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ICMP（Internet Control Message Protocol）因特网控制报文协议 111111&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了提高 IP 数据报交付成功的机会（消息管理和协商），允许主机或路由器&lt;strong&gt;报告差错情况和提供有关异常情况的报告&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PING&lt;/strong&gt;（Packet InterNet Groper）数据包因特网探索器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用来测试两个主机之间的连通性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IGMP&lt;/strong&gt;（Internet Group Management Protocol）互联网组管理协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;专门用于 &lt;strong&gt;IPv4 网络&lt;/strong&gt; 中的组播（Multicast）通信管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;传输层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#传输层&#34;&gt;#&lt;/a&gt; 传输层&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TCP（Transmission Control Protocol）传输控制协议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是一种&lt;strong&gt;面向连接的&lt;/strong&gt;、&lt;strong&gt;可靠的&lt;/strong&gt;传输协议，适用于需要确保数据正确性和顺序的通信场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UDP（User Datagram Protocol）用户数据报协议 1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UDP 是一种&lt;strong&gt;无连接的&lt;/strong&gt;、&lt;strong&gt;快速的&lt;/strong&gt;传输协议，适用于对速度要求高而对可靠性要求低的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Socket 套接字&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是网络通信的一个抽象概念，它是应用层和传输层之间的接口，用于实现网络数据通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NAT（Network Address Translation）网络地址转换 1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 IP 数据包头中将一个地址交换为另一个地址，是网络地址即将用完的解决方案之一&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PAT（端口地址转换，Port address translation）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;应用层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#应用层&#34;&gt;#&lt;/a&gt; 应用层&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;URL（Uniform Resource Locator）统一资源定位符 1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种标准化的资源标识方法，用于定位互联网上的资源（如网页、文件、图片等）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP（HyperText Transfer Protocol，超文本传输协议）111&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种&lt;strong&gt;应用层协议&lt;/strong&gt;，用于在客户端和服务器之间传输超文本（如 HTML 文档）、图片、视频等资源。TCP，80&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTML（HyperText Markup Language，超文本标记语言）11&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于创建和设计网页的标记语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FTP （File Transfer Protocol）文件传输协议 11&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种可靠的，&lt;strong&gt;面向连接&lt;/strong&gt;的传输文件协议，使用 TCP，20/21&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TFTP （Trivial File Transfer Protocol）简单文件传输协议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种简单的文件传输协议，使用 UDP， 69&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）11&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一种用于电子邮件&lt;strong&gt;发送&lt;/strong&gt;的协议，邮件发送，登录发送等操作。TCP，25&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;POP3（Post Office Protocol version 3，邮局协议版本 3）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一种用于&lt;strong&gt;接收邮件&lt;/strong&gt;的协议. TCP，110&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一种互联网标准，用于扩展电子邮件协议，使其能够支持文本之外的多种类型的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SNMP（Simple Network Management Protocol，简单网络管理协议）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一种应用程序层协议，可简化网络设备之间的管理信息交换。UDP, 161/162&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DNS（Domain Name System）域名系统 1111&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是网络上的服务，该服务管理域名并响应客户端将域名转换为关联 IP 地址的请求。UDP，53&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DHCP（Dynamic Host Configuration Protocol）动态主机配置协议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一种网络管理协议，用于自动分配 IP 地址和其他网络参数（如子网掩码、默认网关、DNS 服务器）给网络中的设备。UDP, 67/68&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Telnet 协议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于远程连接主机。TCP, 23&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;路由器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路由器&#34;&gt;#&lt;/a&gt; 路由器&lt;/h1&gt;
&lt;p&gt;解决路由环路问题的四个办法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路由中毒（Route Poisoning）1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由中毒，信息在路由表中失效的时候，把该表项的的度量值（metric）设为无穷大 16。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;水平分隔（Split Horizon）11&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从某个端口收到的报文信息，不能再从该端口发送回去&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义最大值（Maximum）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置最大跳数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计时器（Hold-Down Timers）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标记为不可达时启动一个计时器，若在计时期间收到新的、更优的路径信息，会更新；否则，计时结束还没有新的有效路径信息，则删除该条目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;路由协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路由协议&#34;&gt;#&lt;/a&gt; 路由协议&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;指定路由器（Designated Router，DR）&lt;/strong&gt;：只有在&lt;strong&gt;多路复用&lt;/strong&gt;的链路下使用，被选举出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;备用指定路由器（Backup Designated Router，BDR）&lt;/strong&gt;：如果 DR 坏了，再次选举会出现问题，如果 DR 损坏，BDR 立即成为 DR，目的是提高交换效率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ABR（Area Border Router）：区域边界路由器&lt;/strong&gt;，有一定的约束（一个路由器最多连接 3 个路由器）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TTL（Time To Live）被路由器丢弃之前允许通过的最大网段数量&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;局域网交换与-vlan&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#局域网交换与-vlan&#34;&gt;#&lt;/a&gt; 局域网交换与 VLAN&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对称交换（Symmetric Switching）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可在具有&lt;strong&gt;相同带宽&lt;/strong&gt;（10/10 Mbps 或 100/100 Mbps）的端口之间提供交换连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;非对称交换（Asymmetric Switching）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过将带有服务器的网段连接到更高带宽的端口（100 Mbps），减少了服务器上潜在瓶颈的可能性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交换机的交换方式：&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;储存转发（Store-and-Forward）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交换机&lt;strong&gt;接收整个帧&lt;/strong&gt;，最后校验其 CRC，然后再将其发送到目的地。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;直通（Cut-through）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分为两种。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fast forward switching 快速转发切换：&lt;strong&gt;仅在立即转发帧之前检查目标 MAC，即&lt;/strong&gt;只要看到帧的目的地址就转发，而不看帧的后面的部分&lt;/strong&gt;（Cut through 有的时候也直接指这个）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fragment Free 碎片释放：&lt;strong&gt;在转发帧之前&lt;/strong&gt;读取前 64 个字节&lt;/strong&gt;以减少错误：避免碰撞和帧碎片&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;生成树协议（STP, The Spanning-Tree Protocol）1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一种网络协议，用于以太网交换机环境中防止网络中的 &lt;strong&gt;环路&lt;/strong&gt; 问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;VLAN（Virtual Local Area Network）虚拟局域网&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种在局域网（LAN）中实现逻辑分段的技术，通过将一个物理网络划分为多个虚拟网络，实现对广播域的隔离。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;广域网&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#广域网&#34;&gt;#&lt;/a&gt; 广域网&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PPP（Point-to-Point Protocol）点对点协议 111111&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种数据链路层通信协议，主要用于在两点之间建立直接连接的链路。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CHAP（Challenge Handshake Authentication Protocol）挑战握手认证协议 111&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种网络认证协议，常用于点对点协议（PPP）连接中，用于验证远程客户端的身份。三次握手，避免了密码的明文传输，更安全&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ISDN（Integrated Services Digital Networks）综合数字服务网络&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许通过现有电话线传输数字信号，提供远程站点的连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ADSL（Asymmetric Digital Subscriber Line）非对称数字用户线路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种宽带接入技术，通过普通电话线（铜线）提供高速互联网接入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SONET（Synchronous Optical Network）同步光纤网&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种高性能的光纤通信标准&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;网络安全&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#网络安全&#34;&gt;#&lt;/a&gt; 网络安全&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ACL（Access Control Lists）访问控制列表&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是指令列表，它告诉&lt;strong&gt;路由器&lt;/strong&gt;允许或拒绝什么类型的数据包。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;其他需要背的：&lt;/p&gt;
&lt;p&gt;编码方式&lt;/p&gt;
&lt;p&gt;TCP 三次握手四次挥手&lt;/p&gt;
&lt;p&gt;端口号&lt;/p&gt;
&lt;p&gt;UDP 首部&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;注：以下都有例外，仅为参考&lt;/p&gt;
&lt;p&gt;P：基本都是 Protocol&lt;/p&gt;
&lt;p&gt;A：Access 或者 Address&lt;/p&gt;
&lt;p&gt;I：Inter+xxx&lt;/p&gt;
&lt;p&gt;C：基本都是 Control&lt;/p&gt;
&lt;p&gt;T：大部分都是和 Transfer，Transmission，Translation 有关的&lt;/p&gt;
&lt;p&gt;N：大部分都是 Network&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;2023 级考的名词解释是 DHCP CSMA/CD VLSM OSPF UDP PDU URL SMTP&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/CN11/</guid>
            <title>计网第十一章 网络安全</title>
            <link>https://erinwithbmq.github.io/2025/01/11/CN11/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="互联网计算" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 18:56:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;互联网计算系列整理主要内容来自软院 2020 级学长&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=&#34;&gt; EagleBear2002 的博客&lt;/span&gt;，为博主本人阅读后提炼整理的内容。&lt;br /&gt;
内容不算全面，仅推荐大家复习时参考。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;数据加密标准 DES Data Encryption Standard&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据加密标准 DES 属于常规密钥密码体制，是一种分组密码（对称加密算法）&lt;/p&gt;
&lt;h1 id=&#34;acl&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#acl&#34;&gt;#&lt;/a&gt; ACL&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;访问控制列表 ACL（Access Control Lists）&lt;strong&gt;是指令列表，它告诉&lt;/strong&gt;路由器&lt;/strong&gt;允许或拒绝什么类型的数据包。&lt;/p&gt;
&lt;p&gt;可以根据以下情况允许或拒绝数据包：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;源地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目的地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上层的协议，比如 TCP 或 UDP 端口&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ACL 末尾有一个隐含的  &lt;code&gt;deny any&lt;/code&gt;  语句：如果数据包与 ACL 中的任何语句都不匹配，则将其&lt;strong&gt;丢弃&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;exampleacl-例子&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#exampleacl-例子&#34;&gt;#&lt;/a&gt; Example：ACL 例子&lt;/h3&gt;
&lt;p&gt;如果我们有如下所述的 ACL 列表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;Permit packets from 192.168.100.1 to pass
Permit packets from 192.168.100.2 to pass
Deny packets from 192.168.100.3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Packets from 192.168.100.1 will be forwarded&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Packets from 192.168.100.3 will be denied&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;But how does the router process the packets from 192.168.100.4? &lt;strong&gt;denied（默认被丢弃掉）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;出站标准-acl-流程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#出站标准-acl-流程&#34;&gt;#&lt;/a&gt; 出站标准 ACL 流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;收到 packet，确定路由表确认路由表看能够转发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以转发的话，进入 ACL 确认&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;如果当前端口没有 ACL 配置，则直接进行转发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前端口有 ACL 配置，开始匹配 source 地址（标准的 ACL，只能对原地址进行判断）&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;语句满足条件，&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;deny&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;premit&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语句不满足条件，看下一条，如果没有下一条，则&lt;strong&gt;默认 deny&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;标准 ACL 只能显示声明拒绝规则，而扩展 ACL 可以显式声明拒绝规则和允许规则。因此，标准 ACL 的拒绝规则应当尽量放在出口&lt;/p&gt;
&lt;p&gt;在全局配置模式下顺序编写 ACL 语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;Router(config)#access-list [access-list-number] &amp;#123;permit/deny&amp;#125; &amp;#123;test-conditions&amp;#125;
Lab-D(config)#access-list 1 deny 192.5.5.10 0.0.0.0 拒绝来自 192.5.5.10 的报文
Lab-D(config)#access-list 1 deny host 192.5.5.10 与上一行等价
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在接口配置模式下将 ACL 分组（Group）到一个或多个接口。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;Router(config-if)#&amp;#123;protocol&amp;#125; access-group access-list-number &amp;#123;in/out&amp;#125;
Lab-D(config-if)#ip access-group 1 out/in
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in：进入流量  out：发出流量&lt;/p&gt;
&lt;h3 id=&#34;access-list-number-参数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#access-list-number-参数&#34;&gt;#&lt;/a&gt; access-list-number 参数&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ACL Type&lt;/th&gt;
&lt;th&gt;ACL Number&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;IP Standard&lt;/td&gt;
&lt;td&gt;1 to 99&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IP Extended&lt;/td&gt;
&lt;td&gt;100 to 199&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;通配符掩码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#通配符掩码&#34;&gt;#&lt;/a&gt; 通配符掩码&lt;/h3&gt;
&lt;p&gt;编写通配符掩码（Wildcard Mask）以告知路由器地址中要匹配的位以及要忽略的位：&lt;strong&gt;0 位表示检查该位位置，1 表示忽略该位位置&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;例子&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#例子&#34;&gt;#&lt;/a&gt; 例子：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查 192.5.5.0 255.255.255.0 该网络上的所有主机&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Answer： 192.5.5.0 0.0.0.255（和 net mask 是取反的）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查 192.5.5.32 255.255.255.224 子网中的所有主机&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;192.5.5.32 0.0.0.31&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;any-命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#any-命令&#34;&gt;#&lt;/a&gt; any 命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;必须编写语句以允许其他人通过。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Lab-A（config）#access-list 1 permit any&lt;/code&gt;  ==  &lt;code&gt;Lab-A（config）#access-list 1 permit 0.0.0.0 255.255.255.255&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;主机名支持&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#主机名支持&#34;&gt;#&lt;/a&gt; 主机名支持&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Lab-A（config）#access-list 1 permit host 192.5.5.10（host 专指 192.5.5.10）&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;标准-acl-的配置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#标准-acl-的配置&#34;&gt;#&lt;/a&gt; 标准 ACL 的配置&lt;/h2&gt;
&lt;p&gt;标准 ACL 没有目标参数。因此，将标准 ACL 放置在尽可能靠近目标的位置。&lt;/p&gt;
&lt;h2 id=&#34;扩展-acl&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#扩展-acl&#34;&gt;#&lt;/a&gt; 扩展 ACL&lt;/h2&gt;
&lt;p&gt;扩展 ACL 的编号范围为 100-199&lt;/p&gt;
&lt;p&gt;扩展功能包括基于过滤流量的功能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;目的地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ip 协议的部分（更加细分）：您可以编写语句以仅拒绝 ICMP 等协议或 RIP 和 IGRP 之类的路由协议&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;指令语法更加丰富：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;Router(config)# access-list access-list-number &amp;#123;permit|deny&amp;#125; &amp;#123;protocol|protocol-keyword&amp;#125;&amp;#123;source source-wildcard&amp;#125; &amp;#123;destination destination-wildcard&amp;#125; [protocol-specific options] [log]
Lab-A(config)#access-list 101 deny tcp 192.5.5.0 0.0.0.255 210.93.105.0 0.0.0.255 eq telnet log
#举例
Router1(config)#access-list 100 deny ip host 201.201.201.4 host 205.205.205.2
Router1(config)#access-list 100 permit ip any any


Router(config-if)#&amp;#123;protocol&amp;#125; access-group
access-list-number &amp;#123;in/out&amp;#125;
Lab-A(config-if)#ip access-group 101 out
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;access-list-number&lt;/code&gt; ：choose from the range 100 to 199&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;#123;protocol | protocol-number&amp;#125;&lt;/code&gt; ：For the CCNA, you only need to know ip and tcp--many more are available，只用考虑 ip 和 tcp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;#123;source source-wildcard&amp;#125;&lt;/code&gt; ：same as in standard 和标准的相似。可以用 host 而不写 wild&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;#123;destination destination-wildcard&amp;#125;&lt;/code&gt; ：formatted like the standard, but specifies the destination。可以用 host 而不写 wild&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[protocol-specific options]&lt;/code&gt; ：这个参数用于确认协议的过滤部分，可选&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如：拒绝网络 221.23.123.0 访问服务器 198.150.13.34&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;Router-C(config)#access-list 100 deny ip 221.23.123.0 0.0.0.255 198.150.13.34 0.0.0.0
Router-C(config)#access-list 100 permit ip any any
Router-C(config)#int e0
Router-C(config-if)#ip access-group 100 in
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;acl-的校验&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#acl-的校验&#34;&gt;#&lt;/a&gt; ACL 的校验&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;show access-lists&lt;/code&gt;  查看全部&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shows all access-lists configured on the router&lt;/code&gt;  显示路由器上配置的所有访问列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;show access-lists &amp;#123;name | number&amp;#125;&lt;/code&gt;  查看某一个端口的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/CN10/</guid>
            <title>计网第十章 广域网</title>
            <link>https://erinwithbmq.github.io/2025/01/11/CN10/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="互联网计算" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 18:53:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;互联网计算系列整理主要内容来自软院 2020 级学长&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=&#34;&gt; EagleBear2002 的博客&lt;/span&gt;，为博主本人阅读后提炼整理的内容。&lt;br /&gt;
内容不算全面，仅推荐大家复习时参考。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;WAN 在 OSI 的前三层运行，但&lt;strong&gt;主要集中在物理层和数据链路层&lt;/strong&gt;。广域网和局域网相比相对低效。&lt;/p&gt;
&lt;h1 id=&#34;ppp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ppp&#34;&gt;#&lt;/a&gt; PPP&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;点对点协议（PPP，Point-to-Point Protocol）&lt;/strong&gt;：PPP 包含用于识别网络层协议的协议字段（包含一个协议单元，指定网络协议），根据不同的网络协议对帧做控制与检查。&lt;/p&gt;
&lt;p&gt;串行链路上使用最广泛的&lt;strong&gt;第二层协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PPP 提供以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;网络协议多路复用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态分配 IP 地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证：PAP，CHAP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;压缩&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;错误检测&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;pap-安全认证协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#pap-安全认证协议&#34;&gt;#&lt;/a&gt; PAP 安全认证协议&lt;/h2&gt;
&lt;p&gt;PPP 中一个可选择的方法&lt;/p&gt;
&lt;p&gt;PAP 由一方向另一方发起请求，另一方选择是否接受，双方具有相同的用户名和密码，发起方可以多次尝试&lt;/p&gt;
&lt;h2 id=&#34;chap&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#chap&#34;&gt;#&lt;/a&gt; CHAP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;挑战握手认证协议（Challenge Handshake Authentication Protocol，CHAP）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;避免明文发送，三阶段握手，发起方是 HQ，找一个时间来 Challenge，然后由用户进行 response，之后决定是否接受。密码密文发送比较安全，而且更加合理的设计。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN10/image.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;HQ 定期向用户发起 Challenge，是一个随机数&lt;/p&gt;
&lt;p&gt;用户获得随机数，将数字、用户名、密码通过特定加密算法加密后返回给 HQ&lt;/p&gt;
&lt;p&gt;HQ 将结果与自己的值检查响应，匹配则验证成功。&lt;/p&gt;
&lt;h1 id=&#34;isdn&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#isdn&#34;&gt;#&lt;/a&gt; ISDN&lt;/h1&gt;
&lt;p&gt;** 综合数字服务网络（ISDN，Integrated Services Digital Networks）** 允许通过现有电话线传输数字信号：提供远程站点的连接&lt;/p&gt;
&lt;p&gt;ISDN 服务有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;BRI（基本速率接口，Basic Rate Interface），用户虚拟电路数据传，HDLC，PPP，两个 B 通道 + 一个 D 通道&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PRI（主速率接口，Primary Rate Interface），发送控制信息，LAPD&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;B 通道&lt;/strong&gt;：用于承载用户数据，每个通道的带宽为 &lt;strong&gt;64 Kbps&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;D 通道&lt;/strong&gt;：用于信令和控制，带宽为 &lt;strong&gt;16 Kbps&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;adsl&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#adsl&#34;&gt;#&lt;/a&gt; ADSL&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;非对称数字用户线路（ADSL，Asymmetric Digital Subscriber Line）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ADSL 的极限传输距离与&lt;strong&gt;数据率&lt;/strong&gt;以及&lt;strong&gt;用户线的线径&lt;/strong&gt;都有很大的关系（用户线越细，信号传输时的衰减就越大），而所能得到的最高数据传输速率与实际的用户线上的&lt;strong&gt;信噪比&lt;/strong&gt;密切相关。ADSL 的 “非对称” 指的是其上行和下行带宽的不对称性，下行速度（从互联网到用户）通常远高于上行速度（从用户到互联网），适合用户以下载为主的使用需求。&lt;/p&gt;
&lt;h1 id=&#34;sonet&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#sonet&#34;&gt;#&lt;/a&gt; SONET&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;同步光纤网 SONET（Synchronous Optical Network）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步数字系列（Synchronous Digital Hierarchy，SDH）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SDH 的基本速率为 155.52 Mb/s&lt;/p&gt;
&lt;p&gt;SONET 第 1 级同步传送信号 STS-1（ Synchronous Transport Signal） 的传输速率为 51.84 Mb/s，第 3 级同步传送信号 STS-3 传输速率是 STS-1 的 3 倍，为 155.52 Mb/s， …，等等，依此类推。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/CN9/</guid>
            <title>计网第九章 局域网交换与 VLAN</title>
            <link>https://erinwithbmq.github.io/2025/01/11/CN9/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="互联网计算" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 18:50:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;互联网计算系列整理主要内容来自软院 2020 级学长&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=&#34;&gt; EagleBear2002 的博客&lt;/span&gt;，为博主本人阅读后提炼整理的内容。&lt;br /&gt;
内容不算全面，仅推荐大家复习时参考。&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id=&#34;交换机&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#交换机&#34;&gt;#&lt;/a&gt; 交换机&lt;/h1&gt;
&lt;p&gt;交换机是基于&lt;strong&gt;硬件&lt;/strong&gt;的。&lt;/p&gt;
&lt;h2 id=&#34;基本功能&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基本功能&#34;&gt;#&lt;/a&gt; 基本功能&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根据 MAC 地址建立和维护&lt;strong&gt;交换表&lt;/strong&gt;（类似于网桥表）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将帧切换出接口到目标&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;对称交换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#对称交换&#34;&gt;#&lt;/a&gt; 对称交换&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;对称交换（Symmetric Switching）&lt;strong&gt;可在具有&lt;/strong&gt;相同带宽&lt;/strong&gt;（10/10 Mbps 或 100/100 Mbps）的端口之间提供交换连接。&lt;/p&gt;
&lt;h2 id=&#34;非对称交换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#非对称交换&#34;&gt;#&lt;/a&gt; 非对称交换&lt;/h2&gt;
&lt;p&gt;** 非对称交换（Asymmetric Switching）** 通过将带有服务器的网段连接到更高带宽的端口（100 Mbps），减少了服务器上潜在瓶颈的可能性。&lt;/p&gt;
&lt;p&gt;非对称交换需要在交换器中进行&lt;strong&gt;内存缓冲&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;内存缓冲：&lt;strong&gt;交换机中存储目标和传输数据的内存区域&lt;/strong&gt;，直到可以将其切换出正确的端口为止。&lt;/p&gt;
&lt;h2 id=&#34;交换方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#交换方式&#34;&gt;#&lt;/a&gt; 交换方式&lt;/h2&gt;
&lt;h3 id=&#34;储存转发&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#储存转发&#34;&gt;#&lt;/a&gt; 储存转发&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;储存转发（Store-and-Forward）&lt;/strong&gt;：网桥、路由器等通过软件转发的设备使用。&lt;/p&gt;
&lt;p&gt;交换机&lt;strong&gt;接收整个帧&lt;/strong&gt;，最后校验其 CRC，然后再将其发送到目的地。&lt;/p&gt;
&lt;h3 id=&#34;直通&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#直通&#34;&gt;#&lt;/a&gt; 直通&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;直通（Cut-through）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述存储转发会增加延迟，通过使用直通切换方法可以&lt;strong&gt;减少延迟&lt;/strong&gt;。分为下面两种&lt;/p&gt;
&lt;p&gt;快速转发切换（Fast forward switching）：仅在立即转发帧之前检查目标 MAC，即&lt;strong&gt;只要看到帧的目的地址就转发，而不看帧的后面的部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;碎片释放（Fragment Free）：在转发帧之前&lt;strong&gt;读取前 64 个字节&lt;/strong&gt;以减少错误：避免碰撞和帧碎片&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN9/image.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;不同层的交换机&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#不同层的交换机&#34;&gt;#&lt;/a&gt; 不同层的交换机&lt;/h2&gt;
&lt;p&gt;一般用第二层。略&lt;/p&gt;
&lt;h1 id=&#34;生成树协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#生成树协议&#34;&gt;#&lt;/a&gt; 生成树协议&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;生成树协议（STP, The Spanning-Tree Protocol）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;往往是&lt;strong&gt;第二层交换机&lt;/strong&gt;的冗余导致的桥回路。&lt;/p&gt;
&lt;h2 id=&#34;生成树协议综述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#生成树协议综述&#34;&gt;#&lt;/a&gt; 生成树协议综述&lt;/h2&gt;
&lt;p&gt;生成树协议的元素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;主要功能：在&lt;strong&gt;交换机 / 桥接网络&lt;/strong&gt;中允许&lt;strong&gt;冗余路径&lt;/strong&gt;，而不会因环路的影响而引起延迟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STP 通过计算&lt;strong&gt;稳定的生成树&lt;/strong&gt;网络拓扑&lt;strong&gt;来防止环路&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;生成树帧&lt;/strong&gt;（称为桥协议数据单元，bridge protocol data unit，BPDU）用于确定生成树拓扑&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在正常情况下禁用一些端口来防止出现冗余。&lt;/p&gt;
&lt;h3 id=&#34;桥协议数据单元&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#桥协议数据单元&#34;&gt;#&lt;/a&gt; 桥协议数据单元&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BPDU&lt;/strong&gt; 是交换机之间的流量；它们不承载最终用户（end-user）流量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STP 建立一个称为&lt;strong&gt;根网桥的根节点&lt;/strong&gt;，生成的树源自根桥。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;网桥标识-bid&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#网桥标识-bid&#34;&gt;#&lt;/a&gt; 网桥标识 BID&lt;/h3&gt;
&lt;p&gt;网桥 ID（BID）：8 个字节（2 + 6）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;高阶子字段（2 个字节）：&lt;strong&gt;网桥优先级&lt;/strong&gt;，值域：0-65535（默认值：32,768），通常以十进制格式表示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低阶子字段（6 个字节）：分配给交换机的 &lt;strong&gt;MAC 地址&lt;/strong&gt;，以十六进制格式表示&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;路径代价&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路径代价&#34;&gt;#&lt;/a&gt; 路径代价&lt;/h3&gt;
&lt;p&gt;记住 g 口相连代价为 4，f 口相连代价为 19&lt;/p&gt;
&lt;h2 id=&#34;初始-stp-收敛&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#初始-stp-收敛&#34;&gt;#&lt;/a&gt; 初始 STP 收敛&lt;/h2&gt;
&lt;h3 id=&#34;根交换机决定&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#根交换机决定&#34;&gt;#&lt;/a&gt; 根交换机决定&lt;/h3&gt;
&lt;p&gt;具有最低 BID 的交换机成为根交换机&lt;/p&gt;
&lt;h3 id=&#34;选择根端口&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#选择根端口&#34;&gt;#&lt;/a&gt; 选择根端口&lt;/h3&gt;
&lt;p&gt;每个非根交换机都需要选择一个根端口。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;离根交换机的 cost 最低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若 cost 相同，则选择对端端口 ID（PID）最小的。（PID：优先级 + 端口号）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;选择指定端口&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#选择指定端口&#34;&gt;#&lt;/a&gt; 选择指定端口&lt;/h3&gt;
&lt;p&gt;每个网段都需要有一个指定端口。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根交换机的所有端口都是指定端口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根端口的对端肯定是指定端口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;端口到根交换机的 cost 最低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若 cost 相同，则选择本端交换机 BID 最小的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;vlan&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#vlan&#34;&gt;#&lt;/a&gt; VLAN&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;虚拟局域网（Virtual Local Area Network，VLAN）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;VLAN：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在第 2 层和第 3 层工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制网络广播&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;允许用户由网络管理员分配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供更严格的网络安全性&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;vlan-的结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#vlan-的结构&#34;&gt;#&lt;/a&gt; VLAN 的结构&lt;/h2&gt;
&lt;h3 id=&#34;骨干网-backbone&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#骨干网-backbone&#34;&gt;#&lt;/a&gt; 骨干网 BackBone&lt;/h3&gt;
&lt;h3 id=&#34;路由器的作用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路由器的作用&#34;&gt;#&lt;/a&gt; 路由器的作用&lt;/h3&gt;
&lt;p&gt;通过路由器，vlan1 向 vlan2 发送信息&lt;/p&gt;
&lt;p&gt;trunk 链路要用交叉线来连接&lt;/p&gt;
&lt;h2 id=&#34;vlan-的实现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#vlan-的实现&#34;&gt;#&lt;/a&gt; VLAN 的实现&lt;/h2&gt;
&lt;h3 id=&#34;静态-vlan&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#静态-vlan&#34;&gt;#&lt;/a&gt; 静态 VLAN&lt;/h3&gt;
&lt;p&gt;写死在交换机端口上&lt;/p&gt;
&lt;h3 id=&#34;动态-vlan&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#动态-vlan&#34;&gt;#&lt;/a&gt; 动态 VLAN&lt;/h3&gt;
&lt;p&gt;交换机通过 MAC 地址或者哪一个协议，指定是哪一个 VLAN。&lt;/p&gt;
&lt;h3 id=&#34;访问连接-access-links&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#访问连接-access-links&#34;&gt;#&lt;/a&gt; 访问连接 Access Links&lt;/h3&gt;
&lt;p&gt;访问连接是仅作为一个 VLAN 成员的交换机上的连接。&lt;/p&gt;
&lt;p&gt;此 VLAN 被称为端口的本机 VLAN，连接到端口的任何设备都完全不知道 VLAN 存在。&lt;/p&gt;
&lt;h3 id=&#34;主干链路-trunk-links&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#主干链路-trunk-links&#34;&gt;#&lt;/a&gt; 主干链路 Trunk Links&lt;/h3&gt;
&lt;p&gt;主干链路能够支持多个 VLAN&lt;/p&gt;
&lt;p&gt;主干链路通常用于将交换机连接到其他交换机或路由器。&lt;/p&gt;
&lt;p&gt;一般 Trunk 就是 BackBone。&lt;/p&gt;
&lt;h3 id=&#34;vlan-配置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#vlan-配置&#34;&gt;#&lt;/a&gt; VLAN 配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;Switch# vlan database
Switch(vlan)# vlan [vlanid]
Switch(vlan)# exit

Switch# show vlan [vlanid]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不也可以直接在 config 里配置 vlan 吗。&lt;/p&gt;
&lt;h2 id=&#34;在局域网之间的路由&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#在局域网之间的路由&#34;&gt;#&lt;/a&gt; 在局域网之间的路由&lt;/h2&gt;
&lt;p&gt;可以使用子接口，在路由器指定接口上划分多个接口。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN9/image%201.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN9/image%202.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN9/image%203.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果是 Trunk Link：应该使用交叉线，而不是直通线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是 Access Link：直通线&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;vlan-题目备注&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#vlan-题目备注&#34;&gt;#&lt;/a&gt; VLAN 题目备注&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;同一 VLAN 中的两台主机可以&lt;strong&gt;跨越多台交换机&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必须是第三层及以上的交换机才能用来构建 VLAN&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/CN8/</guid>
            <title>计网第八章 路由协议</title>
            <link>https://erinwithbmq.github.io/2025/01/11/CN8/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="互联网计算" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 18:45:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;互联网计算系列整理主要内容来自软院 2020 级学长&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=&#34;&gt; EagleBear2002 的博客&lt;/span&gt;，为博主本人阅读后提炼整理的内容。&lt;br /&gt;
内容不算全面，仅推荐大家复习时参考。&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id=&#34;rip&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rip&#34;&gt;#&lt;/a&gt; RIP&lt;/h1&gt;
&lt;p&gt;**RIP（Routing Information Protocol）** 是一种基于距离向量（Distance Vector）的动态路由协议。&lt;/p&gt;
&lt;h2 id=&#34;ripv1&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ripv1&#34;&gt;#&lt;/a&gt; RIPv1&lt;/h2&gt;
&lt;p&gt;距离向量协议。使用&lt;strong&gt;跳数&lt;/strong&gt;作为度量标准，最大跳数为&lt;strong&gt; 15&lt;/strong&gt;，达到 16 跳的报文自动抛弃。&lt;/p&gt;
&lt;p&gt;RIPv1 具有以下限制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;它不会在其更新中发送子网掩码信息：意味着必须用同样的子网掩码，不支持 VLSM 或无类域间路由（CIDR）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以 255.255.255.255 的广播形式发送更新：只能发给邻居，不能通过路由器转发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持身份验证&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rip-配置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rip-配置&#34;&gt;#&lt;/a&gt; RIP 配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;router rip # 选择 RIP 路由协议
network 1.0.0.0
network 2.0.0.0
凡是属于上面的网段的端口都运行 RIP 协议
这些网段必须做到直连该路由器
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ripv2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ripv2&#34;&gt;#&lt;/a&gt; RIPv2&lt;/h2&gt;
&lt;p&gt;新增了以下的功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这是一种使用&lt;strong&gt;跳数指标&lt;/strong&gt;的距离矢量协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它使用&lt;strong&gt;抑制计时器&lt;/strong&gt;来防止路由循环，默认值为&lt;strong&gt; 180 秒&lt;/strong&gt;，6 倍于交换时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它使用&lt;strong&gt;水平分割&lt;/strong&gt;（Split Horizon）来防止路由循环（Routing Loops）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它使用 16 跳作为&lt;strong&gt;无限距离的度量&lt;/strong&gt;。（15 跳及以内可达）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持子网掩码的信息传播，允许使用 VLSM 和 CIDR（无类域间路由）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路由更新通过多播地址（ &lt;code&gt;224.0.0.9&lt;/code&gt; ）发送，仅发送给支持 RIP 的设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持路由更新消息的认证&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;version 2&lt;/code&gt; ：表示启动 RIPv2，直接使用  &lt;code&gt;router rip&lt;/code&gt;  默认为 v1，一定要输入这个命令才能启动 RIPv2&lt;/p&gt;
&lt;h3 id=&#34;ripv1-和-ripv2-的对比&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ripv1-和-ripv2-的对比&#34;&gt;#&lt;/a&gt; &lt;strong&gt;RIPv1 和 RIPv2 的对比&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;RIPv1&lt;/th&gt;
&lt;th&gt;RIPv2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;子网掩码支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;更新方式&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;广播（255.255.255.255）&lt;/td&gt;
&lt;td&gt;多播（224.0.0.9）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;认证功能&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;路由环路避免&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;基本机制（分割视域等）&lt;/td&gt;
&lt;td&gt;增强机制（触发更新等）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;最大跳数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;小型简单网络&lt;/td&gt;
&lt;td&gt;小型或中型网络&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;验证与故障排除&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#验证与故障排除&#34;&gt;#&lt;/a&gt; 验证与故障排除&lt;/h3&gt;
&lt;p&gt;故障排除 RIPv2：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;Router#debug ip rip #显示更新路由表的时候的更新
Router#undebug all #（或 no debug all）：停止 debug
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;debug ip rip&lt;/code&gt;  命令显示 RIP 路由更新的发送和接收。&lt;/p&gt;
&lt;h1 id=&#34;ospf&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ospf&#34;&gt;#&lt;/a&gt; OSPF&lt;/h1&gt;
&lt;p&gt;** 开放最短路径优先（OSPF，Open Shortest Path First）** 是基于开放标准（即该标准可以再扩充）的链路状态路由协议。&lt;/p&gt;
&lt;p&gt;与 RIPv1 和 RIPv2 相比，OSPF 正在成为首选的 IGP 协议（内部网关协议），因为它具有可伸缩性。&lt;/p&gt;
&lt;h2 id=&#34;ospf-的核心特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ospf-的核心特点&#34;&gt;#&lt;/a&gt; &lt;strong&gt;OSPF 的核心特点&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;链路状态路由协议&lt;/strong&gt;&lt;br /&gt;
 OSPF 路由器通过生成 LSA（Link State Advertisement，链路状态通告）来共享自身的链路状态信息，最终构建出整个网络的拓扑图。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Dijkstra 算法&lt;/strong&gt;&lt;br /&gt;
 OSPF 使用 SPF（Shortest Path First）算法计算最短路径，基于拓扑数据库选择最优路由。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分层架构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;支持&lt;strong&gt;多区域&lt;/strong&gt;设计（Area），以减少路由表规模和 SPF 计算量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区域 0 是主干区域（Backbone Area），其他区域必须通过主干区域互联。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;快速收敛&lt;/strong&gt;&lt;br /&gt;
网络拓扑发生变化时，OSPF 能够快速更新路由，减少收敛时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持 VLSM 和 CIDR&lt;/strong&gt;&lt;br /&gt;
OSPF 可以传播子网掩码信息，支持灵活的 IP 地址分配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;认证机制&lt;/strong&gt;&lt;br /&gt;
支持明文和加密（MD5 或 SHA）认证，提供更高的安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多播传输&lt;/strong&gt;&lt;br /&gt;
 OSPF 使用多播地址  &lt;code&gt;224.0.0.5&lt;/code&gt; （所有 OSPF 路由器）和  &lt;code&gt;224.0.0.6&lt;/code&gt; （所有 DR/BDR 路由器）发送路由更新，减少广播风暴。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ospf-与-rip-差别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ospf-与-rip-差别&#34;&gt;#&lt;/a&gt; OSPF 与 RIP 差别&lt;/h2&gt;
&lt;p&gt;OSPF：用于大型网络，基于带宽，可以分层（将网络划分成 2 层），收敛更快，支持多路负载均衡&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN8/image.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;例如这张图，OSPF 走上（带宽大，计算出速度更快），RIP 走下（跳数更少）&lt;/p&gt;
&lt;h2 id=&#34;ospf-术语&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ospf-术语&#34;&gt;#&lt;/a&gt; OSPF 术语&lt;/h2&gt;
&lt;h3 id=&#34;link-连接&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#link-连接&#34;&gt;#&lt;/a&gt; Link 连接&lt;/h3&gt;
&lt;h3 id=&#34;link-state-链路状态&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#link-state-链路状态&#34;&gt;#&lt;/a&gt; Link-State 链路状态&lt;/h3&gt;
&lt;p&gt;邻居（Neighbors）：相邻的路由器&lt;/p&gt;
&lt;p&gt;物理链路的信息，包括路由器连接关系、通过什么接口、链路带宽、网络类型（点对点、多路复用）等，不同网络类型处理代价不同&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两种网络类型：点对点，多路复用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;点对点与多路复用的区别&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;点对点网络&lt;/th&gt;
&lt;th&gt;多路复用网络&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;通信范围&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;两个节点之间&lt;/td&gt;
&lt;td&gt;多个节点共享同一链路&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;拓扑复杂性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;简单&lt;/td&gt;
&lt;td&gt;较复杂&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;通信效率&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;高（独占带宽）&lt;/td&gt;
&lt;td&gt;可能因冲突或广播风暴受影响&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;点对点连接、链路少的场景&lt;/td&gt;
&lt;td&gt;局域网、大型网络&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;路由设计&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不需要复杂路由算法&lt;/td&gt;
&lt;td&gt;通常需要 DR 和 BDR 协调&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;cost-代价费用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#cost-代价费用&#34;&gt;#&lt;/a&gt; Cost 代价 / 费用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一般是固定值除以带宽&lt;/strong&gt;，与带宽成反比&lt;/p&gt;
&lt;h3 id=&#34;area-区域&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#area-区域&#34;&gt;#&lt;/a&gt; Area 区域&lt;/h3&gt;
&lt;p&gt;具有相同区域 ID 的网络 / 路由器集合 。区域内的每个路由器都有相同的链路状态信息。&lt;/p&gt;
&lt;p&gt;Area 是对&lt;strong&gt;端口&lt;/strong&gt;的划分，即一个路由器的不同端口可以属于不同 area。&lt;/p&gt;
&lt;p&gt;应该就是一个 Area 内互相传递 LSA？&lt;/p&gt;
&lt;h3 id=&#34;autonomous-systemas-自治系统&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#autonomous-systemas-自治系统&#34;&gt;#&lt;/a&gt; Autonomous System，AS 自治系统&lt;/h3&gt;
&lt;p&gt;多个 Area 形成一个自治系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Neighbours 必须在一个 Area 中，Neighbour 之间交换拓扑数据库（Topology Databases）当中存的是 link-state&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个 Area 中获得全部 Link-State 后计算 Tree，生成表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN8/image-20230716093615650.png&#34; alt=&#34;https://eaglebear2002.github.io/28848/image-20230716093615650.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;指定路由器（Designated Router，DR）&lt;/strong&gt;：只有在&lt;strong&gt;多路复用&lt;/strong&gt;的链路下使用，被选举出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;备用指定路由器（Backup Designated Router，BDR）&lt;/strong&gt;：如果 DR 坏了，再次选举会出现问题，如果 DR 损坏，BDR 立即成为 DR，目的是提高交换效率&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ospf-域&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ospf-域&#34;&gt;#&lt;/a&gt; OSPF 域&lt;/h3&gt;
&lt;p&gt;在多区域 OSPF 网络中，要求所有区域都连接到区域 0（主干）。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN8/image%201.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ABR（Area Border Router）：区域边界路由器&lt;/strong&gt;，有一定的约束（一个路由器最多连接 3 个路由器）。&lt;/p&gt;
&lt;p&gt;一个 Area 中不能有超过 50 台路由器，否则会导致 SPF 算法产生的计算量和内存过大。&lt;/p&gt;
&lt;h2 id=&#34;ospf-行为&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ospf-行为&#34;&gt;#&lt;/a&gt; OSPF 行为&lt;/h2&gt;
&lt;p&gt;OSPF &lt;strong&gt;操作&lt;/strong&gt;包括五个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;建立邻接关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择 DR 和 BDR（如果需要）：&lt;strong&gt;多路复用的时候才需要&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现路线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择适当的路线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;维护路线信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OSPF 具有七个&lt;strong&gt;状态&lt;/strong&gt;，它们是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始化（Init）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双向操作（2Way）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预先启动（Ex Start）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交换（Exchange）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加载（Loading）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完成（Full）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN8/image%202.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;dr-与-bdr&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dr-与-bdr&#34;&gt;#&lt;/a&gt; DR 与 BDR&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN8/image%203.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;OSPF 网络类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;广播多路复用网络，例如以太网&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点对点网络&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非广播多路复用网络（NBMA，Non-broadcast multi-access）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多路复用时要选举 DR/BDR，减少连接量与交流量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个路由器都会与 DR（指定路由器）和 BDR（备份指定路由器）建立邻接关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DR 使用 224.0.0.5 的多播地址（适用于所有 OSPF 路由器）向同一网络段中的所有其他路由器发送链路状态信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了确保 DR 和 BDR 能够接收到网络段上所有路由器发送的链路状态信息，使用 224.0.0.6 的多播地址（适用于所有 DR 和 BDR）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;224.0.0.5&lt;/strong&gt;：OSPF 所有路由器的多播地址，于让网络段上的所有 OSPF 路由器接收消息。&lt;br /&gt;
&lt;strong&gt;224.0.0.6&lt;/strong&gt;：专用于 DR 和 BDR 的多播地址，用于路由器发送消息给 DR 和 BDR。&lt;/p&gt;
&lt;h2 id=&#34;ospf-报文&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ospf-报文&#34;&gt;#&lt;/a&gt; OSPF 报文&lt;/h2&gt;
&lt;p&gt;只有 5 个类型的报文&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Fuction&lt;/th&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Hello&lt;/td&gt;
&lt;td&gt;Hello&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Database Description&lt;/td&gt;
&lt;td&gt;DBD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Link-State Request&lt;/td&gt;
&lt;td&gt;LSR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Link-State Update&lt;/td&gt;
&lt;td&gt;LSU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Link-State Acknowledgement&lt;/td&gt;
&lt;td&gt;LSAck&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;hello&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#hello&#34;&gt;#&lt;/a&gt; Hello&lt;/h3&gt;
&lt;p&gt;保持心跳，确定还活着。Hello 几乎是空报文，给所有跑 OSPF 的路由器发送。&lt;/p&gt;
&lt;p&gt;每 10 秒发送一次，数据包的地址为 224.0.0.5（多播）&lt;/p&gt;
&lt;p&gt;Hello 报文的 Type 字段设置为 1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TTL（Time To Live，被路由器丢弃之前允许通过的最大网段数量）&lt;/strong&gt; 是 1，所以不会跨路由器传播，收到即丢弃&lt;/p&gt;
&lt;h3 id=&#34;dr-选举&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dr-选举&#34;&gt;#&lt;/a&gt; DR 选举&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优先级&lt;/strong&gt;为第一关键字，&lt;strong&gt;Router ID&lt;/strong&gt; 为第二关键字，最大的是 DR，第二大的是 BDR。&lt;/p&gt;
&lt;p&gt;优先级为零表示 “从不 DR”&lt;/p&gt;
&lt;h2 id=&#34;ospf-操作&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ospf-操作&#34;&gt;#&lt;/a&gt; OSPF 操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;建立邻接关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择 DR 和 BDR（如果需要）：&lt;strong&gt;多路复用的时候才需要&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现路线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择适当的路线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;维护路线信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-建立路由器邻接&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1-建立路由器邻接&#34;&gt;#&lt;/a&gt; 1. 建立路由器邻接&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;路由器每隔一段时间发送一次 hello 数据包，Hello 报文的 TTL 是 1，表明不会跨路由传播&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果邻居被发现了：将邻居添加到邻居数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现网络类型&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;如果是&lt;strong&gt;多路复用网络&lt;/strong&gt;，进入 DR/BDR 选举过程，然后进入步骤 2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是点对点或点对多点网络，则不会举行 DR/BDR 选举过程，并跳过步骤 2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 hello 数据包标头中的 &lt;strong&gt;DR/BDR 字段已被占用&lt;/strong&gt;（即 DR/BDR 对&lt;strong&gt;已经存在&lt;/strong&gt;），则不会进行 DR/BDR 选举，并跳过步骤 2&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果对方的 DP/BDP 优于我的 DP/BDP，则接受对方的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-选举-dr-和-bdr&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2-选举-dr-和-bdr&#34;&gt;#&lt;/a&gt; 2. 选举 DR 和 BDR&lt;/h3&gt;
&lt;p&gt;按照选举规则进行选举。当 DR 无效时，BDR 成为新的 DR&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果新的 OSPF 路由器以更高的优先级或 Router ID 加入网络，则当前的 DR 和 BDR &lt;strong&gt;不会更改&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仅当当前 DR 失败时，它才成为新的 BDR&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-发现路线&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3-发现路线&#34;&gt;#&lt;/a&gt; 3. 发现路线&lt;/h3&gt;
&lt;p&gt;交换 LSA，直到同步链路状态数据库&lt;/p&gt;
&lt;h3 id=&#34;4-选择适当路线&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4-选择适当路线&#34;&gt;#&lt;/a&gt; 4. 选择适当路线&lt;/h3&gt;
&lt;p&gt;同步后，所有路由器进行 SPF 算法计算最短路径。&lt;/p&gt;
&lt;p&gt;OSPF 然后在路由表中安装成本最低的路径&lt;/p&gt;
&lt;h3 id=&#34;5-维护路由信息&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#5-维护路由信息&#34;&gt;#&lt;/a&gt; 5. 维护路由信息&lt;/h3&gt;
&lt;p&gt;Hello 交换还用来判断邻居有没有死掉。&lt;/p&gt;
&lt;p&gt;问候间隔一般是 10s，即每 10s 发送一次 Hello。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;广播多路访问和点对点链接，速度为 T1（1.544 Mbps） 或更高的链接：每 10 秒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非广播多路访问链接，小于 T1 的链接：每 30 秒&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;死亡间隔是问候间隔的四倍。以 10s 为例，如果 40s 后还没有回应，那么邻居死了（不可达）。&lt;/p&gt;
&lt;h3 id=&#34;链路状态变化出现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#链路状态变化出现&#34;&gt;#&lt;/a&gt; 链路状态变化出现&lt;/h3&gt;
&lt;p&gt;Router A tells all OSPF DRs on &lt;strong&gt;224.0.0.6&lt;/strong&gt;（组播地址），使用 &lt;strong&gt;LSU&lt;/strong&gt;（linkState update）&lt;/p&gt;
&lt;p&gt;DR tells others on &lt;strong&gt;224.0.0.5&lt;/strong&gt;，通过 &lt;strong&gt;LSU&lt;/strong&gt; 告知所有的路由器&lt;/p&gt;
&lt;h2 id=&#34;基本的-ospf-配置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基本的-ospf-配置&#34;&gt;#&lt;/a&gt; 基本的 OSPF 配置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在路由器上启动 OSPF&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Router（config）## router ospf process-id&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程号：process-id&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;取值： 1 ~ 65535&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在一台路由器上识别多个 OSPF 进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常在整个 AS（自治系统）中保持相同的进程 ID&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在路由器上识别 IP 网络&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Router（config-router） ## network address wildcardmask area area-id&lt;/code&gt;  &lt;strong&gt;wildcardmask 和 subnet mask 相反（如子网 255.255.255.0，那么 wild 就是 0.0.0.255）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络地址可以是整个网络，子网或接口的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若只有一个 Area，则为 area0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写 IP 和写网段最后都是一样的。（IP 地址是单个设备具体地址，网段地址是主机号全为 0，表示一个范围的地址）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN8/image%204.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置回路loop地址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#配置回路loop地址&#34;&gt;#&lt;/a&gt; 配置回路（Loop）地址&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;Router(config)#interface loopback number
Router(config-if)#ip address address subnet-mask
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;必须在 OSPF 进程开始之&lt;strong&gt;前&lt;/strong&gt;配置回环接口：会涉及到主从关系确定和 DR 的选举&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置环回地址时，请使用 &lt;strong&gt;/32&lt;/strong&gt; 掩码以避免潜在的路由问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I 建议您在基于 OSPF 的网络中的所有关键路由器上使用环回地址（专用或公用地址）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一旦配置立刻生效，不需要 no shutdown 的命令即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;修改-ospf-接口优先级&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#修改-ospf-接口优先级&#34;&gt;#&lt;/a&gt; 修改 OSPF 接口优先级&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Router（config-if） ## ip ospf priority number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;优先级：越大越高&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;值：0-255, 默认为 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优先级 0 表示接口不能被选为 DR 或 BDR&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;查看 OSPF 的端口的优先级： &lt;code&gt;Router ## show ip ospf [interface type number]&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;修改接口成本&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#修改接口成本&#34;&gt;#&lt;/a&gt; 修改接口成本&lt;/h3&gt;
&lt;p&gt;直接修改成本： &lt;code&gt;ip ospf cost number（1-65535）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置带宽： &lt;code&gt;bandwidth number（单位Kbps）&lt;/code&gt; 改变接口带宽（但是实际物理带宽不会改变）&lt;/p&gt;
&lt;p&gt;不是改变参考带宽！即改变除数。&lt;/p&gt;
&lt;h3 id=&#34;设置计时器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#设置计时器&#34;&gt;#&lt;/a&gt; 设置计时器&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-CSS&#34;&gt;Router(config-if)## ip ospf hello-interval seconds
Router(config-if)## ip ospf dead-interval seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改变问候间隔与死亡间隔&lt;/p&gt;
&lt;p&gt;若只改变问候间隔，则死亡间隔自动变为四倍。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/CN7/</guid>
            <title>计网第七章 路由与路由器</title>
            <link>https://erinwithbmq.github.io/2025/01/11/CN7/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="互联网计算" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 18:43:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;互联网计算系列整理主要内容来自软院 2020 级学长&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=&#34;&gt; EagleBear2002 的博客&lt;/span&gt;，为博主本人阅读后提炼整理的内容。&lt;br /&gt;
内容不算全面，仅推荐大家复习时参考。&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id=&#34;路由器基础&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路由器基础&#34;&gt;#&lt;/a&gt; 路由器基础&lt;/h1&gt;
&lt;h2 id=&#34;内部组件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#内部组件&#34;&gt;#&lt;/a&gt; 内部组件&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN7/image.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;ram-随机存取存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ram-随机存取存储器&#34;&gt;#&lt;/a&gt; RAM 随机存取存储器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;RAM（Random Access Memory，随机存取存储器）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;路由器配置文件的临时存储，一般做为内存使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;断电或重新启动时 RAM 内容丢失&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问很快&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;nvram-非易失随机存取存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nvram-非易失随机存取存储器&#34;&gt;#&lt;/a&gt; NVRAM 非易失随机存取存储器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;NVRAM（Non-volatile RAM）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储备份（backup）/ 启动（startup）配置文件&lt;/p&gt;
&lt;p&gt;路由器掉电或重启时内容不会丢失。&lt;/p&gt;
&lt;p&gt;保证快速访问，但是存储空间有限。&lt;/p&gt;
&lt;h3 id=&#34;flash&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#flash&#34;&gt;#&lt;/a&gt; Flash&lt;/h3&gt;
&lt;p&gt;存储了 Cisco IOS（互联网操作系统），可以存储多个版本的 IOS&lt;/p&gt;
&lt;p&gt;相当于台式机硬盘&lt;/p&gt;
&lt;p&gt;断电保持&lt;/p&gt;
&lt;h3 id=&#34;rom-只读存储器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#rom-只读存储器&#34;&gt;#&lt;/a&gt; ROM 只读存储器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ROM，Read-Only Memory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包含 POST（开机自检）&lt;/p&gt;
&lt;p&gt;引导程序（加载 Cisco IOS）&lt;/p&gt;
&lt;p&gt;作系统软件。有 IOS 的备份&lt;/p&gt;
&lt;h2 id=&#34;接口-interface&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#接口-interface&#34;&gt;#&lt;/a&gt; 接口 Interface&lt;/h2&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h1 id=&#34;路由器启动步骤&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路由器启动步骤&#34;&gt;#&lt;/a&gt; 路由器启动步骤&lt;/h1&gt;
&lt;h2 id=&#34;系统启动程序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#系统启动程序&#34;&gt;#&lt;/a&gt; 系统启动程序&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;执行开机自检 POST&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证 CPU、内存和网络接口的基本操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件初始化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;软件启动程序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#软件启动程序&#34;&gt;#&lt;/a&gt; 软件启动程序&lt;/h2&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;p&gt;如果 NVRAM 中&lt;strong&gt;没有&lt;/strong&gt;有效的配置文件，则执行问题驱动（question-driven）的初始配置例程，该例程称为系统配置对话框，也称为&lt;strong&gt;设置模式 setup mode&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;路由器初始化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路由器初始化&#34;&gt;#&lt;/a&gt; 路由器初始化&lt;/h2&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h2 id=&#34;路由器-cli-指令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路由器-cli-指令&#34;&gt;#&lt;/a&gt; 路由器 CLI 指令&lt;/h2&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN7/image%201.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN7/image%202.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检验基本的路由配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 show running-config 命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储路由器基本配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;copy running-config&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;startup-config&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他检验路由器的命令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Show running-config – 显示当前随机访问存储器中的配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Show startup-config – 显示 NVRAM 中的配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Show IP route – 现实路由表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Show interfaces – 显示所有接口的配置信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Show IP int brief - 显示接口的简要信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;路由和配置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路由和配置&#34;&gt;#&lt;/a&gt; 路由和配置&lt;/h1&gt;
&lt;p&gt;收敛时间 Convergence Time：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从刚启动到网络达到稳定的时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从发生变化到再次稳定的时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;使用网络寻址进行路由&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用网络寻址进行路由&#34;&gt;#&lt;/a&gt; 使用网络寻址进行路由&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;路由器通常使用两个基本功能（路径确定功能和交换功能）将数据包从一条数据链路中继（relay）到另一条数据链路。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;交换功能（switching function）&lt;strong&gt;允许路由器在一个接口上&lt;/strong&gt;接受数据包&lt;/strong&gt;并&lt;strong&gt;通过第二个接口转发。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路径确定（path determination）&lt;strong&gt;功能使路由器能够选择&lt;/strong&gt;最合适的接口&lt;/strong&gt;来&lt;strong&gt;转发数据包&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路由器使用地址的&lt;strong&gt;网络部分&lt;/strong&gt;进行路径选择，以将数据包传递到下一个路由器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址的 ** 节点部分（主机部分）** 由直接连接到目标网络的路由器使用，以将数据包传递到正确的主机。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路由器如何使用网络部分和节点部分&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;网络部分&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;路由器使用网络部分决定数据包下一跳的路径。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如，路由器看到目标 IP 是  &lt;code&gt;192.168.2.10&lt;/code&gt; ，而根据路由表知道  &lt;code&gt;192.168.2.0/24&lt;/code&gt;  应该转发到接口  &lt;code&gt;GigabitEthernet0/1&lt;/code&gt; ，因此数据包被发送到该接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;节点部分&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当数据包到达目标网络（如  &lt;code&gt;192.168.2.0/24&lt;/code&gt; ）时，目标路由器使用节点部分（如  &lt;code&gt;10&lt;/code&gt; ）确定具体设备。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这一阶段通常由 ARP 协议解析 MAC 地址，并通过交换机转发到目标主机。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;静态和动态路由&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#静态和动态路由&#34;&gt;#&lt;/a&gt; 静态和动态路由&lt;/h2&gt;
&lt;h3 id=&#34;静态路由&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#静态路由&#34;&gt;#&lt;/a&gt; 静态路由&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN7/image%203.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;目的地址 network：后面需要包含掩码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下一条地址 address：确定下一跳地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Distance：管理距离（可选项。不写的话，默认为 1）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ip route 172.16.3.0 255.255.255.0 192.168.2.4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个命令定义了一条从当前路由器到 &lt;strong&gt;172.16.3.0/24&lt;/strong&gt; 网络的静态路由，具体通过下一跳地址 &lt;strong&gt;192.168.2.4&lt;/strong&gt; 转发数据包。&lt;/p&gt;
&lt;p&gt;即如果收到目的地址为 172.16.3.0/24 **** 的报文，将其转发给 192.168.2.4&lt;/p&gt;
&lt;h4 id=&#34;管理距离&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#管理距离&#34;&gt;#&lt;/a&gt; 管理距离&lt;/h4&gt;
&lt;p&gt;** 管理距离（administrative distance，AD）** 是路由信息源的可信赖性的等级，表示为从 0 到 255 的数值。&lt;/p&gt;
&lt;p&gt;静态路由的管理距离通常很短（默认值为 1）&lt;/p&gt;
&lt;p&gt;数值越低，可信度越高。AD 为 1 时其优先级非常高，仅次于直连网段 AD=0&lt;/p&gt;
&lt;h2 id=&#34;动态路由&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#动态路由&#34;&gt;#&lt;/a&gt; 动态路由&lt;/h2&gt;
&lt;p&gt;动态路由取决于两个基本路由器功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;维护（maintance）路由表（动态维持的）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向其他路由器分发（distribution）路由信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;动态路由协议分类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#动态路由协议分类&#34;&gt;#&lt;/a&gt; 动态路由协议分类&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;大致分为以下三类：&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;距离矢量（DV,Distance Vector）DVP Protocol&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链路状态（LS,Link State）LSP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;混合路由（HR,Hybird Routing）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中 Hybrid Routing 是在两种之间&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dvp-距离矢量协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dvp-距离矢量协议&#34;&gt;#&lt;/a&gt; DVP 距离矢量协议&lt;/h3&gt;
&lt;p&gt;路由器不知道整个网路的具体拓扑&lt;/p&gt;
&lt;p&gt;基于距离矢量的路由算法（也称为 &lt;strong&gt;Bellman-Ford 算法&lt;/strong&gt;）在路由器之间传递路由表的周期性副本。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;大家交换 Routing Table&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只知道可达，但是不知道怎么可达（知道 where, 但是不知道 how），不知道整个网路的具体拓扑&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;路由环路问题-routing-loops&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路由环路问题-routing-loops&#34;&gt;#&lt;/a&gt; 路由环路问题 Routing Loops&lt;/h4&gt;
&lt;p&gt;路由环路会导致数据包在网络中不断循环，无法到达目的地，从而浪费网络资源和带宽，甚至引起网络崩溃。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义最大值（Maximum）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置最大跳数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路由中毒（Route Poisoning）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN7/image%204.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;当网络 5 发生故障时，路由器 E 通过将网络 5 的表条目设置为&lt;strong&gt; 16（无穷大） 或不可访问&lt;/strong&gt;来启动路由中毒。（而不是删除条目）&lt;/p&gt;
&lt;p&gt;当路由器 C 从路由器 E 接收到路由中毒时，它会将更新（称为毒性逆转，poison reverse）发送回路由器 E。这确保网段上的所有路由器都已接收到中毒的路由信息。&lt;/p&gt;
&lt;p&gt;最终所有的路由器都知道不可达。&lt;/p&gt;
&lt;p&gt;一句话概括：路由毒害，由信息在路由表中失效的时候，把该表项的的度量值（metric）设为无穷大 16。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;水平分隔（Split Horizon）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从某个端口收到的报文信息，不能再从该端口发送回去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计时器（Hold-Down Timers）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启动计时器&lt;/strong&gt;：当目标网络被标记为 “不可达” 时，路由器会启动一个计时器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;等待更优路径&lt;/strong&gt;：在计时器运行期间，如果路由器收到新的、更优的路径信息，会更新记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;忽略更差路径&lt;/strong&gt;：如果收到的路径信息不如现有记录好，则忽略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;超时删除记录&lt;/strong&gt;：如果计时器倒计时结束且没有新的有效路径信息，路由器会删除该条目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;阻止发送路由更新&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#阻止发送路由更新&#34;&gt;#&lt;/a&gt; 阻止发送路由更新&lt;/h3&gt;
&lt;p&gt;防止接口发出任何路由更新信息：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Router（config-router）#Passive-interface f0/0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口接受路由表的更新，但是不发送报文出去&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;lsp-链接状态协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#lsp-链接状态协议&#34;&gt;#&lt;/a&gt; LSP 链接状态协议&lt;/h2&gt;
&lt;p&gt;基于链接状态的路由算法也称为 &lt;strong&gt;SPF（shortest path first，最短路径优先）算法&lt;/strong&gt;，维护复杂的拓扑信息数据库：对树处理路由表，没有环路问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LSA（Link State Advertisement，链路状态通告）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;链接状态网络发现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#链接状态网络发现&#34;&gt;#&lt;/a&gt; 链接状态网络发现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;路由器之间&lt;strong&gt;交换 LSA&lt;/strong&gt;，每个路由器都以直接连接的网络开头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个路由器与其他路由器并行&lt;strong&gt;构建一个拓扑数据库&lt;/strong&gt;，该拓扑数据库包含来自网络的所有 LSA。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SPF 算法计算网络可达性&lt;/strong&gt;：路由器将此逻辑拓扑构建为一棵树，以其自身为根，由链路状态协议互联网络中每个网络的所有可能路径组成。然后，对这些路径进行最短路径优先（SPF）排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路由器在路由表中列出其最佳路径以及这些目标网络的端口&lt;/strong&gt;。它还维护拓扑元素和状态详细信息的其他数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;链接状态更新&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#链接状态更新&#34;&gt;#&lt;/a&gt; 链接状态更新&lt;/h3&gt;
&lt;p&gt;如果有一个链路的状态发生变化（恢复或者被破坏），必须将修改通知给全部路由器消耗代价比较大（SPF 算法）。&lt;/p&gt;
&lt;h2 id=&#34;比较链接状态和距离矢量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#比较链接状态和距离矢量&#34;&gt;#&lt;/a&gt; 比较：链接状态和距离矢量&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;DV：距离矢量&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;视野窄，代价小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于跳数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定期交换路由表，收敛慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交换路由表&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LS：链路状态&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;
&lt;p&gt;视野宽，有一定代价&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于带宽&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初期充分交换，收敛快&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交换 Linked State 的数据库&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;混合协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#混合协议&#34;&gt;#&lt;/a&gt; 混合协议&lt;/h2&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;OSI’s IS-IS（Intermediate System-to-Intermediate System）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cisco’s EIGRP（Enhanced Interior Gateway Routing Protocol）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;主动路由协议-routing-protocol&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#主动路由协议-routing-protocol&#34;&gt;#&lt;/a&gt; 主动路由协议 Routing Protocol&lt;/h2&gt;
&lt;p&gt;主动路由协议的示例包括：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;英文缩写&lt;/th&gt;
&lt;th&gt;英文解释&lt;/th&gt;
&lt;th&gt;中文解释&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RIP&lt;/td&gt;
&lt;td&gt;a distance-vector routing protocol&lt;/td&gt;
&lt;td&gt;距离矢量协议&lt;/td&gt;
&lt;td&gt;DV&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IGRP&lt;/td&gt;
&lt;td&gt;Cisco’s distance-vector routing protocol IGRP&lt;/td&gt;
&lt;td&gt;思科的距离矢量路由协议&lt;/td&gt;
&lt;td&gt;DV，基本启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OSPF&lt;/td&gt;
&lt;td&gt;Open Shortest Path First&lt;/td&gt;
&lt;td&gt;开放式最短路径优先&lt;/td&gt;
&lt;td&gt;LSP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EIGRP&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;平衡的混合路由协议&lt;/td&gt;
&lt;td&gt;杂合&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;工作在第三层&lt;/p&gt;
&lt;h2 id=&#34;路由协议的主要目标&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#路由协议的主要目标&#34;&gt;#&lt;/a&gt; 路由协议的主要目标&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;最佳路线（&lt;strong&gt;Optimal Route&lt;/strong&gt;）：选择最佳路线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;效率（&lt;strong&gt;Efficiency&lt;/strong&gt;）：最少使用带宽和路由器处理器资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速收敛（&lt;strong&gt;Rapid Convergence&lt;/strong&gt;）：越快越好。有些比其他人收敛更快。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;灵活性（&lt;strong&gt;Flexibility&lt;/strong&gt;）：可以处理各种情况，例如高使用率和失败的路由&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何启用动态路由协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#如何启用动态路由协议&#34;&gt;#&lt;/a&gt; 如何启用动态路由协议&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Router(config)#router [protocol]&lt;/code&gt;  ， &lt;code&gt;[protocol&lt;/code&gt;  填 &lt;code&gt;rip&lt;/code&gt; ， &lt;code&gt;ospf&lt;/code&gt;  等&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Router(config)#network [network-number]&lt;/code&gt; ， &lt;code&gt;network-number&lt;/code&gt;  填直连网络号&lt;/p&gt;
&lt;h2 id=&#34;定义默认路由&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#定义默认路由&#34;&gt;#&lt;/a&gt; 定义默认路由&lt;/h2&gt;
&lt;p&gt;如果路由表中没有目标网络的条目，则将数据包发送到默认网络。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用动态路由协议定义默认路由： &lt;code&gt;Router(config)# ip default-network [network-number]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将默认路由定义为静态路由： &lt;code&gt;Router（config）## ip route 0.0.0.0 0.0.0.0 [next-hop-ipaddress| exit-interface]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置默认路由后，使用 show ip route 将显示：（172.16.1.2 是默认的下一跳地址）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不得已的网关是到网络 0.0.0.0 的 172.16.1.2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有不知道转发给谁的都给 172.16.1.2&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在  &lt;code&gt;ip route 0.0.0.0 0.0.0.0 &amp;lt;next-hop-ip&amp;gt;&lt;/code&gt;  这条配置中，&lt;strong&gt;默认路由&lt;/strong&gt;是指  &lt;code&gt;0.0.0.0 0.0.0.0&lt;/code&gt;  这一部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt; &lt;code&gt;0.0.0.0&lt;/code&gt; &lt;/strong&gt; 表示网络号，匹配所有的目标地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt; &lt;code&gt;0.0.0.0&lt;/code&gt; &lt;/strong&gt; 表示子网掩码，匹配所有网络范围。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：&lt;br /&gt;
当路由器接收到一个数据包且无法在路由表中找到更具体的匹配时，就会使用这条默认路由，并将数据包转发给  &lt;code&gt;&amp;lt;next-hop-ip&amp;gt;&lt;/code&gt; （下一跳地址）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认路由指向的下一跳地址&lt;/strong&gt;（ &lt;code&gt;&amp;lt;next-hop-ip&amp;gt;&lt;/code&gt; ）通常是出口网关，比如通向互联网的上级路由器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erinwithbmq.github.io/2025/01/11/CN6/</guid>
            <title>计网第六章 会话、表示、应用层</title>
            <link>https://erinwithbmq.github.io/2025/01/11/CN6/</link>
            <category term="南京大学软件工程专业课程" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" />
            <category term="大二上" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" />
            <category term="互联网计算" scheme="https://erinwithbmq.github.io/categories/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E4%BA%8C%E4%B8%8A/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" />
            <category term="复习资料" scheme="https://erinwithbmq.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/" />
            <pubDate>Sat, 11 Jan 2025 18:39:00 +0800</pubDate>
            <description><![CDATA[ &lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;互联网计算系列整理主要内容来自软院 2020 级学长&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9lYWdsZWJlYXIyMDAyLmdpdGh1Yi5pby8=&#34;&gt; EagleBear2002 的博客&lt;/span&gt;，为博主本人阅读后提炼整理的内容。&lt;br /&gt;
内容不算全面，仅推荐大家复习时参考。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;前两层略&lt;/p&gt;
&lt;h1 id=&#34;第七层应用层&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第七层应用层&#34;&gt;#&lt;/a&gt; 第七层：应用层&lt;/h1&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN6/image.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;上图中各层的一些协议和使用：会话层对端口进行管理&lt;/p&gt;
&lt;p&gt;第七层对应了应用界面，第六层对应了各种协议&lt;/p&gt;
&lt;p&gt;Telnet 端口不是 23 吗？&lt;/p&gt;
&lt;h2 id=&#34;超文本传输协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#超文本传输协议&#34;&gt;#&lt;/a&gt; 超文本传输协议&lt;/h2&gt;
&lt;h3 id=&#34;统一资源定位符-url&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#统一资源定位符-url&#34;&gt;#&lt;/a&gt; 统一资源定位符 URL&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;统一资源定位符 URL&lt;/strong&gt; 是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。&lt;/p&gt;
&lt;p&gt;格式： &lt;code&gt;&amp;lt;URL 的访问方式&amp;gt;：//&amp;lt;主机&amp;gt;：&amp;lt;端口&amp;gt;/&amp;lt;路径&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;访问方式：协议 HTTPS 或者 HTTP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机：域名的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;端口对应进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路径对应具体的文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;http&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#http&#34;&gt;#&lt;/a&gt; HTTP&lt;/h3&gt;
&lt;p&gt;HTTP 1.0 协议是&lt;strong&gt;无状态&lt;/strong&gt;的（stateless）&lt;/p&gt;
&lt;p&gt;HTTP 协议本身也是&lt;strong&gt;无连接&lt;/strong&gt;的，虽然它使用了面向连接的 TCP 向上提供的服务。&lt;/p&gt;
&lt;h3 id=&#34;http-的请求报文结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#http-的请求报文结构&#34;&gt;#&lt;/a&gt; HTTP 的请求报文结构&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN6/image%201.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;报文由三个部分组成，即开始行、首部行和实体主体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在请求报文中，开始行就是请求行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求报文和应答报文的应答结构都是一样的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应答码：&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;2xx：成功&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3xx：&lt;strong&gt;重定向&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4xx：错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5xx：&lt;strong&gt;服务器内部&lt;/strong&gt;错误，而不是客户端请求的错误&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;html&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#html&#34;&gt;#&lt;/a&gt; HTML&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HTML（HyperText Markup Language，超文本标记语言）&lt;/strong&gt;。略。&lt;/p&gt;
&lt;h2 id=&#34;ftp-和-tftp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#ftp-和-tftp&#34;&gt;#&lt;/a&gt; FTP 和 TFTP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;FTP （File Transfer Protocol）文件传输协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TFTP （Trivial File Transfer Protocol）简单文件传输协议&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FTP 是一种可靠的，&lt;strong&gt;面向连接&lt;/strong&gt;的服务，它使用 &lt;strong&gt;TCP&lt;/strong&gt; 传输文件。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;FTP 首先在客户端和服务器 **（端口 21）&lt;strong&gt;之间建立&lt;/strong&gt;控制连接 **&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后，建立第二个连接，这是计算机之间通过其传输数据的链接。&lt;strong&gt;（端口 20）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TFTP 是使用 &lt;strong&gt;UDP&lt;/strong&gt; 的&lt;strong&gt;无连接&lt;/strong&gt;服务（简化的 FTP）&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;体积小，易于实施。更加方便&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如。 TFTP 在路由器上用于传输配置文件和 Cisco IOS 映像&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持交互，没有目录浏览功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;strong&gt;端口 69&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;telnet-协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#telnet-协议&#34;&gt;#&lt;/a&gt; Telnet 协议&lt;/h2&gt;
&lt;p&gt;端口 23。用于远程连接主机。但是早不用这个了啊大家不都用 ssh 了吗。&lt;/p&gt;
&lt;h2 id=&#34;smtp-和-pop&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#smtp-和-pop&#34;&gt;#&lt;/a&gt; SMTP 和 POP&lt;/h2&gt;
&lt;p&gt;电子邮件服务器使用 SMTP 发送和 POP 接收邮件相互通信。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;**SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）** 邮件发送，登录发送等操作。端口号 25（也有其他端口）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;POP3（Post Office Protocol version 3，邮局协议版本 3）&lt;/strong&gt; 邮件接收，邮件到达邮件服务端，由客户端和服务端联系接收邮件。端口 110&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;发送者先登录到服务器，通过服务器根据 SMTP 传输到对应的服务器，然后用户登录后通过 POP3 协议收邮件到本地。&lt;/p&gt;
&lt;h3 id=&#34;mime&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#mime&#34;&gt;#&lt;/a&gt; MIME&lt;/h3&gt;
&lt;p&gt;**MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展）** 是一种互联网标准，用于扩展电子邮件协议，使其能够支持文本之外的多种类型的数据，包括图片、音频、视频、应用程序文件等。&lt;/p&gt;
&lt;p&gt;MIME 增加 5 个新的邮件首部：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MIME-Version 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Content-Description 说明邮件主体是否是图像、音频或视频&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Content-Id ：唯一标识符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Content-Transfer-Encoding 主体编码方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Content-Type 主体的数据类型和子类型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;与smtp的关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#与smtp的关系&#34;&gt;#&lt;/a&gt; 与 SMTP 的关系&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;SMTP 是传输协议，MIME 是数据格式标准。&lt;/p&gt;
&lt;p&gt;SMTP 定义了邮件&lt;strong&gt;如何传输&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;MIME 定义了邮件&lt;strong&gt;传输什么内容&lt;/strong&gt;以及&lt;strong&gt;内容的格式&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MIME 解决了 SMTP 的局限性，很多的文件（附件）并不是 ASCII 码的，我们需要用 MIME 将对应的文件进行转换。（因为 SMTP 只支持 7 位 ASCII 文本数据）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;snmp-简单网络管理协议&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#snmp-简单网络管理协议&#34;&gt;#&lt;/a&gt; SNMP 简单网络管理协议&lt;/h2&gt;
&lt;p&gt;端口 161/162&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;161&lt;/strong&gt;：用于管理端向代理端发送请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;162&lt;/strong&gt;：用于代理端向管理端发送告警（Trap）&lt;/p&gt;
&lt;p&gt;**SNMP（Simple Network Management Protocol，简单网络管理协议）** 是一种应用程序层协议，可简化网络设备之间的管理信息交换。&lt;/p&gt;
&lt;p&gt;SNMP 的通信基于 UDP 协议 通过广播进行实现&lt;/p&gt;
&lt;h2 id=&#34;dns-域名系统&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#dns-域名系统&#34;&gt;#&lt;/a&gt; DNS 域名系统&lt;/h2&gt;
&lt;p&gt;** 域名系统（Domain Name System，DNS）** 是网络上的服务，该服务管理域名并响应客户端将域名转换为关联 IP 地址的请求。&lt;/p&gt;
&lt;p&gt;端口 53&lt;/p&gt;
&lt;h3 id=&#34;结合域名服务器查找-ip-地址&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#结合域名服务器查找-ip-地址&#34;&gt;#&lt;/a&gt; 结合域名服务器查找 IP 地址&lt;/h3&gt;
&lt;p&gt;DNS 系统以层次（hierarchy）结构设置，该层次结构创建不同级别的 DNS 服务器。&lt;/p&gt;
&lt;p&gt;此级别的 DNS 服务器判断其自身是否能够将域名转换为关联的 IP 地址：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果可以，则将结果返回给客户端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有，它将请求发送到更高级别。（向上级请求）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN6/image-20230716093300053.png&#34; alt=&#34;https://eaglebear2002.github.io/61317/image-20230716093300053.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;应用层沟通的方式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#应用层沟通的方式&#34;&gt;#&lt;/a&gt; 应用层：沟通的方式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;无上下文，请求后就断开：如打开浏览器，连接到默认页面，并且该页面的文件将传输到客户端。处理完成后，连接断开。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有上下文：如 Telnet，FTP，建立与服务器的连接并保持该连接，直到执行所有处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;动态主机配置协议-dhcp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#动态主机配置协议-dhcp&#34;&gt;#&lt;/a&gt; 动态主机配置协议 DHCP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是一种网络管理协议，用于自动分配 IP 地址和其他网络参数（如子网掩码、默认网关、DNS 服务器）给网络中的设备。&lt;/p&gt;
&lt;h3 id=&#34;概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概述&#34;&gt;#&lt;/a&gt; 概述&lt;/h3&gt;
&lt;p&gt;接到因特网的计算机的协议软件需要配置的项目包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;IP 地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子网掩码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认路由器的 IP 地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;域名服务器的 IP 地址&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DHCP 可以高效地分配 IP 地址。是局域网的网络协议，使用 &lt;strong&gt;UDP&lt;/strong&gt; 来实现。&lt;/p&gt;
&lt;p&gt;目前一般都是自动获取 IP 地址，而不需要手动去获取 IP 地址等信息。&lt;/p&gt;
&lt;p&gt;服务器端口：67&lt;/p&gt;
&lt;p&gt;客户端端口：68&lt;/p&gt;
&lt;h3 id=&#34;过程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#过程&#34;&gt;#&lt;/a&gt; 过程&lt;/h3&gt;
&lt;h4 id=&#34;发现&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#发现&#34;&gt;#&lt;/a&gt; 发现&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN6/image%202.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;广播&lt;/p&gt;
&lt;h4 id=&#34;响应&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#响应&#34;&gt;#&lt;/a&gt; 响应&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN6/image%203.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;h4 id=&#34;选择&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#选择&#34;&gt;#&lt;/a&gt; 选择&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN6/image%204.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;DHCP Client 选择一个 DHCP Offer 报文（一般选择最先收到的 DHCP Offer 报文），向网络发送一个 DHCP Request &lt;strong&gt;广播&lt;/strong&gt;数据包，&lt;strong&gt;所有的 Server 进行同步&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;租约确认&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#租约确认&#34;&gt;#&lt;/a&gt; 租约确认&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;/image/CN6/image%205.png&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;广播&lt;/p&gt;
&lt;h4 id=&#34;租期续约&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#租期续约&#34;&gt;#&lt;/a&gt; 租期续约&lt;/h4&gt;
&lt;p&gt;在租期中，DHCP Client 直接向为其提供 IP 地址的 DHCP Server 发送 DHCP Request 消息，收到回应的 DHCP ACK 消息后，DHCP Client 根据所提供的新的租期以及其它更新的 TCP/IP 参数更新自己的配置，IP 租用更新完成&lt;/p&gt;
&lt;h4 id=&#34;租期释放&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#租期释放&#34;&gt;#&lt;/a&gt; 租期释放&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当 DHCP Client 不再需要使用分配 IP 地址时，就会主动向 DHCP Server 发送 Release 报文，告知不再需要分配 IP 地址，DHCP Server 会释放被绑定的租约&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到时间后，Server 会主动询问，如果没有应答会自动释放&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
